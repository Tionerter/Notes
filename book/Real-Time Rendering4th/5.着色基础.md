## 5.着色基础

​		渲染三维对象的图像时，模型不仅应具有适当的几何形状，而且还应具有所需的视觉外观。根据应用程序的不同，其范围可以从写实感（外观与真实物体的照片几乎相同）到出于创造性原因选择的各种类型的风格化外观。有关两者的示例，请参见图5.1。

​		本章将讨论同样适用于真实感渲染和风格化渲染的那些方面。第15章专门致力于风格化渲染，而本书的重要部分（第9章至第14章）则着重于通常基于物理的真实感渲染方法。

### 5.1着色模型

​		确定渲染对象外观的第一步是选择一个着色模型，用于描述对象的颜色如何根据表面取向，视图方向和光照等因素而产生变化。

​		例如，我们将使用Gooch着色模型[561]的变体。这是第15章讨论的非真实感渲染的一种形式。Gooch着色模型旨在提高技术插图(类似工艺品)中细节的清晰度。

​		Gooch着色背后的基本思想是将表面法线与光源的位置进行比较。如果法线指向灯光，则使用较暖的色调为表面着色；如果指向不对，则使用较冷的色调。介于两者之间的角度在这些色调之间进行插值，这取决于用户提供的表面颜色。在此示例中，我们向模型添加了风格化的“突出显示”效果，以使表面具有光泽外观。图5.2显示了实际的着色模型。

​		着色模型通常具有用于控制外观变化的属性。设置这些属性的值是确定对象外观的下一步。我们的示例模型只有一种属性，即表面颜色，如图5.2的底部图像所示。

![1570721010717](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1570721010717.png)

​		<font size=2>图5.1。顶部图像来自使用虚幻引擎渲染的真实风景场景。底部图片来自Campo Santo的游戏Firewatch，该游戏采用说明性艺术风格设计。 （上图由G̈okhanKaradayi提供，下图由Campo Santo提供。）</font>

​	![1570721041515](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1570721041515.png)

​		<font size=2>图5.2。风格化的着色模型，结合了Gooch着色和高光效果。顶部图像显示了具有中性表面颜色的复杂对象。下图显示了具有各种不同表面颜色的球体。 （来自计算机图形档案[1172]的中国龙网格，来自斯坦福3D扫描存储库的原始模型。）</font>

![1570721057335](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1570721057335.png)

​		<font size=2>图5.3。单位长度矢量输入到示例阴影模型（以及其他大多数着色模型）：表面法线n，视图矢量v和光照方向l。</font>

​		与大多数着色模型一样，此示例受与表面取向相关的视点和照明方向的影响。为了方便着色，这些方向通常表示为归一化（单位长度）向量，如图5.3所示。

​		现在，我们已经定义了阴影模型的所有输入，接下来可以看一下模型本身的数学定义：

​		
$$
\mathbf{c}_{shaded}=
s\textbf{c}_{highlight}+(1-s)(t\textbf{c}_{warm}+(1-t)\textbf{c}_{cool}).
\qquad\qquad(5.1)
$$
​		在此方程式中，我们使用了以下中间计算：
$$
\begin{align}
\textbf{c}_{cool}&=(0,0,0.55)+0.25\textbf{c}_{surface},\\
\textbf{c}_{warm}&=(0.3,0.3,0)+0.25\textbf{c}_{surface},\\
\textbf{c}_{highlight}&=(1,1,1),\\
t&=\frac{\mathbf{n}\cdot\mathbf{l}+1}{2},
\qquad\qquad(5.2)
\\
r&=2(\mathbf{n}\cdot\mathbf{l})\mathbf{n}-\mathbf{l},\\
s&=(100(\mathbf{r}\cdot\mathbf{v})-97)^{\mp}.
\end{align}
$$

​		该定义中的几个数学表达式也经常在其他着色模型中找到。着色操作中通常会进行区间限定操作，通常区间限定到0或在0到1之间。这里，我们将在1.2节中介绍的x表示法用于计算高光混合因子s，限制在0和1之间的区间。点积运算符出现3次，每次出现在两个单位长度的矢量之间；这是一种极为常见的运算。两个向量的点积是它们的长度与它们之间夹角的余弦的乘积。因此，两个单位长度向量的点积就是夹角的余弦，它是两个向量彼此相似程度的度量。由余弦组成的简单函数通常是最令人愉悦且最准确的数学表达式，用于说明着色模型中两个方向（例如，光线方向和表面法线）之间的关系。

​		另一种常见的着色操作是在两种颜色之间基于0到1之间的标量值的线性插值。该操作采用tca +（1- t）cb的形式，随着t的值在1和0之间移动，它会分别在ca和cb各自进行插值。此操作在此着色模型中出现了两次，第一是在$$\mathbf{c}_{warm}$$和$$\mathbf{c}_{cool}$$之间进行插值，第二是将第一的插值结果与$$\mathbf{c}_{hightlight}$$之间进行插值。线性插值在着色器中出现的频率很高，以至于在我们已经看到的每种着色语言中，它都是一个内置函数，称为lerp或mix。

​		线“ r = 2（n·l）n-l”计算反射光矢量，将l反射大约n。尽管不像前两个操作那样普遍，但是对于大多数着色语言来说，它也具有内置的反射功能就足够了。

​		通过将这些操作以不同的方式与各种数学表达式和着色参数组合在一起，可以为多种风格化和逼真的外观定义着色模型

### 5.2光源

​		光照对我们的示例着色模型的影响非常简单。它提供了着色的主要方向。当然，现实世界中的光照可能非常复杂，可以有多个光源，每个光源都有自己的大小，形状，颜色和强度。间接光照会带来更多变化。正如我们将在第9章中看到的那样，基于物理的真实感着色模型需要考虑所有这些参数。

​		相反，风格化的着色模型根据应用程序和视觉样式的需要可以以多种不同方式使用光照。但一些高度风格化的着色模型可能根本没有照明的概念，或者（例如我们的Gooch着色示例）可能仅使用光照来提供一些简单的方向性。

​		光照复杂性的下一步是使着色模型以二元关系对光的存在或不存在做出反应。使用这种着色模型的表面在受到光线影响时将具有一种外观，而在不受光线影响的情况下将具有另外不同的外观。这提供了区分这两种情况的一些准则：与光源的距离，阴影（将在第7章中讨论），表面是否背对光源（即表面法线n与光矢量l之间的角度大于90°），或这些因素的某种组合。

​		从光的二元存在或不存在到光强度的连续性，这都是一小步。这可以表示为不存在和完全存在之间的简单插值，可以表示为强度的有界范围，可能为0到1，或者表示为以无界数量级影响着色的某种方式。后者的一个常见选择是将着色模型分解为亮和不亮部分，而光强$$k_{light}$$线性缩放被亮部分：

​		
$$
\mathbf{c}_{shaded}=f_{unlit}(\mathbf{n},\mathbf{v})+
k_{light}f_{lit}(\mathbf{l},\mathbf{n},\mathbf{v})
\qquad\qquad(5.3)
$$
​		这可以轻松拓展为RGB型的光颜色：
$$
\mathbf{c}_{shaded}=f_{unlit}(\mathbf{n},\mathbf{v})+
c_{light}f_{lit}(\mathbf{l},\mathbf{n},\mathbf{v})
\qquad\qquad(5.4)
$$
​		和扩展为多光源：
$$
\mathbf{c}_{shaded}=f_{unlit}(\mathbf{n},\mathbf{v})+
\sum_{i=1}^{n}c_{light}f_{lit}(\mathbf{l},\mathbf{n},\mathbf{v})
\qquad\qquad(5.5)
$$
​		未受到光照的部分$$f_{unlit}$$（n，v）对应于将光视为二元存在的着色模型中的“不受光影响时的外观”。它可以具有各种形式，具体取决于所需的视觉样式和应用程序的需求。例如，$$f_{unlit}$$（）=（0,0,0）将使不受光源影响的任何表面变为纯黑色。另外，未照明的部分可以为未照明的对象表达某种形式的外观，类似于Gooch模型的冷色，用于远离光线的表面。通常，着色模型的这一部分表示某种形式的光照，这些光照并非直接来自明确放置的光源，例如来自天空的光或来自周围物体反射的光。这些其他形式的照明将在第10章和第11章中讨论。

​		前面我们提到过，如果光方向l与表面法线n的角度大于90°，则光源不会影响表面点，实际上是来自表面下面。这种情况可以视为表面和光照方向在对着色影响中的一种特殊情况。尽管是基于物理的，但这种关系可以从简单的几何原理中得出，并且对于许多基于非物理的类型的和风格化的着色模型也很有用。

​		可以将光在表面上的效果显示为一组射线，其中射线击中表面的密度对应于用于表面着色目的的光强度。参见图5.4，该图显示了光照表面的横截面。沿该截面入射到表面的光线之间的间距与l和n之间的角度的余弦成反比。因此，入射到表面的光线的总密度与l和n之间的角度的余弦成正比，正如我们之前所看到的，它等于这两个单位长度矢量之间的点积。在这里，我们看到了为什么定义与光的传播方向相反的光矢量l会很方便；否则，在执行点积运算之前，我们必须将其取反。

![image-20191201233449917](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191201233449917.png)

​		<font size=2>图5.4。图的上排示出了表面上的光的截面图。左侧的光线笔直地撞击表面，在中心的光线以一定角度撞击表面，在右侧，我们看到使用矢量点积来计算角度余弦。下图显示了相对于整个表面的横截面平面（包括光和视图向量）。</font>

​		更准确地说，当光线密度为正时，其光线密度（以及光线对着色的贡献）与点积成正比。负值对应于从表面后面发出的光线，无效。因此，在将光的着色乘以光照的点积之前，我们需要先将点积的值进行区间限定为0。使用第1.2节中介绍的$$x^+$$表示，即将负值置为零，我们有
$$
\mathbf{c}_{shaded}=f_{unlit}(\mathbf{n},\mathbf{v})+
\sum_{i=1}^{n}(\mathbf{l}_{i}\cdot\mathbf{n})^{+}c_{light}f_{lit}(\mathbf{l},\mathbf{n},\mathbf{v})
\qquad\qquad(5.6)
$$
​		支持多个光源的着色模型通常将使用公式5.5（更通用）或公式5.6（基于物理的模型所需）中的一种。公式5.6这对于风格化模型也可能是有利的，因为它有助于确保照明的总体一致性，尤其是对于背离灯光或阴影的表面。但是，某些模型不适用于该结构。此类模型将使用公式5.5。

​		函数flit()的最简单选择是使其颜色恒定，
$$
\mathbf{c}_{shaded}=f_{unlit}(\mathbf{n},\mathbf{v})+
\sum_{i=1}^{n}(\mathbf{l}_{i}\cdot\mathbf{n})^{+}c_{light}c_{sufface}
\qquad\qquad(5.8)
$$
​		该模型上收到光照的部分符合兰伯特着色模型，Johann Heinrich Lambert [967]（于1760年提出），该模型在理想的漫反射表面（即完全无光泽的表面）的背景下工作。在这里，我们对Lambert模型进行了一些简化的解释，将在第9章中更严格地介绍。Lambertian模型可以单独用于简单着色，它是许多着色模型的关键组成部分。

​		从公式5.3-5.6中可以看出，光源通过两个参数与着色模型交互：入射光的方向l和光的颜色$$c_{light}$$。有多种不同类型的光源，它们的主要区别在于这两个参数在场景中的变化方式。

​		接下来，我们将讨论几种流行类型的光源，它们有一个共同点：在给定的表面位置，每个光源仅从一个方向l照射表面。换句话说，从作色表面位置看，光源是一个无限小的点。对于现实世界的光源，这并非严格如此，但是大多数光源相对于它们与照明表面的距离较远，因此这是一个合理的近似值。在7.1.2和10.1节中，我们将讨论从多个方向照亮表面位置的光源，即“区域光”。

#### 5.2.1平行光

​		平行光是最简单的光源模型。l和$$c_{light}$$两个部分在整个场景中都保持不变，除了$$c_{light}$$可能受到阴影的影响而产生衰减。平行光在空间中没有具体的位置坐标，这和真实的光源不同。真实的光源一般在空间中都有明确的坐标位置。平行光是一种抽象概念，当场景到光源的距离远大于场景大小时，平行光是很好选择。例如，一个小的桌面模型受到距离20英尺远的泛光灯的照射，泛光灯可以被视为平行光。或者几乎所有受到太阳照射的场景，除了所涉及的场景是诸如太阳系内行星之类的场景。

​		可以扩展平行光的概念，允许在入射光方向l保持恒定的同时改变$$c_{light}$$的值。这种情况通常是将灯光效果绑定到场景的特定部分出于性能或者其他原因。例如，可以定义一个处于两个嵌套的（一个在另一个内）方形体积的区域，其中靠近外盒的$$c_{light}$$等于外盒外的（0,0,0）（纯黑色），靠近内盒的等于内盒的一个常量，而处于两个方形体积之间的区域的值将对两个$$c_{light}$$进行平滑插值。

#### 5.2.2精确光源

​		精确光源不是实时的光源，但精确光源具有位置坐标。与现实中的光源不同，此类光源没有大小，形状，尺寸信息。对于拉丁语中的“point”，我们用术语“punctual”来表示“point”，该术语包括源自单个局部位置的所有照明源。我们使用“point light”一词来表示一种特定类型的发射源，它在所有方向上均等地发射光。因此，点光源和聚光灯是精确光源的两种不同形式。入射光向量l随当前着色表面点$$p_{0}$$相对于点光源的位置$$p_{light}$$的位置而变化：
$$
\mathbf{l}=\frac{\mathbf{p}_{light}-\mathbf{p}_{0}}
{\Arrowvert\mathbf{p}_{light}-\mathbf{p}_{0}\Arrowvert}
\qquad\qquad(5.9)
$$
​		这个等式是向量归一化的一个例子：一个向量除以它的长度得到一个单位长度的和原向量同方向的向量。这是一个常见的作色运算，这和我们之前提到其他作色运算一样，对于大多数的着色语言都内置了这个运算。但是，有时需要此操作的中间结果，这需要使用更多基本操作以多个步骤显式执行归一化。将其应用于精确光源方向计算可以得到以下结果：
$$
\begin{align}
\mathbf{d}&=\mathbf{p}_{light}-\mathbf{p}_{0}\\
r&=\sqrt{\mathbf{d}\cdot\mathbf{d}}\\
\mathbf{l}&=\frac{\mathbf{d}}{r}
\qquad\qquad(5.10)
\end{align}
$$
​		两个向量间的点乘操作等于两个向量的长度乘以这两个向量之间的夹角的cos值，因为cos0°=1，所以点乘向量自身的操作等于该向量长度的平方。所以要想获得任意向量的长度只需要将该向量点乘自己然后开方。

​		我们所需要的中间值是r，从精确光源到当前作色点的距离。它除了用来归一化入射光向量，还被用来计算光线颜色的衰减其中$$c_{light}$$作为距离函数，这将在之后的章节讨论。

##### 点光源/全向光源

​		在所有方向上均匀发光的精确光源被称为点光源或全向光源。对于点光源，$$c_{light}$$的值作为距离r的函数，唯一的变化源是之前提到的距离衰减。图5.5使用类似于图5.4中余弦因数的几何推理，说明了为什么会变暗。在给定的表面上，来自点光源的射线之间的间隔与从表面到光源的距离成比例。与图5.4中的余弦因子不同，此间隔的增加沿表面上的两个维度发生，因此射线密度（光线颜色$$ c_{light}$$）与距离r的平方的倒数$$\frac{1}{r^2}$$成比例。这使我们能够使用单个光照属性$$c_{light_{0}}$$来指定$$ c_{light} $$的空间变化，该属性定义为在固定参考距离$$r_{0}$$处的$$c_{light}$$值：
$$
\mathbf{c}_{light}(r)=
\mathbf{c}_{light_{0}}(\frac{r_{0}}{r})^2
\qquad\qquad(5.11)
$$
​		等式5.11经常被称为平方反比光线衰减。尽管公式对点光源的距离衰减是对的，但还有一些问题让这个等式不能作为理想状态被实际的着色使用。

​		第一个问题是当相对距离过小的时候，公式中的r值趋向于0，$$c_{light}$$的值会无限的增大。当r的值等于0，我们会面临一个除零的问题，解决这个问题的一个方法是为分母添加一个极小的值$$\epsilon$$:

​		$$\epsilon$$值的精确大小取决于应用程序的需要，例如，虚幻引擎让$$\epsilon$$=1cm
$$
\mathbf{c}_{light}(r)=
\mathbf{c}_{light_{0}}\frac{r_{0}^2}{r^2+\epsilon}
\qquad\qquad(5.12)
$$
​		另一个方法是限制r的最小值到$$r_{min}$$，这在CryEngine和寒霜引擎中被使用

​		
$$
\mathbf{c}_{light}(r)=
\mathbf{c}_{light_{0}}
\begin{pmatrix}
\frac{r_{0}}
{max(r,r_{min})}
\end{pmatrix}
^2
\qquad\qquad(5.13)
$$
​		不同于先前方法中使用的任意$$ \epsilon $$值，$$r_{ min }$$的值具有物理解释：发射光的物理半径。 r小于$$r_{ min }$$的值对应于穿透物理光源内部的着色表面，这是不可能的。

![image-20191201233522012](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191201233522012.png)

​		<font size=2>图5.5。来自点光源的光线之间的间距与距离r成正比增加。由于间距的增加是二维的，因此光线的密度（以及光强度）成比例地降低随着1/r平方的增大。</font>

​		平方反比衰减的第二个问题发生在相对较大的距离处。问题不在于视觉效果，而在于性能。尽管光强度会随着距离的增加而降低，但它永远不会变为0。为进行高效渲染，希望光在某个有限距离处达到0强度（第20章）。可以通过多种不同的方式修改平方反比公式来实现这一目的。理想情况下，修改应引入尽可能少的更改。为了避免在光线影响的边界处出现明显的截止，还建议修改函数的导数和值在相同距离处达到0。一种解决方案是将平方函数乘以具有所需属性的开窗函数。虚幻引擎[861]和寒霜[960]游戏引擎都使用了这样一种功能[860]：

​		
$$
f_{win}(r)=
\begin{pmatrix}
1-(\frac{r}{r_{max}})^4
\end{pmatrix}^{+2}
\qquad\qquad(5.14)
$$
​		+2表示限定值，如果值为负数则限定值为0。图5.6展示了反比平方曲线和窗口函数乘积的结果。

![image-20191201233549219](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191201233549219.png)

​		<font size=2>图5.6。该图显示了平方反比曲线（使用ε方法避免奇异性，ε值为1），公式5.14中描述的窗口函数（rmax设置为3）和窗口曲线。</font>.

​		应用程序的需求将影响所用方法的选择。例如，当以相对较低的空间频率（例如，在光照贴图或每个顶点中）采样距离衰减函数时，在rmax处使导数等于0尤为重要。 CryEngine不使用光照贴图或顶点照明，因此它采用了更简单的调整，在0.8rmax和rmax之间变换为线性衰减[1591]。

​		对于某些应用程序，匹配平方反比曲线不是优先事项，因此完全使用其他功能函数。这有效地将公式5.11-5.14概括为以下内容：
$$
\mathbf{c}_{light}(r)=
\mathbf{c}_{light_{0}}f_{dist}(r)
\qquad\qquad(5.15)
$$
​		其中fdist（r）是距离的某些函数。这种函数称为距离衰减函数。在某些情况下，非反平方衰减函数的使用受性能约束。例如，“正当防卫2（Just Cause 2）”游戏需要的照明非常便利。它规定了一个衰减函数，该函数易于计算，同时还足够平滑，可以避免每个顶点的照明特效[1379]：

​		
$$
f_{dist}(r)=
\begin{pmatrix}
1-(\frac{r}{r_{max}})^2
\end{pmatrix}^{+2}
\qquad\qquad(5.16)
$$
​	在其他情况下，衰减功能的选择可能受到设计因素的影响。例如，用于真实感游戏和风格化游戏的虚幻引擎具有两种用于光衰减的模式：如公式5.12中所述的平方反比模式，以及可以调整以创建各种衰减曲线的指数衰减模式。 [1802]。游戏古墓丽影（2013）的开发人员使用样条编辑工具来编写衰减曲线[953]，从而可以更好地控制曲线形状。

##### 聚光灯

​		与点光源不同，几乎所有真实世界的光源照明都随方向和距离而变化。这种变化可以表示为方向衰减函数fdir（l），该函数与距离衰减函数结合以定义光强度的整体空间变化：
$$
\mathbf{c}_{light}=
\mathbf{c}_{light_{0}}f_{dist}(r)f_{dir}(r)
\qquad\qquad(5.17)
$$
​		选择不同的fdir（l）可以产生各种光照效果。其中一种重要的效果是聚光灯，它将光投射到圆锥形中。聚光灯的方向衰减函数具有围绕聚光灯方向矢量s的旋转对称性，因此可以表示为s与相对于表面的反向光线向量-l之间的角度θs的函数。需要反转光线向量，因为我们之前将光线向量l定义为从表面上指向光源，但在这里我们需要从光源发射的向量。

​		大多数聚光灯函数都使用由θs的余弦组成的表达式，这是着色中角度最常见的形式（如我们先前所见）。聚光灯通常具有本影角θu，该本影角对光进行限制，以使所有θs≥θu的fdir（l）= 0。该角度可以与前面看到的最大衰减距离rmax类似用于剔除。聚光灯通常还具有半影角θp，该半影角定义了一个内锥，在该锥中，光拥有其全部强度。见图5.7。

![image-20191201233607238](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191201233607238.png)

​		<font size=2>图5.7。聚光灯：θs是从灯的定义方向s到向量-l的角度，即到表面的方向； θp表示半影； θu表示为光定义的本影角。</font>

​		许多种类的方向衰减函数被聚光灯所使用，但它们往往大致相似。例如，函数FdirF（l）用于寒霜游戏引擎[960]，函数fdirT（l）用于three.js浏览器图形库[218]：
$$
\begin{align}
t&=
\begin{pmatrix}
\frac{\cos\theta_{s}-\cos\theta{u}}{\cos\theta_{p}-\cos\theta{u}}
\end{pmatrix}^{\mp},\\
f_{dir_{F}}(\mathbf{l})&=t^2,\\
f_{dir_{T}}(\mathbf{l})&=smoothstep(t)=t^2(3-2t).
\qquad\qquad(5.18)
\end{align}
$$
​		回想一下，$$x^{ \mp }$$是我们在1.2节中介绍的将限制在0和1之间的符号。平滑步长函数是三次多项式，通常用于着色中的平滑插值。它是大多数着色语言的内置函数。

​		图5.8显示了到目前为止我们讨论过的某些光源类型。

![image-20191201233621968](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191201233621968.png)

​		<font size=2>图5.8。某些类型的灯。从左到右：平行光，无衰减的点光源和平滑过渡的聚光灯。请注意，由于光线和表面之间的角度变化，点光会朝边缘变暗。</font>

##### 其他类型的精确光源

​		精确光源中clight的部分的值可以通过多种方式进行变化。

​		fdir（l）函数不仅限于上述简单的聚光灯衰减功能；它可以表示任何类型的方向变化，包括从实际光源测量的复杂列表模式。照明工程协会（IES）已为此类测量定义了标准文件格式。 IES配置文件可从许多照明设备制造商处获得，并已用于游戏Killzone：Shadow Fall [379，380]，以及虚幻 [861]和寒霜 [960]游戏引擎中。 Lagarde很好地总结了[961]在解析使用此文件格式中的问题。

​		游戏《古墓丽影》（Tomb Raider，2013年）[953]具有一种精确光源，可对沿x，y和z世界轴的距离应用独立的衰减功能。在《古墓丽影》中，曲线还应用于随时间变化的光强，例如产生闪烁的手电筒。

​		在第6.9节中，我们将讨论如何通过使用纹理来改变光强和颜色。

#### 5.2.3其他光照类型

​		平行光和精确光源的主要特征是光线方向l是如何计算的。可以通过使用其他方法来计算光线方向来定义不同类型的光。例如，除了前面提到的光源类型外，古墓丽影还拥有使用线段作为光源而不是点的胶囊灯[953]。对于每个着色像素，将线段上最接近点的方向用作光线方向l。

​		一旦着色器拥有在着色方程中使用的l和clight值，可以使用任何方法去计算这些值。

​		到目前为止讨论的光的类型是抽象的。实际上光源具有大小和形状，并且它们从多个方向照亮表面点。在渲染中，此类光源称为区域光源，它们在实时应用程序中的使用稳步增长。区域光渲染技术分为两类：一种模拟由于区域光受到部分遮挡而产生的阴影，阴影边缘变柔和的技术（第7.1.2节），和模拟区域光对表面着色的影响的技术。 （第10.1节）。第二类光照对于光滑的镜面表面最为明显，在这种表面上，可以通过反射清楚地看到光源的形状和大小。平行光和精确光源不太可能被废弃，尽管它们不再像过去那样普遍。已经开发出一种近似光照面积而且实现起来相对简单的技术，因此得到了广泛的应用。GPU性能的增强还允许使用比过去更复杂的技术。

### 5.3实现着色模型

​		为了发挥作用，这些着色和光照方程式当然必须在代码中实现。在本节中，我们将介绍设计和编写此类实现的一些关键注意事项。我们还将逐步介绍一个简单的实现示例。

#### 5.3.1评估频率

​		在设计着色实现时，需要根据计算频率对计算进行划分。首先，确定给定计算的结果在整个draw call中是否始终恒定。在这种情况下，尽管GPU计算着色器可用于特别昂贵的计算，但计算通常可由应用程序在CPU上执行。得到的结果通过统一的着色器输入传递到图形API。

​		即使在这一类别中，也可能有各种各样的可能的评估频率，从“一次性”开始。这种情况最简单的情况就是着色方程式中的常数子表达式，但这可以应用于基于很少更改的诸如硬件配置和安装选项之类的因素。当编译着色器时可以解决这种着色计算，在这种情况下，甚至不需要设置统一的着色器输入。或者，可以在安装时或在加载应用程序时在离线预计算过程中执行这种计算。

​		另一种情况是，着色计算的结果在整个应用程序运行中发生变化，但是变化速度如此之慢以至于不需要在每一帧进行更新。例如，光照因素取决于虚拟游戏世界中的一天中的时间。如果计算成本很高，则需要在多个帧上进行摊销。

​		其他情况包括每帧执行一次的计算，例如合并视图和透视矩阵。或每个模型一次，例如根据位置更新模型照明参数；或每次绘图调用一次，例如，更新模型中每种材质的参数。通过评估频率将统一的着色器输入分组有助于提高应用程序的效率，并且还可以通过最大程度地减少持续更新来提高GPU性能[1165]。

​		如果着色计算的结果在一次绘制调用中发生更改，则无法通过统一的着色器输入将其传递给着色器。取而代之的是，它必须由第3章中描述的可编程着色器阶段之一进行计算，并在需要时通过更改着色器输入传递到其他阶段。从理论上讲，可以在任何可编程阶段执行着色计算，每个阶段对应于不同的评估频率：

  * 顶点着色器——每个曲面细分顶点之前评估
  * 外壳着色器——评估每个表面的面片
  * 域着色器——每个曲面细分顶点之后评估
  * 几何着色器——每个图元评估
  * 像素着色器——每个像素评估

​		实际上，大多数着色计算是针对每个像素执行的。尽管这些通常是在像素着色器中实现的，但计算着色器的实现却越来越普遍。第20章将讨论几个示例。其他阶段主要用于几何运算，例如变换和变形。为了理解为什么会这样，我们将比较每个顶点和每个像素着色评估的结果。在较早的文本中，有时有时将它们分别称为Gouraud着色[578]和Phong着色[1414]，尽管这些术语在今天并不常用。该比较使用的着色模型与公式5.1中的阴影模型有些相似，但经过修改可与多个光源一起使用。完整的模型将在稍后我们详细介绍示例实现时给出。

​		图5.9显示了在具有大量顶点密度的模型上按像素和按顶点着色的结果。对于龙来说，这是一个非常致密的网格，两者之间的差异很小。但是在茶壶上，顶点着色评估会导致可见的错误，例如成角度的高光，而在两个三角形平面上，顶点着色版本显然是不正确的。这些错误的原因是，着色方程的各个部分（尤其是高光）的值在网格表面上非线性地变化。这使得它们不适合顶点着色器，其结果在被馈送到像素着色器之前在三角形上线性插值。

![image-20191201233655017](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191201233655017.png)

​		<font size=2>图5.9。比较公式5.19中示例阴影模型的每个像素和每个顶点的评估结果的比较，显示在顶点密度不同的三个模型上。左列显示每个像素的评估结果，中间列显示每个顶点的评估，右列显示每个模型的线框渲染以显示顶点密度。 （来自计算机图形档案[1172]的中国龙网格，来自斯坦福3D扫描存储库的原始模型。）</font>

​		原则上，仅计算着色模型的镜面反射的高光部分是可能的在像素着色器中，并在顶点着色器中计算其余部分。这可能不会导致视觉误差，并且理论上将节省一些计算。实际上，这种混合实现通常不是最佳的。着色模型的线性变化部分往往在计算上花费最少，并且以这种方式拆分着色计算往往会增加一定的开销（例如重复计算和其他变化的输入），从而弊大于利。
​		如前所述，在大多数实现中，顶点着色器负责非着色操作，例如几何变换和变形。生成的几何表面属性（转换为适当的坐标系）由顶点着色器写入，在三角形上线性插值，并作为变化的着色器输入传递到像素着色器中。这些属性通常包括曲面的位置，曲面法线以及（如果需要）法线贴图，还可以包括曲面切线向量。
​		请注意，即使顶点着色器始终生成单位长度的表面法线，插值也可以更改其长度。参见图5.10的左侧。因此，需要在像素着色器中对法线进行重新归一化（缩放为长度1）。但是，顶点着色器生成的法线的长度仍然很重要。如果法线长度在各个顶点之间变化很大，例如，作为顶点融合的副作用，这将使插值倾斜。这可以在图5.10的右侧看到。由于这两种效果，实现常常在插值之前和之后，即在顶点着色器和像素着色器中，对插值矢量进行归一化。

![image-20191201233711504](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191201233711504.png)

​		<font size=2>图5.10。在左侧，我们看到单位法线在整个表面上的线性插值会产生长度小于1的插值向量。在右侧，我们看到具有明显不同长度的法线的线性插值导致插值方向偏向两个法线中的较长方向。</font>

​		与表面法线不同，通常不插值指向特定位置的矢量，例如视图矢量和点光源的光线矢量。取而代之的是，使用插值的表面位置来计算像素着色器中的这些向量。除了需要在像素着色器中执行的归一化之外，在任何情况下这些向量中的每一个都是通过向量减法来计算的，这很快。如果出于某种原因有必要对这些向量进行插值，请不要事先对其进行归一化。如图5.11所示，这将导致错误的结果。

![image-20191201233726314](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191201233726314.png)

​		<font size=2>图5.11。两个光向量之间的插值。在左侧，在插值前对其进行归一化会导致插值后方向不正确。在右侧，对未归一化的向量进行插值可得出正确的结果。</font>

​		前面我们提到顶点着色器将表面几何形状转换为“适当的坐标系”。通过统一变量传递到像素着色器的相机和灯光位置通常由应用程序转换为相同的坐标系。这样可以最大程度地减少像素着色器将所有阴影模型矢量带入相同坐标空间的工作。但是，哪个协调系统是“适当的”系统？可能性包括全局世界空间以及相机的局部坐标系，或者更罕见的是当前渲染模型的局部坐标系。通常根据系统性能（例如性能，灵活性和简单性）为整个渲染系统做出选择。例如，如果预计渲染的场景将包含大量灯光，则可以选择世界空间以避免变换灯光位置。或者，最好使用摄像机空间，以更好地优化与视图矢量有关的像素着色器操作，并可能提高精度（第16.6节）。

​		尽管大多数着色器实现（包括我们将要讨论的示例实现）都遵循上述一般概述，但当然也有例外。例如，某些应用出于风格原因选择了原始着色评估的多面外观。这种样式通常称为平面着色。图5.12中显示了两个示例。

![image-20191216224545211](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216224545211.png)

​		<font size=2>图5.12。 有两种使用平面阴影作为样式选择的游戏：肯塔基州零号路线（顶部）和巨龙（巨蟹座），底部。 （上部图片由Cardboard Computer提供，下部图片由Numinous Games提供。）</font>>

​		原则上，可以在几何着色器中执行平面着色，但是最近的实现通常使用顶点着色器。这是通过将每个图元的属性与其第一个顶点相关联并禁用顶点值插值来完成的。禁用插值（可以分别为每个顶点值完成）将导致第一个顶点的值传递到图元中的所有像素。

#### 5.3.2实现样例

​		现在，我们将提供一个实现着色模型的示例。 如前所述，我们正在实现的着色模型与从公式5.1中扩展的Gooch模型相似，但修改可与多个光源一起使用。 它由以下描述
$$
\mathbf{c}_{shaded}=\frac{1}{2}\mathbf{c}_{cool}+\sum^n_{i=1}(\mathbf{l}_i\cdot\mathbf{n})^+\mathbf{c}{light}_i(s_i\mathbf{c}_{hightlight}+(1-s_i)\mathbf{c}_{warm}),
\qquad\qquad(5.19)
$$
​		中间值由以下计算：
$$
\begin{align}
\mathbf{c}_{cool}&=(0,0,0.55)+0.25\mathbf{c}_{surface},\\
\mathbf{c}_{warm}&=(0.3,0.3,0)+0.25\mathbf{c}_{surface},\\
\mathbf{c}_{hightlight}&=(2,2,2),\\
\mathbf{r}_{i}&=2(\mathbf{n}\cdot\mathbf{l}_i)\mathbf{n}-\mathbf{l}_i,\\
s_i&=(100(\mathbf{r}_i\cdot\mathbf{v})-97)^\mp.\\
\end{align}
\qquad\qquad(5.20)
$$
​		该公式适合公式5.6中的多光源结构，为方便起见，在此重复：
$$
\mathbf{c}_{shaded}=f_{unlit}(\mathbf{n},\mathbf{v})+\sum^n_{i=1}(\mathbf{l}_i\cdot\mathbf{n})^+\mathbf{c}{light}_i f_{lit}(\mathbf{l}_i,\mathbf{n},\mathbf{v}).
$$
​		在这种情况下，照亮和不照亮项的是
$$
\begin{align}
f_{unlit}(\mathbf{n},\mathbf{v})&=\frac{1}{2}\mathbf{c}_{\text{cool}},\\
f_{lit}(\mathbf{l}_i,\mathbf{n},\mathbf{v})&=s_i\mathbf{c}_{hightlight}+(1-s_i)\mathbf{c}_{warm},
\end{align}
\qquad\qquad(5.21)
$$
​		调整冷色项的不亮贡献，使结果看起来更像原始方程式。

​		在大多数典型的渲染应用程序中，诸如$\mathbf{c}_{surface}$之类的材质属性的变化值将存储在顶点数据中，或更常见的是存储在纹理中（第6章）。 但是，为使此实现示例简单，我们将假设$\mathbf{c}_{surface}$在整个模型中是恒定的。

​		此实现将使用着色器的动态分支功能遍历所有光源。虽然这种简单的方法可以在相当简单的场景中很好地使用，但对于具有许多光源的大型且复杂的几何场景却无法很好地缩放。第20章将介绍有效处理大量光源的渲染技术。此外，为了简单起见，我们将仅支持一种光源：点光源。尽管实现非常简单，但是它是前面介绍的最佳实践。

​		着色模型不是孤立实现的，而是在更大的渲染框架中实现的。这个例子是在一个简单的WebGL 2应用程序中实现的，该应用程序由Tarek Sherif [1623]的“ Phong-shaded Cube” WebGL 2示例进行了修改，但是相同的原理也适用于更复杂的框架。

​		我们将讨论来自应用程序的GLSL着色器代码和JavaScript WebGL调用的一些示例。目的不是讲授WebGL API的细节，而是展示普遍的实现原理。我们将以“由内而外”的顺序进行实现，首先是像素着色器，然后是顶点着色器，最后是应用程序方向的图形API调用。

​		在着色器代码完全之前，着色器源包括着色器输入和输出的定义。 如第3.3节中所述，使用GLSL术语，着色器输入分为两类。 其中之一是一组统一的输入，这些输入值由应用程序设置并且在绘制调用中保持不变。 另一种类型由变化的输入组成，这些输入值可以在着色器调用（像素或顶点）之间改变。 在这里，我们看到像素着色器的各种输入（在GLSL中被标记）及其输出的定义：

```GLSL
in vec3 vPos;
in vec3 vNormal;
out vec4 outColor;
```

​		此像素着色器具有单个输出，即最终的着色颜色。 像素着色器输入与顶点着色器输出匹配，顶点着色器输出在送到像素着色器之前由三角形上进行插值。 该像素着色器具有两个不同的输入：表面位置和表面法线，两者都在应用程序的世界空间坐标系中。统一输入的数量要大得多，因此，为了简便起见，我们仅显示两个定义，这两者均与光源有关：

```GLSL
struct Light {
  vec4 position;
  vec4 color;
 };
uniform LightUBlock {
  Light uLights[MAXLIGHTS];
};
uniform uint uLightCount;
```

​		由于这些是点光源，因此每个光源的定义都包括一个位置和一个颜色。 为了符合GLSL std140数据设计标准的限制，将它们定义为vec4而不是vec3。 尽管在这种情况下std140布局可能会导致一些空间的浪费，但它简化了确保CPU和GPU之间的数据设计一致的任务，这就是我们在此示例中使用它的原因。 Light结构体数组是在一个统一块内定义的，该块是GLSL功能，用于将一组统一变量绑定到缓冲区对象，以加快数据传输速度。 数组长度定义为等于应用程序在单个绘制调用中允许的最大灯光数量。 稍后我们将看到，应用程序在编译着色器之前将着色器源中的MAXLIGHTS字符串替换为正确的值（本例中为10）。 统一整型uLightCount是绘制调用中的实际处于激活状态的灯光数。
​		接下来，我们将看一下像素着色器代码：

```GLSL
vec3 lit(vec3 l, vec3 n, vec3 v) {
	vec3 r_l = reflect(-l, n);
	float s = clamp(100.0 * dot(r_l, v) - 97.0, 0.0, 1.0);
	vec3 highlightColor = vec3(2,2,2);
	return mix(uWarmColor , highlightColor , s);
}
void main () {
	vec3 n = normalize(vNormal);
	vec3 v = normalize(uEyePosition.xyz - vPos);
	outColor = vec4(uFUnlit , 1.0);
	for (uint i = 0u; i < uLightCount; i++) {
  		vec3 l = normalize(uLights[i].position.xyz - vPos);
    	float NdL = clamp(dot(n, l), 0.0, 1.0);
  		outColor.rgb += NdL * uLights[i].color.rgb * lit(l,n,v);
  }
}
```


​		我们有一个关于照亮项的函数定义，它由main（）函数调用。总的来说，这是方程式5.20和5.21的简单GLSL实现。请注意，$f_{unlit}()$和$\mathbf{c}_{warm}$的值作为统一变量传入。由于这些值在整个绘制调用中是恒定的，因此应用程序可以计算这些值，从而节省了一些GPU周期。

​		该像素着色器使用了几个内置的GLSL函数。 reflect（）函数反射一个向量（在此情况下为光向量）在第二个向量（在这种情况下是表面法线）定义的平面上。由于我们希望光向量和反射向量都指向远离表面的位置，因此我们需要将前者传递给reflect（）之前对其取反。 clamp（）函数具有三个输入。其中两个限制了第三个输入的范围。在大多数GPU上，到0到1（与HLSL saturate（）函数相对应）之间的范围的夹取是快速的，通常有高效的释放。这就是为什么我们在这里使用它的原因，尽管我们只需要将值限制到0（因为我们知道它不会超过1）。函数mix（）也具有三个输入，并在两个输入之间线性插值，即暖色和高光颜色在这种情况下，取决第三个值（介于0和1之间的混合参数）。在HLSL中，此函数称为lerp（），用于“线性插值”。最后，normalize（）将向量除以其长度，将其长度缩放到1。

​		现在让我们看一下顶点着色器。由于我们已经看到了像素着色器的一些统一定义（uniform definitions）示例，因此我们将不显示其任何统一定义，但是变化的输入和输出定义值得研究：

```GLSL
layout(location=0) in vec4 position;
layout(location=1) in vec4 normal;
out vec3 vPos;
out vec3 vNormal;
```

​		请注意，如前所述，顶点着色器输出与像素着色器变化的输入匹配。 输入包含指令，这些指令指定如何在顶点数组中排列数据。 接下来是顶点着色器代码：

```GLSL
void main () {
	vec4 worldPosition = uModel * position;
	vPos = worldPosition.xyz;
	vNormal = (uModel * normal).xyz;
	gl_Position = viewProj * worldPosition;
}
```

​		这些是顶点着色器的常用操作。着色器将表面位置和法线转换为世界空间，并将它们传递给像素着色器以用于着色。最后，将表面位置转换为裁剪空间，并将其传递给gl_position，这是是光栅器使用的特殊系统定义的变量。 gl_position变量是任何顶点着色器的必需输出。

​		请注意，法线向量未在顶点着色器中归一化。由于它们在原始网格数据中的长度为1，因此不需要进行归一化，并且此应用程序不会执行任何可能会不均匀改变其长度的操作，例如顶点混合或不均匀缩放。模型矩阵可以具有统一的缩放因子，但是会成比例地改变所有法线的长度，因此不会导致图5.10右侧所示的问题。

​		该应用程序使用WebGL API进行各种渲染和着色器设置。每个可编程着色器阶段都是单独设置的，然后将它们都绑定到一个程序对象。这是像素着色器设置代码：

```GLSL
var fSource = document.getElementById("fragment").text.trim();

var maxLights = 10;
fSource = fSource.replace(/MAXLIGHTS/g, maxLights.toString());

var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fragmentShader , fSource);
gl.compileShader(fragmentShader);
```

​		请注意“片段着色器”参考。 WebGL（以及它所基于的OpenGL）使用此术语。如本书前面所述，尽管“像素着色器”在某些方面不那么明确，但它是更常见的用法，我们在本书中将继续进行。该代码也是将MAXLIGHTS字符串替换为适当的数值的地方。大多数渲染框架执行类似的预编译着色器操作。

​		还有更多的应用程序端代码用于设置统一，初始化顶点数组，清除，绘制等，您可以在程序[1623]中查看这些代码，并且许多API指南对此进行了说明。我们的目标是理解着色器如何被视为单独的处理器在它们自身的编程环境下。因此，我们现在结束本示例。

#### 5.3.3材质系统

​		就像我们的简单示例一样，渲染框架很少只实现一个着色器。 通常，需要一个专用系统来处理应用程序使用的各种材质，着色模型和着色器。

​		如前几章所述，着色器是GPU的可编程着色器阶段之一的程序。 因此，它是低级图形API资源，而不是美工可以直接与其交互的东西。 相反，材质是面向美工的平面视觉外观的封装。 材质有时还会描述非视觉方面，例如碰撞属性，由于它们不在本书的讨论范围之内，因此我们将不对其进行进一步讨论。

​		虽然材质是通过着色器实现的，但这并不是简单的一对一对应。在不同的渲染情况下，相同的材质可能使用不同的着色器。一个着色器也可以由多种材质共享。最常见的情况是参数化材质。以最简单的形式，材质参数化需要两种类型的材质实体：材质模板和材质实例。每个材质模板都描述了一类材质，并具有一组参数，可以根据参数类型为它们分配数字，颜色或纹理值。每个物料实例都对应一个材质模板，外加其所有参数的一组特定值。诸如Unreal Engine [1802]之类的某些渲染框架允许使用更复杂的层次结构，其中材质模板是从多个级别的其他模板派生的。

​		可以在运行时通过将统一的输入传递给着色器程序来解析参数，也可以在编译时通过在着色器被编译之前替换值来解析参数。一种常见的编译时参数类型是布尔型，它控制给定材质的特征是否激活。这可以由美工人员通过材质用户界面中的复选框设置，也可以由材质系统程序设置，例如，可忽略的远处物体的视觉效果以减低着色器开销。

​		尽管材质的参数可能与着色模型中参数一一对应，但并非总是如此。一个材质可以将给定着色模型参数的值（例如表面颜色）固定为恒定值。或者，一个着色模型的参数被计算作为一系列复杂的操作（将多个材质参数以及经过插值的顶点或纹理值作为输入）。在某些情况下，诸如平面位置，平面方向甚至时间之类的参数也可能会影响计算。基于表面位置和方向的着色在地形材质中尤其常见。例如，高度和表面法线可用于控制降雪效果，在高海拔几乎水平的表面上和白色表面颜色混合。基于时间的着色在动画材质中很常见，例如闪烁的霓虹灯。

​		材质系统最重要的任务之一是将各种着色器功能划分为单独的元素，并控制这些元素的组合方式。在许多情况下，这种类型的组合很有用，包括以下几种：

* 使用几何处理（例如，刚体变换，顶点混合，渐变，曲面细分，实例化和裁剪）来构成表面着色。 这些功能各不相同：表面着色取决于材质，几何处理取决于网格。 因此，分别编写它们并让材质系统根据需要进行组合很方便。

* 使用诸如像素丢弃和混合之类的合成操作来构成表面着色。 这与移动GPU尤其相关，在移动GPU中，混合通常是在像素着色器中执行的。 通常希望选择让这些操作独立于材质来用于表面着色。

* 将用于计算着色模型参数的操作与着色模型本身的计算组合在一起。 这允许只编写一次着色模型实现，然后将其与各种不同方法结合使用来用于计算阴影模型参数。

* 互相组合单个可选的材质特征，选择逻辑和着色器的其余部分。 这样可以分别编写每个功能的实现。

* 构成着色模型并通过光源评估计算其参数：计算每个光源在着色点的$\mathbf{c}_{light}$和$l$值。 延迟渲染（在第20章中讨论）等技术会更改此构成的结构。 在支持多种此类技术的渲染框架中，这增加了一层额外的复杂性。

​		如果图形API提供这种类型的着色器代码模块作为核心功能，将会很方便。可悲的是，与CPU代码不同，GPU着色器不允许对代码片段进行编译后链接。每个着色器阶段的程序都作为一个单元编译。着色器阶段之间的分隔确实提供了一些有限的模块化，这在某种程度上匹配我们列表中的第一项：通过几何处理（通常在其他着色器阶段中执行）来构成表面着色（通常在像素着色器中执行）。但是这种匹配并不完美，因为每个着色器也执行其他操作，并且仍然需要处理其他类型的组合。考虑到这些限制，材质系统可以实现所有这些类型的合成的唯一方法是在源代码级别。这主要涉及字符串操作，例如连接和替换，通常通过C风格的预处理指令（例如＃include，＃if和#define）执行。

​		早期的渲染系统具有相对较少的着色器变量，并且通常每个都是手动编写的。这有一些好处。例如，可以在完全了解最终着色器程序的情况下优化每个变量。但是，随着变量数量的增加，这种方法很快变得不切实际。当考虑到所有不同的部分和选项时，可能存在的不同着色器变量数量很多。这就是为什么模块化和可组合性如此重要的原因。

​		设计用于处理着色器变量的系统时要解决的第一个问题是，是在运行时通过动态分支还是在编译时通过条件预处理在不同选项之间进行选择。在较旧的硬件上，动态分支通常是不可能或非常缓慢的，因此，运行时选择不是一个选择。然后所有变量都在编译时进行处理，包括对不同光源类型数量的所有可能组合[1193]。

​		相反，当前的GPU可以很好地处理动态分支，尤其是在一次绘制调用中所有像素的分支行为相同时。 如今，许多功能变量（例如灯光数量）都在运行时处理。 但是，向着色器添加大量功能变量会产生不同的成本：寄存器数量的增加和占用率的相应降低，进而导致性能降低。有关更多详细信息，请参见第18.4.5节。 因此，编译时变量仍然很有价值。 它避免包含永远不会执行的复杂逻辑。

​		例如，让我们想象一个支持三种不同类型灯光的应用程序。两种光源类型很简单：点光源和平行光源。第三种是支持列表照明模式和其他复杂功能的通用聚光灯，需要大量的着色器代码才能实现。但是，比方说，通用聚光灯很少使用，在应用程序中只有不到5％的灯是这种类型的。过去，将为三种灯源类型的数量的每种可能组合编译成单独的着色器变量，以避免动态分支。尽管今天并不需要，但是编译两个单独的变量仍然是有益的，一个变量适用于通用聚光灯的数量等于或大于1的情况，而另一个变量适用于此类聚光灯的数量恰好等于0的情况。由于其代码更简单，因此第二种变量（最常用）可能具有较低的寄存器占用率，从而具有更高的性能。

​		现代材质系统同时使用了运行时着色器变量和编译时着色器变量。即使不再只在编译时处理全部负担，但总体复杂性和变量数量仍在增加，因此仍需要编译大量着色器变量。例如，在《命运：被占领的国王》游戏的某些区域中，在单个帧中使用了9000多种编译的着色器变量[1750]。可能的变量数量可能会更大，例如，Unity渲染系统的着色器具有接近1000亿个可能的变量。仅编译实际使用的变量，但是必须重新设计着色器编译系统以处理大量可能的变量[1439]。

​		材质系统设计师采用不同的策略来解决这些设计目标。尽管有时将它们表示为互斥的系统结构[342]，但这些策略可以（通常是）合并在同一系统中。这些策略包括：

* 代码重用——在共享文件中实现功能，使用#include预处理程序指令访问这些功能从需要它们的任何着色器中。
* 减法——一个着色器，通常称为超级着色器[1170，1784]，使用编译时预处理器条件和动态分支的组合来聚集大量功能，以删除未使用的部分并在互斥的选择中切换。
* 加法——各种功能定义为具有输入和输出连接器的节点，并将它们组合在一起。这类似于代码重用策略，但结构更清晰。节点的组成可以通过文本[342]或可视图形编辑器完成。后者旨在使非工程师（例如技术美术）更容易编写新的材质模板[1750，1802]。通常，可视化图形创作只能访问着色器的一部分。例如，在虚幻引擎中，图形编辑器只能影响着色模型输入的计算[1802]。参见图5.13。
* 基于模板——定义了一个接口，只要符合该接口，就可以插入不同的实现。 这比加法策略更为正式，通常用于较大的功能块。 这种接口的一个常见示例是遮光模型参数的计算与遮光模型本身的计算之间的分离。 虚幻引擎[1802]具有不同的“材质域”，其中包括用于计算着色模型参数的表面域和用于计算对给定光源调制$\mathbf{c}_{light}$的标量值的光函数域。 Unity [1437]中也存在类似的“表面着色器”结构。 注意，延迟着色技术（在第20章中讨论过）采用G缓冲区作为接口，实现了类似的结构。

​		![image-20191216224645030](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216224645030.png)

​		<font size=2>图5.13。 虚幻引擎材质编辑器。 注意节点图右侧的高节点。 该节点的输入连接器对应于渲染引擎使用的各种着色输入，包括所有着色模型参数。 （材质样本由Epic Games提供。）</font>

​		对于更特殊的示例，（现在免费的）WebGL Insights [301]一书中的几章讨论了各种引擎如何控制其着色器管线。 除了组合之外，现代材质系统还有其他一些重要的设计注意事项，例如需要以最少的着色器代码重复来支持多个平台。 这包括功能上的变化，以解决平台，着色语言和API之间的性能和功能差异。 Des-tiny着色器系统[1750]是此类问题的一种代表性解决方案。 它使用专有的预处理器层，该层接受着色语言编写的着色器。 这允许编写与平台无关的材质，并自动翻译成不同的着色语言和实现。 虚幻引擎[1802]和Unity [1436]具有相似的系统。

​		材质系统还需要确保良好的性能。除了对着色变体进行专门编译外，材质系统还可以执行其他一些常见的优化。 Destiny着色器系统和虚幻引擎会自动检测在一次绘制调用中保持不变的计算（例如，较早实现示例中的暖色和冷色计算）并将其移到着色器之外。另一个示例是Destiny中使用的范围界定系统，以区分以不同频率更新的常量（例如，每帧一次，每个灯光一次，每个对象一次）并在适当的时间更新每组常量以减少API开销。

​		如我们所见，实现着色方程是决定可以简化哪些部分，各种表达式的计算频率以及用户如何修改和控制外观的问题。渲染管道的最终输出是颜色和混合值。剩余章节有关抗锯齿，透明度和图像展示细节介绍了如何组合和修改这些值以进行显示。

### 5.4走样和反走样

​		想象一个大的黑色三角形在白色背景上缓慢移动。由于屏幕网格单元被三角形覆盖，该单元表示的像素值强度应平稳下降。通常发生在各种基本渲染器中的情况是，一旦网格单元的中心被覆盖，像素颜色就会立即从白色变为黑色。标准GPU渲染也不例外。参见图5.14的最左列。![image-20191216224722203](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216224722203.png)

​		<font size=2>图5.14。 上排显示了具有不同反走样级别的三幅图像，它们分别具有三角形，直线和一些点。 下排图像是上排的放大。 最左列的图像每个像素仅使用一个样本，这意味着不使用反走样。 中间列图像每个像素四个样本（以网格模式）渲染，而右列的每个像素使用八个样本（在4×4棋盘中，一半的正方形被采样）。</font>

​		无论三角形在那里或不在那里，三角形都显示在像素中。画出的线段有类似的问题。因为边的边缘呈锯齿状，因此这种视觉现象称为“锯齿”，经过动画处理后会变成“爬虫”。更正式地说，此问题称为走样（图形失真），而为避免该问题所做的努力称为反走样技术。

​		采样原理和数字滤波的主题足够大，足以填满自己的书[559，1447，1729]。但这是渲染的关键领域，因此将介绍采样和过滤的基本原理。然后，我们将专注于当前可以实时完成的工作，以减轻走样。

#### 5.4.1采样与滤波原理

​		渲染图像的过程本质上是一个采样任务。之所以如此，是因为图像的生成是对三维场景进行采样的过程，以便获得图像中每个像素（离散像素的数组）的颜色值。要使用纹理映射（第6章），必须对纹理像素（不是像素）进行重采样才能在不同条件下获得良好的效果。为了在动画中生成图像序列，通常以统一的时间间隔对动画进行采样。本节介绍采样，重构和过滤的主题。为简单起见，大多数材质将以一维显示。这些概念也可以自然扩展到二维，因此可以在处理二维图像时使用。

​		图5.15显示了如何以均匀空间间隔对连续信号进行采样，即离散化。该采样过程的目标是

![image-20191216224807229](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216224807229.png)

​		<font size=2>图5.15。 对连续信号（左）进行采样（中），然后通过重建恢复原始信号（右）。</font>

​		以数字方式表示信息。这样做可以减少信息量。但是，采样信号需要被重构用于恢复原始信号。这是通过对采样信号进行滤波来完成的。

​		无论何时采样，都可能发生走样。这是不想要的现象，我们需要对抗走样才能生成满意的图像。在古老的西方人看来，走样的一个典型例子是由电影摄影机拍摄的旋转的纺车轮。因为旋转带的移动速度比摄像机录制图像的速度快得多，所以轮子似乎在缓慢旋转（向后或向前），甚至看起来根本没有旋转。如图5.16所示。之所以会出现这种效果，是因为车轮的图像是按照一系列时间步长拍摄的，被称为时间走样。

![image-20191216224828768](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216224828768.png)

​		<font size=2>图5.16。 第一行显示了一个纺车（原始信号）。 在第二行中采样不适当，使其看起来朝相反的方向移动。 这是由于采样率太低而造成走样的示例。 在第三行中，采样率正好是每转两个采样，因此我们无法确定轮子朝哪个方向旋转。 这是奈奎斯特极限。 在第四行中，采样率高于每转两个样本，我们突然可以看到轮子朝着正确的方向旋转。</font>

​		计算机图形中常见的走样示例是光栅化线或三角形边缘的“锯齿”，诸如“萤火虫”一样闪烁的高光，细化具有方格图案的纹理时（第6.2.2节）。

​		当信号以太低的频率采样时，会发生走样。这样，被采样的信号然后呈现为频率低于原始信号的信号。如图5.17所示。为了正确地采样信号（即，可以从采样中重建原始信号），采样频率必须大于要采样的信号的最大频率的两倍。这通常被称为采样定理，采样频率被称为奈奎斯特速率[1447]或奈奎斯特极限，此后是1928年瑞典科学家哈里·奈奎斯特（1889–1976）发现的。奈奎斯特极限也如图 5.16所示。该定理使用术语“最大频率”意味着该信号必须受到带宽限制，这仅意味着没有任何高于特定限制的频率。换句话说，信号必须足够平滑相对于相邻样本之间的间隔

![image-20191216224847933](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216224847933.png)

​		<font size=2>图5.17。 蓝色实线是原始信号，红色圆圈表示均匀间隔的采样点，绿色虚线是重构的信号。 上图显示了太低的采样率。 因此，重建的信号似乎具有较低的频率，即原始信号的走样。 下图显示的采样率恰好是原始信号频率的两倍，而此处重构的信号是一条水平线。 可以证明，如果采样率稍稍增加，则可以实现完美的重构。</font>

​		三维场景通常从不限制带宽在使用点样本进行渲染时。 三角形的边缘，阴影边界和其他现象会产生不连续变化的信号，因此会产生无限的频率[252]。 同样，无论样本有多紧密，对象仍然可以足够小以至于根本无法进行采样。 因此，在使用点样本渲染场景时无法完全避免走样问题，但我们几乎总是使用点采样。 但是，有时可能会知道信号何时受到带宽限制。 一个示例是将纹理应用于表面时。 与像素的采样率相比，可以计算纹理采样的频率。 如果此频率低于奈奎斯特极限，则无需采取特殊措施即可正确采样纹理。 如果频率太高，则可以使用多种算法对纹理进行带宽限制（第6.2.2节）。

<font color=#ff7200>重建</font>

​		给定一个带宽限制的采样信号，我们现在将讨论如何从采样信号中重建原始信号。 为此，必须使用滤波器。 图5.18显示了三个常用的滤波器。 请注意，滤波器的面积应始终为1，否则重建的信号可能看起来会增大或缩小。

![image-20191216224916912](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216224916912.png)

​		<font size=2>图5.18。 左上方显示盒式过滤器，右上方显示帐篷式过滤器。 底部显示了一个Sinc滤波器（已在此处固定在x轴上）。</font>

​		在图5.19中，盒式滤波器（最近邻居）用于重建采样信号。 这是最差的滤波器，因为产生的信号是不连续的阶梯状。 尽管如此，由于其简单性，它仍经常用于计算机图形学。 从图中可以看出，盒式滤波器放置在每个采样点上，然后进行缩放，以使滤波器的最高点与采样点重合。 这些经过缩放和转换后的框函数总和是右图所示的重构信号。

![image-20191216224932871](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216224932871.png)

​		<font size=2>图5.19。 使用盒式滤波器重建采样信号（左）。 这是通过将盒式滤波器放置在每个采样点上，并在y方向上缩放使滤波器的高度与采样点相同来完成的。 其总和是重建信号（右）。</font>

​		盒式过滤器可以被任何其他过滤器替代。 在图5.20中，帐篷滤波器（也称为三角滤波器）用于重建采样信号。 请注意，此滤波器在相邻采样点之间实现线性插值，因此它比盒式滤波器更好，因为现在重建的信号是连续的。

![image-20191216224947854](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216224947854.png)

​		<font size=2>图5.20。 使用帐篷滤波器重建采样信号（左）。 重建的信号显示在右侧。</font>

但是，使用帐篷滤波器重构的信号的平滑度差。 采样点的坡度会突然变化。 帐篷滤波器不是理想的重建过波器。 为了获得完美的重构，必须使用理想的低通滤波器。 信号的频率分量是正弦波：$\sin（2\pi f）$，其中$f$是该分量的频率。 鉴于此，低通滤波器将去除频率高于滤波器定义的某个频率的所有频率分量。 直观地讲，低通滤波器消除了信号的尖锐特征，即滤波器使信号模糊。 理想的低通滤波器是Sinc滤波器（图5.18底部）：
$$
sinc(x)=\frac{\sin(\pi x)}{\pi x}.
\qquad\qquad(5.22)
$$

​		傅立叶分析[1447]的理论解释了为什么Sinc滤波器是理想的低通滤波器。简要地，推理如下。理想的低通滤波器是频域中的盒式滤波器，当与信号相乘时，它会去除超过滤波器宽度以上的所有频率。将盒式滤波器从频域转换为空间域可得到Sinc函数。同时，乘法运算被转换为卷积函数，这是我们在本节中一直使用的函数，而没有实际描述该术语。
​		使用sinc滤波器重构信号可获得更平滑的结果，如图5.21所示。采样过程在信号中引入了高频成分（突变），低通滤波器的任务是消除这些成分。实际上，sinc滤波器消除了所有频率高于采样率1/2的正弦波。当采样频率为1.0（即采样信号的最大频率必须小于1/2）时，sinc函数是理想的重构滤波器，如方程式5.22所示。更一般地，假设采样频率为$f_s$，即，相邻样本之间的间隔为$1 / f_s$。在这种情况下，理想的重建滤波器是$sinc（f_sx）$，它消除了所有高于$f_s / 2$的频率。重采样信号时，这很有用（下一部分）。但是，sinc的滤波器宽度是无限的，并且在某些区域为负，因此在实践中很少有用。

![image-20191216225028849](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216225028849.png)

​		<font size=2>图5.21。 在这里，sinc滤波器用于重建信号。 sinc滤波器是理想的低通滤波器。</font>

​		一方面，在低质量的盒式和帐篷滤波器之间存在有用的中间地带，另一方面，和不切实际的Sinc滤波器。最广泛使用的滤波器功能[1214、1289、1413、1793]介于这些极端之间。所有这些滤波器函数都与sinc函数近似，但是对它们影响多少像素有限制。与sinc函数最接近的滤波器在其部分域中具有负值。对于应用程序来说负的滤波器值是不被希望或不现实的，通常使用无负波的滤波器（通常称为高斯滤波器，因为它们要么源自高斯曲线，要么类似于高斯曲线）[1402]。第12.1节详细讨论了过滤器功能及其使用。
​		使用任何滤波器后，都会获得连续信号。但是，在计算机图形学中，我们不能直接显示连续信号，但可以使用它们将连续信号重新采样为另一种尺寸，即放大或缩小信号。接下来讨论这个主题。

<font color=ff7200>重采样</font>


​		重采样用于放大或缩小采样信号。假设原始样本点位于整数坐标（0、1、2，...），即样本之间的单位间隔。此外，假设在重新采样后，我们希望新采样点均匀地放置在间隔a之间。对于a> 1，将发生缩小（下采样），对于a<1，将发生放大（上采样）。

​		放大倍数是两者中最简单的情况，因此让我们从此开始。假设如上一节中所示重构了采样信号。凭直觉，由于现在信号已被完美地重建并且是连续的，因此所需要做的只是以所需的间隔对重建的信号进行重新采样。这个过程可以在图5.22中看到。

![image-20191216225050715](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216225050715.png)

​		<font size=2>图5.22。 左侧是采样信号和重构信号。 在右侧，用两倍的采样率对重构的信号进行了重新采样，即发生放大</font>

​		但是，发生缩小时，此技术不起作用。原始信号的频率对于采样率来说太高了，以避免混叠。取而代之的是，已经表明应该使用$sinc（x / a）$的滤波器来从被采样的连续信号中创建连续信号[1447，1661]。之后，可以按所需的间隔进行重采样。如图5.23所示。换句话说，通过使用sinc（x / a）作为滤波器，低通滤波器的宽度增加了，从而消除了更多信号的高频成分。如图所示，（单个Sinc的）滤波器宽度翻倍，以将重采样率降低到原始采样率的一半。将其与数字图像相关，这类似于首先对其进行模糊处理（以去除高频），然后以较低的分辨率对图像进行重采样。

![image-20191216225102674](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216225102674.png)

​		<font size=2>图5.23。 左侧是采样信号和重构信号。 在右侧，滤波器宽度翻倍，以便使样本之间的间隔加倍，也就是说，已经发生缩小。</font>

​		以采样和过滤理论为框架，现在讨论在实时渲染中用于减少混叠的各种算法。

#### 5.4.2基于屏幕的反走样

​		如果未正确采样和填充，三角形的边缘会产生明显的失真。 阴影边界，镜面高光和其他颜色快速变化的现象可能会导致类似的问题。 本节讨论的算法有助于改善这些情况的渲染质量。 它们具有基于屏幕的通用线程，即它们仅对管道的输出样本进行操作。 没有一种最佳的抗锯齿技术，因为每种技术在质量，捕获清晰细节或其他现象的能力，移动时的外观，内存开销，GPU要求和速度方面都具有不同的优势。

​		在图5.14的黑色三角形示例中，一个问题是低采样率。 在每个像素的网格单元的中心采样一个样本，因此，其中最需要了解的是该单元的中心是否被三角形覆盖。 通过在每个屏幕网格单元中使用更多样本并以某种方式混合它们，可以计算出更好的像素颜色。 如图5.24所示。

![image-20191216225129587](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216225129587.png)

​		<font size=2>图5.24。 在左侧，将绘制一个红色三角形，其中一个样本位于像素的中心。 由于三角形不覆盖样本，因此即使像素的大部分被红色三角形覆盖，像素也将是白色的。 在右侧，每个像素使用四个样本，可以看到，其中两个样本被红色三角形覆盖，从而产生了粉红色的像素颜色。</font>

​		基于屏幕的反走样的一般策略是对屏幕使用采样模式，然后对样本进行加权和求和以产生像素颜色$\mathbf{p}$：
$$
\mathbf{p}(x,y)=\sum_{t=1}^{n}w_i\mathbf{c}(i,x,y)
\qquad\qquad(5.23)
$$
​		其中，n为在一个像素中采集的样本数。函数$\mathbf{c}（i，x，y）$是样本颜色，而$w_i$是在[0，1]范围内的权重，样本将对整个像素颜色有所贡献。根据序列$1，...，n$中的样本来获取样本位置，并且该函数还可以选择性使用像素位置（x，y）的整数部分。换句话说，对于每个样本而言，在屏幕网格上获取样本的位置是不同的，并且可选地让采样模式可以随像素而变化。样本通常是实时渲染系统（和大多数其他渲染系统）中的点样本。因此，可以将函数$\mathbf{c}$视为两个函数。首先，函数$\mathbf{f}（i，n）$检索屏幕上需要样本的浮点$（x_f，y_f）$位置。然后对屏幕上的该位置进行采样，即，检索该精确点处的颜色。选择采样方案，并且将渲染管线配置为通常基于每帧（或每个应用程序）来计算特定子像素位置的采样。

​		反走样的另一个变量是$w_i$，即每个样本的权重。 这些权重总和为一。 实时渲染系统中使用的大多数方法都为它们的样本赋予统一的权重，即$w_i$ = 1。 图形硬件的默认模式是在像素中心采集单个样本n，这是上面的反走样方程式的最简单情况。 只有一个项，该项的权重为一，采样函数f始终返回被采样像素的中心。

​		每个像素计算一个以上完整样本的反走样算法称为超级采样（或过采样）方法。从概念上讲，最简单的全场景反走样（FSAA）也称为“超采样抗锯齿”（SSAA），它以较高的分辨率渲染场景，然后过滤相邻的样本以创建图像。例如，假设需要1280×1024像素的图像。如果在屏幕外渲染2560×2048的图像，然后对屏幕上每个2×2像素区域求平均，则将生成所需图像，每个像素具有四个样本，并使用盒式滤镜进行过滤。请注意，这对应于图5.25中的2×2网格采样。这种方法的成本很高，因为所有子样本都必须完全着色并填充，每个样本具有z缓冲区深度。 FSAA的主要优势是简单。此方法的其他较低质量版本仅在一个屏幕轴上以两倍的速率采样，因此称为1×2或2×1超级采样。通常，为简化起见，使用二的幂次方分辨率和盒式滤波器。 NVIDIA的动态超分辨率功能是超级采样的一种更精细的形式，其中场景以更高的分辨率渲染，并使用13个样本的高斯滤镜生成显示的图像[1848]。

![image-20191216225218009](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216225218009.png)

​		<font size=2>图5.25。 一些像素采样方案的比较，范围从每个像素的最少到最多样本。 Quincunx共享边角样本并对其中心样本进行加权，以使其值达到像素最终颜色的一半。 2×2旋转网格比2×2直形网格在几乎水平的边缘捕获更多的灰阶。 类似地，尽管使用的样本较少，但8 rooks模式却比4×4 grid捕获了更多的此类近乎水平线的灰阶。</font>

​		一种与超级采样有关的采样方法是基于累积缓冲区的概念[637，1115]。代替一个大的屏幕外缓冲区，此方法使用的缓冲区具有与所需图像相同的分辨率，但每个颜色通道具有更多bits。为了获得2×2的场景采样，将生成四个图像，并根据需要将视图在屏幕的x或y方向上移动半个像素。生成的每个图像均基于网格单元内的不同样本位置。每帧必须重新渲染场景几次并将结果复制到屏幕的额外开销使该算法在实时渲染系统中开销很高。当性能不是很关键时，它对于生成更高质量的图像很有用，因为每个像素可以使用任意位置的任意数量的样本[1679]。累积缓冲区曾经是单独的硬件。 OpenGL API直接支持它，但在3.0版中已弃用。在现代GPU上，可以通过对输出缓冲区使用更高精度的颜色格式，在像素着色器中实现累积缓冲区的概念。

​		当诸如物体边缘，镜面高光和尖锐阴影之类的现象导致颜色突然变化时，需要额外的样本。通常可以使阴影更柔和使高光更平滑以避免走样。可以增加特定对象的大小，例如电线，以确保它们在其长度的每个位置覆盖至少一个像素[1384]。对象边缘的走样仍然是主要的采样问题。可以使用分析方法，其中在渲染过程中检测到对象边缘并考虑它们的影响，但是与仅获取更多样本相比，这些方法通常更昂贵且更不可靠。但是，诸如保守光栅化和光栅器顺序视图之类的GPU功能开辟了新的可能性[327]。

​		诸如超级采样和累积缓冲之类的技术通过生成单独计算的阴影和深度和完全指定的样本来工作。由于每个样本都必须通过像素着色器，因此总增益相对较低，成本也较高。

​		多重采样抗锯齿（MSAA）通过对每个像素一次计算表面着色并在样本之间共享该结果，从而降低了高计算成本。 每个片段的像素可能有四个（x，y）采样位置，每个都有自己的颜色和z深度，但是对于每个应用于像素的对象片段，像素着色器仅评估一次。 如果片段覆盖了所有MSAA位置样本，则在像素中心评估作色样本。 相反，如果片段包含较少的位置样本，则可以移动阴影样本的位置以更好地表示所覆盖的位置。 例如，这样做可以避免从纹理的边缘进行着色采样。 此位置调整称为质心采样或质心插值，如果启用，则由GPU自动完成。 质心采样避免了非三角形问题，但会导致导数计算返回不正确的值[530，1041]。 参见图5.26。

![image-20191216225237945](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216225237945.png)

​		<font size=2>图5.26。 在中间，像素被两个对象重叠。 红色的物体覆盖了三个样本，蓝色的只是一个。 像素着色器评估位置以绿色显示。 由于红色三角形覆盖了像素的中心，因此此位置用于着色器评估。 在样本的位置评估蓝色对象的像素着色器。 对于MSAA，所有四个位置存储单独的颜色和深度。 右侧显示了EQAA的2f4x模式。 现在，这四个样本具有四个ID值，它们由存储的两种颜色和深度的构成的表索引。</font>

​		MSAA比纯超级采样方案快，因为片段仅被着色一次。它着重于以更高的速率采样片段的像素覆盖范围并共享计算出的着色。通过进一步分离采样和覆盖范围，可以节省更多的内存，这反过来又可以使反走样更快—触摸的内存越少，渲染越快。 NVIDIA在2006年推出了覆盖采样抗锯齿（CSAA），AMD随之推出了增强质量抗锯齿（EQAA）。这些技术通过以较高的采样率仅存储片段的覆盖范围来工作。例如，EQAA的“ 2f4x”模式存储两个颜色和深度值，在四个样本位置之间共享。颜色和深度不再存储在特定位置，而是存储在表格中。然后，四个样本中的每个样本仅需要一位来指定两个存储值中的哪一个与其位置相关联。见图5.26。覆盖样本指定每个片段对最终像素颜色的贡献。如果超过了存储的颜色数量，则将存储的颜色逐出，并将其样本标记为未知。这些样本对最终颜色没有帮助[382，383]。对于大多数场景而言，相对较少的像素包含三个或更多可见的不透明片段，它们的着色根本不同，因此该方案在实践中表现良好[1405]。但是，为了获得最高质量，游戏《极限竞速：地平线2》采用了4倍MSAA，尽管EQAA具有性能优势[1002]。

将所有几何图形渲染到多样本缓冲区后，便会执行解析操作。此过程将样本颜色平均在一起，以确定像素的颜色。值得注意的是，当使用具有高动态范围颜色值的多重采样时，可能会出现问题。在这种情况下，为避免失真，通常需要在解析之前对值进行色调映射[1375]。这可能很昂贵，因此可以使用更简单的近似色调映射函数或其他方法[862，1405]。

​		默认情况下，MSAA通过框滤波器进行解析。在2007年，ATI引入了自定义滤波器抗锯齿（CFAA）[1625]，它具有使用窄而宽的帐篷滤镜的能力，这些滤镜会略微扩展到其他像素单元中。此后此模式已被EQAA支持所取代。在现代GPU上，像素或计算着色器可以访问MSAA样本并使用所需的任何重建滤波器，包括从周围像素的样本中采样的。较宽的滤镜可以减少走样，尽管会丢失锐利的细节。 Pettineo [1402，1405]发现，滤波器宽度为2或3像素的三次平滑插值和B样条滤波器总体上具有最佳效果。还有一个性能成本，因为即使使用自定义着色器模拟默认的框滤波器解析也将花费更长的时间，而更宽的过滤器内核意味着增加的样本访问的成本。

​		NVIDIA的内置TXAA支持类似地在比单个像素更宽的区域上使用更好的重建滤波器，以提供更好的结果。它和更新的MFAA（多帧抗锯齿）方案都使用了时间抗锯齿（TAA），这是一类通用的技术，可使用先前帧的结果来改善图像。由于使程序员能够设置每帧MSAA采样模式的功能，部分程度上使此类技术成为可能[1406]。这样的技术可以解决诸如旋转的车轮等走样问题，并且还可以改善边缘渲染质量。

​		想象一下，通过生成一系列图像来“手动”执行采样模式，其中每次渲染使用在像素中采样位置的不同位置。这种偏移是通过在投影矩阵上附加一个微小的平移来完成的[1938]。生成并平均的图像越多，结果越好。这个使用多个偏移图像的概念在时间抗混叠算法中被使用。可以使用MSAA或另一种方法生成单个图像，然后和先前的图像混合。通常只使用两到四个帧[382、836、1405]。较旧的图像可能会被赋予较小的权重[862]，然而如果观看者和场景不移动，这可能会导致帧闪烁，因此通常只对最后一帧和当前帧进行相等的加权。由于每个帧的样本位于不同的子像素位置，因此这些样本的加权总和比单个帧具有更好的边缘覆盖估计。因此，使用最后的两个帧平均的系统可以提供更好的结果。每个帧都不需要额外样本，这就是这种方法如此吸引人的原因。甚至可以使用时间采样来生成较低分辨率的图像，该图像将放大到显示器的分辨率[1110]。另外，需要很多样本才能获得良好结果的照明方法或其他技术可以被代替为每帧使用较少的样本，因为结果将在几帧中混合[1938]。

​		在不增加额外采样成本的情况下为静态场景提供抗锯齿功能时，这种类型的算法在用于时间抗锯齿功能时会遇到一些问题。如果没有对帧进行均等加权，则静态场景中的对象可能会出现微光。快速移动的物体或快速的摄像机移动可能会导致重影，即物体留下的轨迹由于先前帧的影响。重影的一种解决方案是仅对缓慢移动的对象执行这种抗锯齿处理[1110]。另一个重要的方法是使用重投影（第12.2节）来更好地关联先前和当前帧的对象。在这样的方案中，对象生成运动矢量，这些运动矢量存储在单独的“速度缓冲区”中（第12.5节）。这些向量用于将前一帧与当前帧相关联，即，从当前像素位置中减去该向量，以找到前一帧该对象表面位置的颜色像素。在当前帧中一部分不太可能成为表面的样本将被丢弃[1912]。由于时间抗锯齿不需要额外的样本，因此也不需要太多的额外工作，因此近年来人们对这种类型的算法产生了浓厚的兴趣并得到了广泛的采用。之所以有些关注，是因为延迟着色技术（第20.1节）与MSAA和其他多采样支持不兼容[1486]。方法各不相同，并且根据应用程序的内容和目标，已经开发了避免失真和提高质量的一系列技术[836，1154，1405，1533，1938]。例如，Whilidal的演示文稿[1885]显示了EQAA，时间抗锯齿和应用于棋盘采样模式的各种过滤技术如何结合起来以保持质量，同时减少像素着色器调用的次数。 Iglesias-Guitian等。 [796]总结了以前的工作，并提出了他们的方案，以使用像素历史记录和预测来最小化过滤失真。 Patney等。 [1357]扩展了Karis和Lottes在虚幻引擎4实现[862]用于虚拟现实应用程序的TAA工作，增加了可变大小的采样以及对眼睛运动的补偿（第21.3.2节）。

<font color=ff7200>采样模式</font>

​		高效的采样模式是减少失真，时间和其他方面的关键因素。 Naiman [1257]表明，在接近水平和接近垂直的边缘上的失真对人类的影响最大。接近45度倾斜的边缘是第二个最影响最大的地方。旋转网格超级采样（RGSS）使用旋转正方形模式来在像素内提供更多垂直和水平分辨率。图5.25显示了此模式的示例。

​		RGSS模式是一种Latin hypercube或N-rooks采样的形式，其中n个样本放置在n×n网格中，每行和每列一个样本[1626]。使用RGSS，四个样本分别位于4×4子像素网格的单独行和列中。与常规2×2采样模式相比，此类模式特别适合捕获几乎水平和垂直的边缘，在常规2×2采样模式下，此类边缘可能会覆盖偶数个样本，因此效率水平较低。

​		N-rooks是创建良好采样模式的开始，但还不够。例如，这些样本都可能沿着子像素网格的对角线放置，因此对于几乎平行于该对角线的边缘给出较差的结果。参见图5.27，为获得更好的采样，我们希望避免将两个样本彼此靠近。我们还希望分布均匀，将样本均匀分布在整个区域。为了形成这样的模式，分层采样技术（例如拉丁超立方体采样）与其他方法（例如抖动，霍尔顿序列和泊松磁盘采样）相结合[1413，1758]。

![image-20191216225320726](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216225320726.png)

​		<font size=2>图5.27。 N-rooks采样。 左侧是合法的N-rooks模式，但在捕获沿其对角线的三角形边缘时效果不佳，因为随着该三角形的移动，所有采样位置都将位于三角形的内部或外部。 右侧是一种模式，可以更有效地捕获此边缘和其他边缘。</font>

​		实际上，GPU制造商通常将此类采样模式硬连接到其硬件中，以进行多重采样抗锯齿。图5.28显示了实际使用的一些MSAA模式。对于时间抗锯齿，覆盖模式是程序员想要的，因为样本位置可以逐帧变化。例如，Karis [862]发现基本的霍尔顿序列比GPU提供的任何MSAA模式效果更好。霍尔顿序列会在空间中生成样本，这些样本看起来是随机的，但差异很小，也就是说，它们在空间中分布良好，并且没有聚类的现象[1413，1938]。

​		虽然子像素网格模式可以更好地近似每个三角形如何覆盖网格单元，但这并不理想。场景可以由在任意屏幕上很小的物体组成，这意味着没有采样率可以完美地捕获它们。如果这些微小的物体或特征形成图案，则以恒定间隔进行采样可能会导致莫尔条纹和其他干涉图案。超级采样中使用的网格模式特别容易混叠。

​		一种解决方案是使用随机采样，这样可以提供更加随机的图案。如图5.28所示的图案肯定是合格的。想象一下，远距离有齿的梳子，每个像素覆盖几个齿。当采样模式与齿频率异相时，规则模式会产生严重的失真。具有较少顺序的采样模式可以分解这些模式。随机化倾向于用噪声代替重复的混叠效应，人类视觉系统对此更为接受[1413]。结构较少的模式有帮助，但是当像素间重复时，它仍会出现混叠现象。一种解决方案是在每个像素上使用不同的采样模式，或者随时间更改每个采样位置。在过去的几十年中，偶尔会硬件中支持交错采样，即一组像素集合的每个像素具有不同的采样模式。例如，ATI的SMOOTHVISION允许每个像素最多16个样本和最多16个用户定义的不同采样模式，这些模式可以混合在一起以重复模式（例如4×4像素图块）。 Molnar [1234]以及Keller和Heidrich [880]发现，对于每个像素使用相同的模式时，使用交错随机采样可以最大程度地减少混叠失真。

![image-20191216225348874](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216225348874.png)

​		<font size=2>图5.28。 适用于AMD和NVIDIA图形加速器的MSAA采样模式。 绿色正方形是着色样本的位置，红色正方形是计算和保存的位置样本。 从左至右：2倍，4倍，6倍（AMD）和8倍（NVIDIA）采样。 （由D3D FSAA查看器生成。）</font>

​		值得注意的是其他一些GPU支持的算法。 NVIDIA的较早的Quincunx方法[365]是一种可以使样本影响多个像素的实时抗锯齿方案。 “ Quincunx”是指五个对象的排列，四个在正方形边角，第五个在中心，例如在六面模具上的五个点的图案。 Quincunx多重采样抗锯齿使用此模式，将四个外部采样放在像素的角上。参见图5.25。每个角样本值被分配到其四个相邻像素。并非像其他大多数实时方案那样平均地对每个样本加权，而是对中心样本赋予1/2的权重，而对每个角落样本赋予的权重为1/8。由于这种共享，每个像素平均只需要两个样本，其结果比两个样本的FSAA方法要好得多[1678]。这种模式近似于二维帐篷滤波器，如上一节所述，该过滤器优于盒式过滤器。

​		通过将每个像素使用单个样本，也可以将Quincunx采样应用于时间抗锯齿[836，1677]。每个帧在每个轴上比之前的帧偏移半个像素，偏移方向在帧之间交替。前一帧提供像素角样本，并且使用双线性插值快速计算每个像素的贡献。将结果与当前帧取平均值。每个帧的权重相等意味着静态视图没有闪烁的现象。校准移动物体的问题仍然存在，但是该方案本身易于编码，并且在每帧每像素仅使用一个样本的情况下具有更好的外观。

​		当在单个帧中使用时，Quincunx通过在像素边界共享样本而具有仅两个样本的低成本。 RGSS模式更适合捕获接近水平和垂直边缘的更多灰度。 FLIPQUAD模式最初是为移动图形开发的，结合了这两个理想的功能[22]。 它的优点是成本仅为每个像素两个样本，并且质量类似于RGSS（每个像素四个样本）。 此采样模式如图5.29所示。 Hasselgren等人探索了其他利用样本共享的低开销采样模式。 [677]。

![image-20191216225412945](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216225412945.png)

​		<font size=2>图5.29。 左侧显示了RGSS采样模式。 每个像素花费四个样本。 通过将这些位置移到像素边缘，可以跨边缘进行样本共享。 但是，要解决此问题，每个其他像素必须具有反射的样本图案，如右图所示。 所得的样本模式称为FLIPQUAD，每个像素花费两个样本。</font>

​		与Quincunx一样，两个样本的FLIPQUAD模式也可以与时间抗锯齿一起使用，并分布在两个帧上。 Drobot [382，383，1154]解决了在他的混合重建抗锯齿（HRAA）工作中哪种两个样本模式最好的问题。 他探索了用于时间抗锯齿的不同采样模式，并发现FLIPQUAD模式是五个测试中最好的。 棋盘图案还可以用于时间抗锯齿。 El Mansouri [415]讨论了使用两个样本的MSAA创建棋盘渲染，以减少着色器开销，同时解决混淆问题。 Jimenez [836]使用SMAA，时间抗锯齿和多种其他技术来提供一种解决方案，其中抗锯齿质量可以随着渲染引擎负载而改变。 Carpentier和Ishiyama [231]在边缘采样，将采样网格旋转了45°。 他们将此时间抗锯齿方案与FXAA（稍后讨论）结合在一起，以在较高分辨率的显示器上进行高效渲染。

<font color=ff7200>形态学方法</font>

​		混叠通常是由边缘引起的，例如由几何形状，尖锐的阴影或明亮的高光形成的边缘。 可以利用与混叠相关的知识体系来提供更好的抗锯齿结果。 2009年，Reshetov [1483]沿着这些思路提出了一种算法，称其为形态抗锯齿（MLAA）。 “形态”是指“与结构或形状有关”。早在1983年，Bloomenthal [170]就在该领域[830]中开展了早期工作。 Reshetov的论文重新激发了对多采样方法替代方法的研究，强调搜索和重建边缘[1486]。

​		这种抗锯齿形式是在后期处理中执行的。 也就是说，以通常的方式完成渲染，然后将结果送到生成抗锯齿结果的过程。 自2009年以来，已经开发出了各种各样的技术。那些依赖于其他缓冲区（例如深度和法线）的技术可以提供更好的结果，例如子像素重构抗锯齿（SRAA）[43，829]，但仅适用于几何边缘的抗锯齿。 诸如几何缓冲区抗锯齿（GBAA）和距离边缘抗锯齿（DEAA）之类的分析方法，使渲染器计算有关三角形边缘位于何处的附加信息，例如，边缘距像素中心的距离多[829] ]。

​		最通用的方案只需要颜色缓冲区，这意味着它们还可以改善阴影，高光或以前应用的各种后处理技术（如轮廓边缘渲染）中的边缘（第15.2.3节）。 例如，定向局部抗锯齿（DLAA）[52，829]是基于以下观察结果：接近垂直的边缘应水平模糊，同样，接近水平的边缘也应与其邻居垂直模糊。

​		边缘检测的更复杂形式试图找到可能以任何角度包含边缘的像素并确定其覆盖范围。 检查潜在边缘周围的邻域，目标是尽可能重建原始边缘所在的位置。 然后可以使用边缘对像素的影响来混合相邻像素的颜色。 有关过程的概念视图，请参见图5.30。

![image-20191216225437269](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216225437269.png)

​		<font size=2>图5.30。 形态抗锯齿。 左侧是锯齿图像。 目标是确定形成边缘的边缘的可能方向。 在中间，该算法通过检查邻居来记录边缘的可能性。 给定样本，显示了两个可能的边缘位置。 在右侧，最佳估计边缘用于将邻近的颜色与估计的覆盖率成比例地混合到中心像素中。 对图像中的每个像素重复此过程。</font>

​		Iourcha等 [798]通过检查像素中的MSAA样本来计算更好的结果，从而改善了边缘查找。注意，与基于样本的算法相比，边缘预测和混合可以提供更高的精度。例如，一种使用每个像素四个样本的技术只能为对象的边缘提供五个混合级别：没有样本覆盖，一个样本覆盖，两个样本，三个样本和四个样本。估计的边缘位置可以具有更多位置，因此可以提供更好的结果。

​		基于图像的算法有几种可能会误入歧途。首先，如果两个对象之间的色差低于算法的阈值，则可能无法检测到边缘。难以解释具有三个或更多不同表面重叠的像素。具有高对比度或高频元素的表面，其中颜色在像素之间快速变化，可能导致算法遗漏边缘。特别地，当对其应用形态抗锯齿时，文本质量通常会受到影响。对象角可能是一个挑战，有些算法可以使它们具有圆润的外观。假设边缘是直的，曲线也会受到不利影响。单个像素变化可能会导致边缘重建方式发生较大变化，从而在帧与帧之间产生明显的失真。解决此问题的一种方法是使用MSAA覆盖蒙版来改善边缘确定性[1484]。

​		形态抗混叠方案仅使用所提供的信息。例如，宽度小于像素的对象（例如电线或绳索）将在屏幕上如果它没有覆盖像素的中心位置出现间隙。在这种情况下，采集更多的样本可以提高质量；仅基于图像的抗锯齿不能。此外，执行时间可以根据查看内容的内容而变化。例如，一片草地的视野所需的抗锯齿时间是天空的三倍[231]。

​		综上所述，基于图像的方法可以为有限的内存和处理成本提供抗锯齿支持，因此它们被用于许多应用程序中。仅彩色版本还与渲染管线分离，使其易于修改或禁用，甚至可以作为GPU驱动程序选项公开。两种最流行的算法是快速近似抗锯齿（FXAA）[1079、1080、1084]和子像素形态抗锯齿（SMAA）[828、830、834]，部分原因是两者都提供了可靠的（免费的）源代码实现为各种机器。两种算法都使用颜色输入，SMAA具有能够访问MSAA样本的优势。每个都有自己的各种可用设置，在速度和质量之间进行权衡。每帧的成本通常在1-2毫秒的范围内，主要是因为这就是视频游戏愿意花费的时间。最后，两种算法都可以利用时间抗锯齿[1812]。 Jimenez [836]提出了一种改进的SMAA实现，比FXAA更快，并描述了一种时间抗混叠方案。最后，我们向读者推荐Reshetov和Jimenez [1486]对形态技术及其在视频游戏中的使用的广泛评论。

### 5.5透明度，Alpha和合成

​		半透明物体可以通过许多不同的方式使光线穿过它们。 对于渲染算法，可以将这些大致分为基于灯光的效果和（light-based）基于视图的效果（view-based effects）。 基于光的效果是对象导致光被衰减或转移，从而导致场景中的其他对象被照亮并以不同方式渲染。 基于视图的效果是呈现半透明对象本身的效果。

​		在本节中，我们将讨论基于视图的透明的最简单形式，其中半透明对象充当其后对象颜色的衰减器。 在后面的章节中，将讨论更为详细的基于视线和光的效果，例如，毛玻璃，光的弯曲（折射），由于透明物体的厚度导致的光衰减以及由于视角导致的反射率和透射率变化。

​		一种给出透明感的方法称为屏门透明（creen-door transparency）[1244]。这个想法是用像素对齐的棋盘填充图案渲染透明三角形。也就是说，三角形的每个其他像素都将被渲染，从而使位于其后面的对象部分可见。通常，屏幕上的像素距离足够近，以至于棋盘图案本身不可见。该方法的主要缺点是通常只能令人信服地在屏幕的一个区域上渲染一个透明对象。例如，如果在蓝色对象上绘制了透明的红色对象和透明的绿色对象，则三种颜色中只有两种可以显示在棋盘图案上。同样，50％的棋盘格是有限的。其他较大的像素遮罩可用于给出其他百分比，但是这些往往会创建可检测的图案[1245]。

​		也就是说，该技术的一个优势是它的简单性。透明对象可以随时以任何顺序呈现，并且不需要特殊的硬件。通过使所有对象在其覆盖的像素处不透明，可以解决透明性问题。同样的想法也被用于对剪切纹理的边缘进行抗锯齿，但在子像素级别使用称为覆盖的Alpha功能（alpha to coverage）（第6.6节）。

​		由Enderton等人介绍。 [423]，随机透明度使用子像素的屏门遮盖与随机采样相结合。通过使用随机点画图案表示片段的alpha覆盖范围，可以创建合理但嘈杂的图像。见图5.31。每个像素需要大量样本才能使结果看起来合理，并且所有子像素样本都需要大量内存。吸引人的是，不需要混合，并且抗锯齿，透明度和创建部分覆盖像素的任何其他现象都可以通过单一机制覆盖。

![image-20191216225517964](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216225517964.png)

​		<font size=2>图5.31。 随机透明。 产生的噪音显示在放大的区域。 （图像来自NVIDIA SDK 11 [1301]示例，由NVIDIA Corporation提供。）</font>

​		大多数透明度算法会将透明对象的颜色与其后面对象的颜色混合在一起。为此，需要Alpha混合的概念[199，387，1429]。当在屏幕上渲染对象时，RGB颜色和z缓冲区深度与每个像素相关联。还可以为对象覆盖的每个像素定义另一个组件，称为alpha（α）。 Alpha是一个值，它描述给定像素的对象片段的不透明度和覆盖度。 alpha为1.0表示对象是不透明的，并且完全覆盖了像素的关注区域； 0.0表示完全不遮盖像素，即片段是完全透明的。

​		像素的Alpha值可以表示不透明度或覆盖率，或者两者，视情况而定。例如，肥皂泡的边缘可能会覆盖像素的四分之三，即0.75，并且可能几乎是透明的，从而使十分之九的光线直达眼睛，所以它的十分之一是不透明的，即0.1。那么其alpha将为0.75×0.1 = 0.075。但是，如果我们使用MSAA或类似的抗锯齿方案，则样本本身将考虑覆盖范围。四分之三的样本将受到肥皂泡的影响。然后，在每个这些样本中，我们将使用0.1不透明度值作为Alpha。

#### 5.5.1混合顺序

​		为了使对象看起来透明，它以小于1.0的alpha渲染到现有场景的顶部。 对象覆盖的每个像素将从像素着色器接收到生成的RGBα（也称为RGBA）。 通常使用over运算符将此片段的值与原始像素颜色混合，如下所示：
$$
\mathbf{c}_o=\alpha_s\mathbf{c}_s+(1-\alpha_s)\mathbf{c}_d\qquad[\textbf{over} \quad\text{operator}]
\qquad\qquad(5.24)
$$
​		其中$\mathbf{c}_s$是透明对象的颜色（称为源），$\alpha_s$是对象的alpha$，\mathbf{c}_d$是混合之前的像素颜色（称为目标），$\mathbf{c}_o$是由于将透明对象放置在现有场景上而产生的颜色 。 在渲染管线发送$\mathbf{c}_s$和$α_s$的情况下，像素的原始颜色$\mathbf{c}_d$被结果$\mathbf{c}_o$代替。 如果传入的RGBα实际上是不透明的（$α_s= 1.0$），则该方程式简化为用对象的颜色完全替换像素的颜色。

示例：混合。 红色的半透明对象被渲染到蓝色的背景上。 假设对象的某些像素的RGB着色为（0.9,0.2,0.1），背景为（0.1，0.1，0.9），并且对象的不透明度设置为0.6。 然后将这两种颜色混合
$$
0.6(0.9, 0.2, 0.1) + (1 − 0.6)(0.1, 0.1, 0.9),
$$

其颜色为（0.58，0.16，0.42）。

​		over运算符为要渲染的对象提供半透明外观。透明度是这样工作的，从某种意义上说，只要可以通过物体看到后面的物体，我们就会将其视为透明物体[754]。使用over可以模拟薄纱织物的真实效果。织物后面的对象被部分遮挡了-织物的线是不透明的。在实践中，宽松的织物具有随角度变化的Alpha覆盖[386]。这里的要点是Alpha模拟了材质覆盖像素的程度。

​		over操作对模拟其他透明效果的效果较弱，尤其是透过有色玻璃或塑料观看时。在现实世界中，放置在蓝色物体前面的红色滤镜通常会使蓝色物体看起来很暗，因为该物体反射的可以穿过红色滤镜的光线很少。请参阅图5.32。当使用over进行混合时，结果是红色和蓝色部分加在一起。最好将这两种颜色相乘，并增加透明对象本身的反射。 14.5.1和14.5.2节中讨论了这种类型的物理透射率。

![image-20191216225546634](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216225546634.png)

​		<font size=2>图5.32。 一个红色的薄纱正方形织物和一个红色的塑料过滤器，具有不同的透明效果。 注意阴影也不同。 （照片由Morgan McGuire提供。）</font>

​		在基本的混合阶段运算符中，over是通常用于透明效果的运算符[199，1429]。另一种有用的操作是加法混合，将像素值简单地求和。那是，
$$
\mathbf{a}_o=\alpha_s\mathbf{c}_s+\mathbf{c}_d\qquad\qquad(5.25)
$$
​		这种混合模式可以很好地用于发光效果，例如闪电或火花，它们不会使后面的像素衰减，而只会使它们变亮[1813]。 但是，此模式的透明度看起来不正确，因为不透明的表面似乎没有被过滤[1192]。 对于诸如烟或火之类的多层半透明表面，加法混合具有使现象的颜色饱和的效果[1273]。

​		为了正确渲染透明对象，我们需要在不透明对象之后绘制它们。首先通过混合关闭渲染所有不透明对象，然后打开over渲染透明对象。从理论上讲，我们总是可以一直打开over，因为不透明的alpha值为1.0会给出源颜色并隐藏目标颜色，但是这样做更昂贵，而且没有真正的收益。

​		z缓冲区的一个限制是每个像素只能存储一个对象。如果多个透明对象与同一像素重叠，则仅z缓冲区无法容纳并稍后解决所有可见对象的影响。在任何给定像素的透明表面上使用over时，通常需要以从后到前的顺序进行渲染。不这样做可能会导致错误的感知提示。一种实现这种排序的方法是，沿视图方向按照到单个对象的质心的距离对其进行排序。这种粗略的分类可以很好地工作，但是在各种情况下都有许多问题。首先，排序值只是一个近似值，因此被分类为距离较远的对象可能位于距离较近的对象的前面。互相贯穿的对象无法针对所有视角在每个网格的基础上进行解析，除非将每个网格分解为单独的部分。有关示例，请参见图5.33的左图。即使是单个具有凹面的网格，也可能在自身重叠的屏幕视图方向上出现排序问题。

![image-20191216225609109](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216225609109.png)

​		<font size =2>图5.33。 在左侧，使用z缓冲区透明渲染了模型。 以任意顺序渲染网格会产生严重的错误。 在右侧，去除深度可提供正确的外观，但要付出额外的时间。 （图片由NVIDIA Corporation提供。）</font>

​		但是，由于其简单性和速度以及不需要额外的内存或特殊的GPU支持，仍然经常使用对透明度进行粗糙排序的方法。 如果实现，通常最好在执行透明度时关闭z深度替换。 也就是说，z缓冲区仍然可以正常测试，但是现存的曲面不会改变所存储的z深度； 最接近的不透明表面的深度保持不变。 这样，所有透明对象将至少以某种形式出现，而不会因照相机旋转而更改排序顺序时突然出现或消失。 其他技术也可以帮助改善外观，例如，每次绘制两次透明网格，首先渲染背面，然后渲染正面[1192，1255]。

​		还可以修改over方程，以便从前向后混合得到相同的结果。 这种混合模式称为Under运算符：
$$
\begin{align}
\mathbf{c}_o=&\alpha_d\mathbf{c}_d+(1-\alpha_d)\alpha_s\mathbf{c}_s\qquad[\textbf{under} \text{operator}],\\
a_o=&\alpha_s(1-\alpha_d)+\alpha_d=\alpha_s-\alpha_s\alpha_d+\alpha_d.
\end{align}
\qquad\qquad(5.26)
$$
​		请注意，under要求目标保持Alpha值，而over则不需要。换句话说，目标（在其下面混合了更近的透明表面）不是不透明的，因此需要具有alpha值。under的公式就像over一样，但是交换了源和目标。另外，请注意，用于计算Alpha的公式与顺序无关，因为可以交换源Alpha和目标Alpha，结果是相同的最终Alpha。

​		alpha公式来自将片段的alpha作为覆盖范围。 Porter和Duff [1429]指出，由于我们不知道每个片段的覆盖区域的形状，因此我们假设每个片段都按其alpha比例覆盖另一个片段。例如，如果$\alpha_s$= 0.7，则以某种方式将像素分为两个区域，其中源片段覆盖0.7，而0.3不是。除非有其他知识，否则覆盖目标范围（例如$\alpha_d$= 0.6）的目标片段将与源片段成比例地重叠。此公式具有几何解释，如图5.34所示。

![image-20191216225632460](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216225632460.png)

​		<font size=2>图5.34。 一个像素和两个片段s和d。 通过沿着不同的轴对准两个片段，每个片段覆盖彼此成比例的量，即，它们是不相关的。 两个片段覆盖的面积等于under的输出Alpha值$\alpha_s-\alpha_s\alpha_d+\alpha_d$。 这意味着将两个面积相加，然后减去它们重叠的面积。</font>

#### 5.5.2与顺序无关的透明

​		under方程式通过将所有透明对象绘制到一个单独的颜色缓冲区中，然后使用over将此颜色缓冲区合并到场景的不透明视图上。 Under运算符的另一种用途是执行与顺序无关的透明（OIT）算法，称为深度剥离（depth peeling）[449，1115]。顺序无关意味着应用程序不需要执行排序。深度剥离背后的想法是使用两个z缓冲区和多次passes。第一次渲染pass，以使所有表面的z深度（包括透明表面）都位于第一个z缓冲区中。在第二次pass中，将渲染所有透明对象。如果对象的z深度与第一个z缓冲区中的值匹配，则我们知道这是最近的透明对象，并将其RGBα保存到一个单独的颜色缓冲区中。我们还通过保存任何透明对象（如果有的话）的z深度来“剥离”该层，如果该透明对象超过了第一个z深度并且是最接近的，则该z深度就是第二近的透明对象的距离。连续的pass继续剥落并在下面添加透明层。经过一定次数的pass后我们停止，然后将透明图像混合在不透明图像之上。见图5.35。

![image-20191216225706000](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216225706000.png)

​		<font size=2>图5.35。 每个深度剥离pass都绘制透明层中的一层。 左侧是第一次pass，显示了直接可见的图层。 中间是第二层，第二次pass在每个像素处显示第二近的透明表面，在这种情况下为对象的背面。 右边是第三层，一组第三近的透明表面。 最终结果可以在第624页的图14.33中找到。（图片由Louis Bavoil提供）。</font>

​		已经出现了该方案的几种变形。例如，Thibieroz [1763]提供了一种从后到前的算法，其优点是能够立即混合透明值，这意味着不需要单独的alpha通道。深度剥离的一个问题是知道需要多少次pass足以捕获所有透明层。一种硬件解决方案是提供一个像素绘制计数器，该计数器可告知渲染时中写入了多少像素。如果一次pass中没有任何像素被渲染，则渲染完成。使用under的优势在于，最重要的透明层（眼睛首先看到的那些层）会尽早渲染。每个透明表面始终会增加其覆盖的像素的alpha值。如果像素的Alpha值接近1.0，则混合贡献会使像素几乎不透明，因此距离较远的对象的影响可以忽略不计[394]。当一次pass中渲染的像素数量降至某个最小值以下时，可以缩短从前到后类型剥离的距离，或者可以指定固定的pass次数。这对于从后到前的剥离类型效果不佳，因为最近（通常是最重要的）层是最后绘制的，因此可能会因提前终止而丢失。

​		虽然深度剥离是有效率的，但它可能会很慢，如果被剥离的每一层都是所有透明对象的单独渲染pass。 Bavoil和Myers [118]提出了双重深度剥离，其中在每个遍中剥离了两个深度剥离层（剩余的最接近和最远的），从而将渲染pass的数量减少了一半。刘等[1056]探索了一种桶分类方法，该方法在一次pass中可捕获多达32个层。这种方法的一个缺点是，它需要大量内存才能为所有层保持排序顺序。通过MSAA或类似方法进行抗锯齿会如天文数字般增加成本。

​		将以交互速率正确地将透明对象混合在一起的问题并不是由于我们缺少算法，而是如何将这些算法有效率地映射到GPU。 1984年，Carpenter提出了A缓冲区[230]，这是另一种多重采样形式。在A缓冲区中，每个被渲染的三角形都会为其完全或部分覆盖的每个屏幕网格单元创建一个覆盖蒙版。每个像素存储一个所有其相关片段的列表。不透明的片段可以清除它们后面的片段，类似于z缓冲区。所有片段均存储在透明表面上。一旦形成所有列表，就可以通过遍历片段并解析每个样本来产生最终结果。

​		通过DirectX 11 [611，1765]中公开的新功能，使在GPU上创建片段的链接列表的想法成为可能。使用的功能包括无序访问视图（UAV）和原子操作，如3.8节所述。通过访问覆盖蒙版并评估每个样本处的像素着色器，来使用MSAA进行抗锯齿。该算法通过光栅化每个透明表面并将生成的片段插入长数组中。连同颜色和深度一起，生成了一个单独的指针结构，该结构将每个片段链接到像素存储的先前片段。然后执行一个单独的pass操作，渲染填充屏幕的四边形，以便在每个像素处评估一个像素着色器。该着色器通过跟随链接检索每个像素处的所有透明片段。检索到的每个片段都与先前的片段依次排序。然后将排序后的列表从后向前混合，以给出最终的像素颜色。因为混合是由像素着色器执行的，所以如果需要，可以为每个像素指定不同的混合模式。 通过减少使用原子运算符的成本提高性能，随着GPU和API的不断发展[914]。

​		A缓冲区的优点是，仅分配每个像素所需的片段，GPU上的链表实现也是如此。 从某种意义上讲，这也可能是不利的，因为在开始渲染一帧之前尚不知道所需的存储量。 具有头发，烟雾或其他物体的场景可能具有许多重叠的透明表面，这可能会产生大量片段。Andersson[46]指出，对于复杂的游戏场景，最多对象们（例如树叶）中的50个透明网格和最多200个半透明粒子可能会重叠。

​		GPU通常具有预先分配的内存资源，例如缓冲区和数组，并且链表方法也不例外。用户需要确定所需的内存大小，而内存大小不足会导致明显的瑕疵。 Salvi和Vaidyanathan [1532]提出了一种通过使用Intel引入的称为像素同步的GPU功能来解决此问题的方法，即多层alpha混合。见图5.36。此功能提供了比原子操作更少的开销的可编程混合。他们的方法重新定义了存储和混合的方式，以便在内存用完时优雅地降低性能。粗略的排序顺序可以使他们的方案受益。 DirectX 11.3引入了光栅化程序顺序视图（第3.8节），这是一种缓冲区类型，允许在任何支持此功能的GPU上实现此透明方法[327，328]。移动设备具有类似的技术，称为“瓦片本地存储”，它允许它们实现多层alpha混合[153]。但是，这种机制会降低性能，因此这种算法可能是高消耗的[1931]。

![image-20191216225733273](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216225733273.png)

​		<font size=2>图5.36。 在左上方，执行传统的从后到前的Alpha混合，由于排序顺序不正确，导致渲染错误。 右上方的A缓冲区被用于提供一个完美的非交互结果。 左下方显示了具有多层alpha混合的渲染。 右下方显示了A缓冲区和多层图像之间的差异，乘以4可得到可见性[1532]。 （图片由英特尔公司的Marco Salvi和Karthik Vaidyanathan提供。）</font>

​		这种方法建立在Bavoil等人提出的k缓冲区的概念上[115]，其中保存了前几层可见图层并对其进行了排序，而更深的图层则被丢弃和合并。 Maule等[1142]使用k缓冲区并通过使用加权平均来解决这些较远的深层。 加权总和[1202]和加权平均[118]透明性技术与顺序无关，是单次pass并且可以几乎在每个GPU上运行。 问题在于它们没有考虑对象的顺序。 因此，例如，使用Alpha表示覆盖率，蓝色纱布围巾上方的红色纱巾给出了紫色，而正确地看到红色的围巾却带有一点蓝色。 虽然对于几乎不透明的对象给出的结果很差，但是这类算法对于可视化很有用，并且对于高度透明的表面和粒子也适用。 见图5.37。

![image-20191216225751091](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216225751091.png)

​		<font size=2>图5.37。 随着不透明度的增加，对象顺序变得越来越重要。 （Dunn [394]之后的图像。）</font>

在加权和透明中，公式为
$$
\mathbf{c}_o=\sum_{i=1}^{n}(\alpha_i\mathbf{c}_i)+
\mathbf{c}_d(1-\sum_{i=1}^{n}\alpha_i),
\qquad\qquad(5.27)
$$
​		其中n是透明表面的数量，$\mathbf{c}_i$和$\alpha_i$表示透明度值的集合，而$\mathbf{c}_d$是场景的不透明部分的颜色。 当渲染透明表面时，将两个和累积并分别存储作，并在透明pass结束时在每个像素处评估方程式。 该方法的问题在于，第一总和饱和，即生成大于（1.0、1.0、1.0）的颜色值，并且背景颜色可能会产生负面影响，因为alpha的总和可能超过1.0。

通常首选加权平均方程式，因为它避免了这些问题：
$$
\begin{align}
\mathbf{c}_{sum}&=\sum_{i=1}^n(alpha_i\mathbf{c}_i),\alpha_{sum}=\sum_{i=1}^n\alpha_i,\\
\mathbf{c}_{wavg}&=\frac{\mathbf{c}_{sum}}{\alpha_{sum}},\alpha_{avg}=\frac{\alpha_{sum}}{n},\\
u&=(1-\alpha_{avg})^n,\\
\mathbf{c}_o&=(1-u)\mathbf{c}_{wavg}+u\mathbf{c}_d.
\end{align}
\qquad\qquad(5.28)
$$
​		第一行表示透明渲染期间在两个单独的缓冲区中生成的结果。 每个对$\mathbf{c}_{sum}$有贡献的表面都受到一个由其alpha加权的影响； 几乎不透明的表面贡献了更多的颜色，几乎透明的表面几乎没有影响。 通过将$\mathbf{c}_{sum}$除以$\alpha_{sum}$，可以得到加权平均透明颜色。 值$\alpha_{avg}$是所有alpha值的平均值。 值$u$是对$n$个透明表面应用此平均alpha值$n$次后目标（不透明场景）的估计可见性。 最后一行实际上是over运算符，其中（1- u）代表源的alpha。

​		加权平均值的一个限制是，对于相同的Alpha，它将均匀混合所有颜色，而不考虑顺序。 McGuire和Bavoil [1176，1180]引入了加权混合与顺序无关的透明，以提供更具说服力的结果。 在它们的公式中，到表面的距离也会影响权重，而更近的表面会受到更大的影响。 而且，不是对alpha进行平均，而是通过将与项$（1-\alpha_i）$相乘并减一来计算u，从而获得一组表面的正确alpha覆盖。 如图5.38所示，该方法产生了更具视觉效果的结果。

![image-20191216230234435](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216230234435.png)

​		<font size=2>图5.38。 查看同一引擎模型的两个不同的摄像头位置，均使用加权混合与顺序无关的透明度进行渲染。 按距离加权有助于弄清哪些表面更靠近观察者[1185]。 （图片由Morgan McGuire提供。）</font>

​		缺点是，在较大的环境中，彼此靠近的对象的距离权重几乎相等，因此结果与加权平均值几乎没有区别。 另外，随着相机到透明物体的距离改变，深度权重可能会随之改变，但是这种改变是逐渐的。

​		McGuire和Mara [1181，1185]将这种方法扩展为包括一种可能的透射色效果。 如前所述，本节中讨论的所有透明度算法都将各种颜色混合在一起而不是过滤它们，从而模仿了像素覆盖。 为了提供滤色器效果，不透明场景由像素着色器读取，每个透明表面将其在该场景中覆盖的像素乘以其颜色，然后将结果保存到第三个缓冲区。 现在，在解析透明缓冲区时，将使用该缓冲区（其中的不透明对象现在由透明对象着色）来代替不透明场景。 该方法之所以有效，是因为与覆盖所致的透明不同，颜色传输与顺序无关。

​		还有其他算法使用这里介绍的几种技术中的元素。例如，Wyman[1931]通过内存需求，插入和合并方法，使用alpha覆盖率还是几何覆盖率以及如何处理丢弃的片段对先前的工作进行了分类。他介绍了通过寻找先前研究中的空白而发现的两种新方法。他的随机分层alpha混合方法使用k缓冲区，加权平均值和随机透明。他的其他算法是Salvi和Vaidyanathan方法的一种变体，使用了覆盖蒙版而不是alpha。

​		鉴于各种类型的透明内容，渲染方法和GPU功能，没有完美的解决方案来渲染透明对象。我们请感兴趣的读者阅读Wyman的论文[1931]和Maule等人的关于交互式透明算法的更详细的调查[1141]。 McGuire的演讲[1182]提供了该领域的更广阔视野，贯穿了其他相关现象，例如体积光，颜色透射和折射，这些将在本书的后面进行更深入的讨论。

#### 5.5.3预乘Alpha和合成

​		over操作符还用于将照片或合成渲染的对象混合在一起。 此过程称为合成（compositing）[199，1662]。 在这种情况下，每个像素的alpha值将与对象的RGB颜色值一起存储。 由Alpha通道形成的图像有时称为遮罩。 它显示了对象的轮廓形状。 有关示例，请参见第203页的图6.27。 然后可以将此RGBα图像与其他此类元素或背景混合使用。

​		使用合成RGBα数据的一种方法是使用预乘alpha（也称为关联的alpha）。 即，在使用之前，RGB值乘以alpha值。 这使得对合成under方程更加高效：
$$
\mathbf{c}_o=\mathbf{c}_s'+(1-\alpha_s)\mathbf{c}_d
\qquad\qquad(5.29)
$$
​		其中$\mathbf{c}'_s$是预乘的源通道，代替公式5.25中的$\alpha_s\mathbf{c}_s$。 预乘Alpha还可以在不更改混合状态的情况下使用over和加法混合，因为现在在混合过程中已添加了源颜色[394]。 请注意，预乘的RGBα值它们通常不大于alpha值，尽管可以使RGB分量产生特别明亮的半透明值。

​		渲染合成图像自然的与预乘alpha吻合。 默认情况下，在黑色背景上渲染的不透明抗锯齿对象会提供预乘值。 假设白色（1,1,1）三角形沿其边缘覆盖了某些像素的40％。 使用（极精确）抗锯齿功能，像素值将设置为0.4的灰度，即我们将为此像素保存颜色（0.4,0.4,0.4）。 如果存储，alpha值也将为0.4，因为这是三角形覆盖的区域。 RGBα值为（0.4、0.4、0.4、0.4），这是一个预乘值。

​		图像存储的另一种方式是使用未乘积的alpha，也称为未关联的alpha，或者甚至是术语非预乘的alpha。未乘Alpha就是它的意思：RGB值不乘以Alpha值。对于白色三角形示例，未相乘的颜色为（1,1,1,0.4）。这种表示形式的优点是可以存储三角形的原始颜色，但是在显示之前，始终需要将该颜色乘以存储的alpha值。每次执行过滤和混合操作时，最好使用预乘数据，因为使用未乘Alpha不能正确执行线性插值之类的操作[108，164]。可能会出现诸如围绕对象边缘的黑色条纹之类的瑕疵[295，648]。请参见第6.6节的结尾进行进一步讨论。预乘的alpha值也可以进行更清晰的理论处理[1662]。

​		对于图像处理应用程序而言，未关联的alpha值可用于遮盖照片而不影响基础图像的原始数据。同样，未关联的alpha表示可以使用颜色通道的整个精度范围。就是说，必须注意正确地将未相乘的RGBα值与用于计算机图形计算的线性空间正确地相互转换。例如，没有浏览器正确执行此操作，也没有可能这样做，因为现在预计会出现不正确的行为[649]。支持Alpha的图像文件格式包括PNG（仅非关联的Alpha），OpenEXR（仅关联）和TIFF（两种Alpha类型）。

​		与alpha通道有关的一个概念是色键[199]。这是视频制作中的一个术语，其中演员是在绿色或蓝色屏幕上拍摄并与背景融合在一起的。在电影行业中，此过程称为绿屏或蓝屏。这里的想法是将特定的色调（用于胶卷）或精确值（用于计算机图形）指定为透明；只要检测到背景，就会显示背景。这样，仅使用RGB颜色即可为图像提供轮廓形状。无需存储任何Alpha。该方案的一个缺点是，对象在任何像素处要么完全不透明，要么完全透明，即Alpha实际上仅为1.0或0.0。例如，GIF格式允许将一种颜色指定为透明。

### 5.6显示编码

​		当我们计算照明，纹理或其他操作的效果时，使用的值假定为线性。 非正式地，这意味着加法和乘法按预期工作。 但是，为了避免各种视觉瑕疵，显示缓冲区和纹理使用我们必须考虑的非线性编码。 简短而草率的答案如下：选取[0，1]范围内的着色器输出颜色并将其提高1 / 2.2的幂，执行所谓的伽马校正。 对传入的纹理和颜色执行相反的操作。 在大多数情况下，您可以告诉GPU为您执行这些操作。 本节说明了快速摘要的方式和原因。

​		我们从阴极射线管（CRT）开始。在数字成像的早期，CRT显示器已成为常态。这些设备在输入电压和显示辐射率之间表现出幂关系。随着施加到像素的能量水平的增加，发出的辐射不会线性增长，而是（令人惊讶地）与该水平成比例地上升，并提高到大于1的功率。例如，假设幂为2。设置为50％的像素将发出设置为1.0的像素的四分之一的光量，即$0.5^2 = 0.25 $[607]。尽管LCD和其他显示技术的固有色调响应曲线与CRT不同，但它们是通过转换电路制造的，从而使它们模仿了CRT响应。

​		该幂函数几乎与人类视觉的亮度灵敏度相反[1431]。这种幸运的巧合的结果是，编码在感觉上大致是统一的。即，在可显示范围内，一对编码值N和N + 1之间的感知差大致恒定。通过测量阈值对比度，我们可以在各种条件下检测到亮度差异约1％。当将颜色存储在有限精度的显示缓冲区中时，这种接近值的最佳分布可以最大程度地减少条带化现象（第23.6节）。相同的好处也适用于通常使用相同编码的纹理。

​		显示传递函数描述了显示缓冲区中的数字值与从显示器发出的辐射度之间的关系。因此，它也称为电光学传递函数（EOTF）。显示传递函数是硬件的一部分，在计算机显示器，电视和电影放映机之间有不同的标准。还有一个标准的传递函数对于过程的另一端，图像和视频捕获设备，称为光电传递函数（OETF）[672]。

​		在编码用于显示的线性颜色值时，我们的目标是消除显示传递函数的影响，以便我们计算的任何值都将发出相应的辐射度。例如，如果我们的计算值加倍，我们希望输出辐射率加倍。为了保持这种连接，我们应用了显示传递函数的逆函数来抵消其非线性效应。使显示屏的响应曲线无效的过程也称为伽马校正，其原因很快就会清楚。在解码纹理值时，我们需要应用显示传递函数来生成用于着色的线性值。图5.39显示了在显示过程中解码和编码的使用。

![image-20191216230605336](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216230605336.png)

​		<font size=2>图5.39。 在左侧，GPU着色器访问PNG颜色纹理，并将其非线性编码的值转换为线性（蓝色）。 进行着色和色调映射后（第8.2.2节），最终的计算值被编码（绿色）并存储在帧缓冲区中。 该值和显示传递函数确定发出的辐射量（红色）。 绿色和红色功能的组合抵消了，因此发出的辐射与线性计算值成正比。</font>

​		个人计算机显示器的标准传递函数由被称为sRGB的颜色空间规范定义。当从纹理读取值或将值写入颜色缓冲区时，可以将大多数控制GPU的API设置为自动应用正确的sRGB转换[491]。如第6.2.2节所述，生成Mipmap还将考虑sRGB编码。通过先转换为线性值，然后执行插值，纹理值之间的双线性插值将正确工作。通过将存储的值解码回线性值，混合新值，然后对结果进行编码，可以正确完成Alpha混合。

​		当将值写入显示的帧缓冲区时，在渲染的最后阶段应用转换很重要。 如果在显示编码之后应用后期处理，则此类效果会在非线性值上计算，这通常是不正确的，并且经常会导致伪影。 可以将显示编码视为一种压缩形式，这可以最好地保留该值的感知效果[491]。 考虑这一领域的一个好方法是使用线性值来执行物理计算，每当我们要显示结果或访问可显示图像（例如颜色纹理）时，我们需要使用适当的编码或解码转换，将数据移入或移出其显示编码形式。

如果确实需要手动应用sRGB，则可以使用标准转换公式或一些简化版本。 实际上，显示是由每个颜色通道的bit数控制的，例如，对于消费者级别的显示器而言，bit数是8，从而给出了一组在[0,255]范围内的级别。 在这里，我们将显示编码的级别表示为[0.0,1.0]范围，而忽略bit数。 线性值也在[0.0，1.0]范围内，表示浮点数。 我们用x表示这些线性值，用y表示存储在帧缓冲区中的非线性编码值。 要将线性值转换为sRGB非线性编码值，我们应用sRGB显示传递函数的逆函数：
$$
y=f_{sRGB}^{-1}(x)=
\begin{cases}
\begin{align}
&1.055x^{1/2.4}-0.055,\quad \text{where} x >0.0031308,\\
&12.92x,\quad \text{where} x\leq 0.0031308,
\end{align}
\end{cases}
\qquad\qquad(5.30)
$$
​		x代表线性RGB三元组的通道。 该方程式适用于每个通道，这三个生成的值驱动显示。 如果您手动应用转换函数，请当心。 错误的一种来源是使用编码的颜色而不是线性形式，而另一种来源是对颜色进行两次解码或编码。

​		这两个变换表达式的底部是一个简单的乘法，这是由于数字硬件需要使变换完全可逆[1431]。顶部的表达式，涉及将值提升为幂的几乎适用于输入值x的整个范围[0.0，1.0]。 考虑到偏移量和缩放，此函数非常近似于一个更简单的公式[491]：
$$
y=f_{display}^{-1}(x)=x^{1/\gamma}
$$
​		$\gamma$= 2.2。 希腊字母$\gamma$是名称“伽玛校正”的基础。

​		正如必须对计算值进行编码以进行显示一样，在进行计算之前，必须将静态相机或摄像机捕获的图像转换为线性值。 您在显示器或电视上看到的任何颜色都有一些可通过屏幕捕获或颜色选择器获得的显示编码的RGB三元组。 这些值是以PNG，JPEG和GIF等文件格式存储的，这些格式可以直接发送到帧缓冲区以在屏幕上显示而无需转换。 换句话说，您在屏幕上看到的任何内容都是定义为显示编码的数据。 在着色计算中使用这些颜色之前，我们必须将这种编码形式转换回线性值。 从显示编码到线性值我们需要的sRGB转换：
$$
x=f_{sRGB}(y)=
\begin{cases}
\begin{align}
\left(
\frac{y+0.055}{1.055}
\right)^{2.4}, \text{where} y>0.04045,\\
\frac{y}{12.92},\text{where} y\leq 0.04045,
\end{align}
\end{cases}
\qquad\qquad(5.32)
$$
​		其中y表示标准化的显示通道值，即存储在图像或帧缓冲区中的值，表示为[0.0，1.0]范围内的值。 此解码函数与我们先前的sRGB公式相反。 这意味着，如果着色器访问纹理并输出纹理而未做任何更改，则其外观将与预期的一样。 解码函数与显示传递函数相同，因为存储在纹理中的值已被编码以正确显示。 我们没有为转换提供线性响应显示，而是为转换提供线性值。

​		更简单的伽玛显示传递函数是公式5.31的反函数
$$
x=f_{display}(y)=y^{\gamma}.\qquad\qquad(5.33)
$$
​		有时，您会看到一个更简单的转化对，尤其是在移动应用和浏览器应用中[1666]：
$$
\begin{align}
y=&f_{simpl}^{-1}(x)=\sqrt{x},\\
x=&f_{simpl}(y)=y^2;
\end{align}
\qquad\qquad(5.34)
$$
​		也就是说，取线性值的平方根进行转换以进行显示，而将其自身的多个值取反即可。 虽然粗略近似，但这种转换比完全忽略该问题要好。

​		如果我们不注意伽玛，则较低的线性值将在屏幕上显得太暗。 一个相关的错误是，如果不执行伽玛校正，某些颜色的色调可能会偏移。 假设我们的$\gamma$= 2.2。 我们要从显示的像素发出与线性计算值成正比的辐射，这意味着我们必须将线性值提高到（1 / 2.2）幂。 线性值0.1给出0.351，0.2给出0.481，而0.5给出0.730。 如果未编码，则按原样使用这些值将导致显示器发出的辐射比所需的少。 请注意，任何这些转换都始终不会更改0.0和1.0。 在使用伽玛校正之前，场景建模人员通常会人为地增加深色表面的颜色，并在逆显示变换中对其进行折叠。

​		忽略伽马校正的另一个问题是，以非线性值执行物理线性辐射度值正确的着色计算。 图5.40给出了一个示例。

![image-20191216231908818](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216231908818.png)

​		<font size=2>图5.40。 两个重叠的聚光灯照亮平面。 在左图像中，在将光值0.6和0.4相加后不执行伽马校正。 有效地对非线性值执行加法操作，从而导致错误。 请注意，左侧的光线看起来比右侧的光线明显明亮，并且重叠部分显得不切实际地明亮。 在右图中，相加后将对值进行伽玛校正。 灯光本身成比例地变亮，并且在重叠的地方可以正确组合。</font>

​		忽略伽玛校正也会影响抗锯齿边缘的质量。 例如，假设一个三角形的边缘覆盖了四个屏幕网格单元（图5.41）。 三角形的规范化辐射率为1（白色）； 背景为0（黑色）。 从左到右，单元格覆盖了$\frac{1}{8}$、$\frac{3}{8}$、$\frac{5}{8}$和$\frac{7}{8}$。因此，如果我们使用盒式滤镜，我们希望将像素的规范化线性辐射度表示为0.125、0.375、0.625和0.875。 正确的方法是对线性值执行抗锯齿，将编码函数应用于四个结果值。 如果不这样做，像素的代表辐射将太暗，从而导致边缘的变形，如图右侧所示。 这种伪影称为绕线，因为边缘看起来有点像扭绳[167，1265]。 图5.42显示了这种效果。

![image-20191216231931569](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216231931569.png)

​		<font size=2>图5.41。 在左侧，黑色（显示为灰色）背景上的白色三角形的边缘覆盖了四个像素，并显示了真实的区域覆盖率。 如果不执行伽玛校正，则中间色调的变暗会导致边缘的扭曲，如右图所示。</font>

![image-20191216231948366](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191216231948366.png)

​		<font size=2>图5.42。 左侧的一组抗锯齿线经过了伽马校正； 在中间，该集合被部分校正； 在右边，没有伽马校正。 （图片由Scott R. Nelson提供。）</font>

​		sRGB标准创建于1996年，现已成为大多数计算机显示器的标准。 但是，从那时起，显示技术得到了发展。 已经开发出更明亮并且可以显示更多颜色的显示器。 在8.1.3节中讨论了彩色显示和亮度，在8.2.1节中介绍了高动态范围显示的显示编码。 哈特（Hart）的文章[672]特别详尽地提供了有关高级显示器的更多信息。

### 进一步阅读和资源

​		Pharr等[1413]更深入地讨论了采样模式和抗锯齿。 Teschner的课程笔记[1758]显示了各种采样模式生成方法。 Drobot [382，383]对实时抗锯齿进行了以前的研究，解释了各种技术的属性和性能。可以在相关的GRAGRAPH课程[829]的注释中找到有关各种形态抗锯齿方法的信息。 Reshetov和Jimenez [1486]提供了游戏中使用的形态学和相关时间抗锯齿工作的最新回顾。

​		对于透明性研究，我们再次请有兴趣的读者阅读McGuire的陈述[1182]和Wyman的著作[1931]。布林（Blinn）的文章“什么是像素？” [169]很好地浏览了计算机图形学的多个领域，同时讨论了不同的定义。 Blinn的“脏像素和符号，符号，符号”书籍[166，168]包含一些有关滤波和抗锯齿的介绍性文章，以及有关alpha，合成和gamma校正的文章。 Jimenez的演讲[836]详细介绍了抗锯齿技术。

​		Gritz和d'Eon [607]对伽玛校正问题进行了很好的总结。 Poynton的书[1431]对各种媒体中的伽玛校正以及其他与颜色有关的主题进行了详尽的介绍。塞兰（Selan）的白皮书[1602]是更新的资料，它解释了显示编码及其在电影行业中的用途，以及许多其他相关信息。