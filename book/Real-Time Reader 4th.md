# 						Real-Time Rendering 4th

## 1.介绍

### 1.2符号和定义

​		首先，我们将解释本书中使用的数学符号。有关本节以及整本书中使用的许多术语的更详尽说明，请访问realtimerendering.com获取我们的线性代数附录。

#### 1.2.1数学定义

​		表1.1总结了我们将使用的大多数数学符号。一些概念将在这里详细描述。

​		请注意，表中的规则有一些例外，主要是着色方程使用在文献中已经极为完善的符号表示法，例如L

代表辐射度，E代表辐照度，$$\sigma_s$$代表散射系数。

​		角度和标量取自$$\mathbb{R}$$，即它们是实数。矢量和点用粗体小写字母表示，并且访问方式为

​	**向量**：
$$
\vec v=
\begin{gather*}
\begin{pmatrix}
v_x \\v_y \\v_z\\v_w
\end{pmatrix}
\end{gather*}
$$
​		列向量格式是计算机图形学世界中常用的格式。在本书的某些地方，我们使用$$(v_x,v_y,v_z)$$代替更正确的形式$$(v_x,v_y,v_z)^T$$，因为前者更容易阅读.


|            类型            |                           注意事项                           |                             例子                             |
| :------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|        角度(angle)         |                         小写希腊字母                         |          $$\alpha_i,\eta,\beta,\theta,\gamma_{60}$$          |
|        因子(scalar)        | 小写英文字母*<kbd><font color=#0099ff size=4>斜体</font></kbd>* |                    *$$a,b,c,u_k,w_{ij}$$*                    |
| 向量或点(vector or point)  |     小写英文字母<kbd><font size=4>**粗体**</font></kbd>      | $$\textbf{a},\textbf{u},\textbf{v}_s,\textbf{h}(\rho),\textbf{h}_z$$ |
|        矩阵(matrix)        |         大写<kbd><font size=4>**粗体**</font></kbd>          |   $$\textbf{T}(\textbf{t}),\textbf{X},\textbf{R}_x(\rho)$$   |
|        平面(plane)         |            $\pi$:法向量点乘平面内任意向量加上因子            | $$\pi:\textbf{n}\cdot\textbf{x}+d=0\\\pi_1:\textbf{n}_1\cdot\textbf{x}+d_1=0\\$$ |
|      三角形(triangle)      |                           △和3个点                           | $$\triangle{\textbf{v}_0\textbf{v}_1\textbf{v}_2},\triangle\textbf{cba}$$ |
|     线段(line segment)     |                            两个点                            |           $$\textbf{uv},\textbf{a}_i\textbf{b}_j$$           |
| 几何物体(geometric entity) |    大写*<kbd><font color=#0099f size=4>斜体</font></kbd>*    |                   *$$A_{OBB},T,B_{AABB}$$*                   |

​		<font size=2>表1.1本书中所用符号的摘要。</font>

大写，小写

希腊字母，英文字母

粗体，非粗体

斜体，非斜体

|      |                            运算符                            |     描述     |
| :--: | :----------------------------------------------------------: | :----------: |
|  1   |                          $$\cdot$$                           |     点乘     |
|  2   |                          $$\times$$                          |     叉乘     |
|  3   |                       $$\textbf{v}^T$$                       |  向量的转置  |
|  4   |                           $$\bot$$                           |    逆运算    |
|  5   |               $$\lvert\quad\cdot\quad\rvert$$                |    绝对值    |
|  6   |               $$\lvert\quad\cdot\quad\rvert$$                | 矩阵的行列式 |
|  7   |               $$\lVert\quad\cdot\quad\rVert$$                |  结构的长度  |
|  8   |                          $$x^{+}$$                           | x的值不小于0 |
|  9   |                         $$x^{\mp}$$                          |  x限制在0~1  |
|  10  |                            $$n!$$                            |     梯乘     |
|  11  | $$\begin{gather*}\begin{pmatrix}n\\k\end{pmatrix}\end{gather*}$$ |  二项式系数  |


$$
x^{+}=

\begin{cases}
x,&x>0\\
0,&otherwise
\end{cases}
$$

$$
x^{\mp}=
\begin{cases}
1,\qquad if&x\geq1,\\
x,\qquad if&0<x<1,\\
0,&otherwise.
\end{cases}
$$



$$
n!=n(n-1)(n-2)\cdot\cdot\cdot3\cdot2\cdot1
$$


$$
\begin{gather*}\begin{pmatrix}n\\k\end{pmatrix}\end{gather*}=
\frac{n!}{k!(n-k!)!}
$$


|      |      函数      | 描述 |
| :--: | :------------: | :--: |
|  1   | $$atan2(y,x)$$ |      |
|  2   |   $$log(n)$$   |      |

#### 1.2.2几何定义

​		所有图形硬件使用的基础渲染图元是由点，线，三角形组成的。

​		在这本书中，我们把几何实体的集合称为模型或者对象。场景是所有包含在环境中被渲染的模型的集合，同时场景还包含光源，材质描述，视图大小。

​		举个例子，比如说一辆车，一栋建筑，甚至是一条线。实际上，一个对象经常由一组渲染图元组成，但有特殊情况。一个对象可能具有相比基础渲染图元更高阶的几何表示，比如bezier曲线和表面，或者再细分的表面。当然，对象可以由其他的对象组成，比如一辆车包含4个车门，4个车轮等等。		

#### 1.2.3着色

​		遵循在计算机图形学中公认的用法，在本书中，术语 shading（着色），shader（着色器）和及其相关联的词用于指两个不同但相关的概念：计算机生成的视觉外观（例如着色模型，着色方程，卡通着色”）或者渲染系统中可编程组件（例如顶点着色器，着色语言）。不论哪种情况，指代的概念都会在其上下文中描述清楚。

#### 进一步阅读和资源

​		我们可以为您推荐的最重要资源是本书的网站：realtimerendering.com。它包含指向每个章节的最新信息和网站的链接。实时渲染的领域实时变化。在本书中，我们尝试着眼于基本概念和不太可能过时的技术。在网站上，我们有机会介绍与当今的软件开发人员相关的信息，并且我们能够使其保持最新状态。
















## 2.渲染管线

​		本章介绍了实时图形的核心组件，即图形渲染管道，也简称为“管道”。管道的主要功能是在给定虚拟摄像机的情况下生成或渲染二维图像，三维物体，光源等。因此，渲染管道是实时渲染的基础工具。使用管道的过程如图2.1所示。图像中对象的位置和形状由其几何形状，环境特征以及相机在该环境中的位置决定。对象的外观受材料属性，光源，纹理（应用于表面的图像）和着色方程的影响。

![1568991361207](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1568991361207.png)

​		<font size=2>图2.1。在左图中，虚拟摄像机位于金字塔的顶端（四条线会聚的点）。仅渲染视图体积内的基元。对于以透视方式呈现的图像（如这里的情况），视图体积是平截头体，即一个头部被截取的棱椎。右图显示了相机“看到的内容”。请注意，左图中的红色圆环形状不在右侧渲染中，因为它位于视锥体外。此外，左图像中的扭曲蓝色棱镜被夹在平截头体的顶平面上。</font>

​		我们将解释渲染管道的不同阶段，重点是功能而不是实现。应用这些阶段的相关细节将在后面的章节中介绍。

### 2.1结构

​		在物理世界中，管道概念以许多不同的形式表现出来，从工厂装配线到快餐厨房。它也适用于图形渲染。管道由若干阶段组成，每个阶段执行庞大任务的一部分。

​		流水线的每个阶段是并行执行的，每个阶段取决于前一阶段的结果。理想情况下，一个非流水线系统被划分成n个流水线阶段，可以带来n倍的速度提升。性能的提高是使用流水线操作的主要原因。例如，一堆数量庞大的三明治可以被一些分工好的工人快速准备好 —— 一个准备面包，另一个添加肉，另一个添加配料。每个人都将自己的结果传递给下一个人，并立即开始下一个三明治的工作。如果每个人花费20秒来执行他们的任务，则每20秒，每分钟三次，最大速率可以生产一个三明治。尽管流水线是并行执行的，但它们会被拖延直到最慢的阶段完成其任务。例如，假设肉类添加阶段变得更加复杂，需要30秒。现在最好的速度是一分钟两个三明治。在这个特殊的流水线，肉类阶段是瓶颈，因为它决定了整个生产的速度。于是配料阶段在等待肉类阶段的完成时处于饥饿状态（对于顾客也是）。

​		这种管道结构也可以在实时计算机图形的背景下找到。将实时渲染管线粗略划分为四个主要阶段 - **应用，几何处理，光栅化和像素处理** - 如图2.2所示。这种结构是渲染管线的核心在实时计算机图形应用程序中，因此是后续章节中讨论的重要基础。这些阶段通常又是一个管线，这意味着它由几个子阶段组成。我们区分这里显示的功能阶段和它们的实现结构。功能阶段有明确的任务要执行，但没有指定任务在管线中执行的方式。给定的实现可以将两个功能阶段组合成一个单元或者执行使用可编程核心，同时将另一个更耗时的功能阶段划分为多个硬件单元。

![1568994209724](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1568994209724.png)

<font size=2>		图2.2。渲染管道的基本构造，包括四个阶段：应用程序，几何处理，光栅化和像素处理。这些阶段中的每一个本身可以是管线，如几何处理阶段下面所示，或者阶段可以（部分）并行化，如像素处理阶段所示。在此图示中，应用程序阶段是单个进程，但此阶段也可以是流水线或并行化的。注意，光栅化找到图元内的像素，例如三角形。</font>

渲染速度可以以每秒帧数（FPS）表示，即每秒渲染的图像的数量。它也可以用赫兹（Hz）表示，它只是1 /秒的符号，即更新的频率。通常以毫秒（ms）表示渲染图像所需的时间。生成图像的时间通常会有所不同，具体取决于每帧期间执行的计算的复杂程度。每秒帧数用于表示特定帧的速率，或表示某个使用持续时间内的平均性能。赫兹用于硬件，例如显示器，其能被设置为固定速率。

​		顾名思义，应用程序阶段由应用程序驱动，因此通常由在通用CPU上运行的软件实现。这些CPU通常包括多个内核，这些内核能够并行处理多个执行线程。这使CPU可以高效地运行应用程序阶段负责的各种任务。传统上在CPU上执行的某些任务包括碰撞检测，全局加速算法，动画，物理仿真以及许多其他任务，具体取决于应用程序的类型。下一个主要阶段是几何处理，它处理变换，投影和所有其他类型的几何处理。此阶段计算要绘制的内容，应如何绘制以及应在何处绘制。几何阶段通常在包含许多可编程内核以及固定操作硬件的图形处理单元（GPU）上执行。光栅化阶段通常将三个顶点作为输入，形成一个三角形，然后找到该三角形内所有要考虑的像素，然后将其转发到下一个阶段。最后，像素处理阶段为每个像素执行一个程序以确定其颜色，并可以执行深度测试以查看其是否可见。它还可以执行每个像素的操作，例如将新计算的颜色与以前的颜色混合。光栅化和像素处理阶段也完全在GPU上进行处理。所有这些阶段及其内部管道将在接下来的四个部分中讨论。有关GPU如何处理这些阶段的更多详细信息，请参阅第3章。

### 2.2应用程序阶段

​		由于通常在CPU上执行，因此开发人员可以完全控制应用程序阶段发生的事情。因此，开发人员可以完全确定实现，以后可以对其进行修改以提高性能。此处的更改也会影响后续阶段的性能。例如，应用程序阶段算法或设置可以减少要渲染的三角形的数量。
​		综上所述，某些应用程序工作可以由GPU使用称为计算着色器的单独模式来执行。此模式将GPU视为高度并行的通用处理器，而忽略了专门用于渲染图形的特殊功能。在应用程序阶段结束时，要渲染的几何图形被传送到几何阶段。这些是渲染图元（rendering primitives），即点，线和三角形，它们最终可能最终出现在屏幕上（或使用的任何输出设备）。这是应用程序阶段最重要的任务。

​		此阶段基于软件的实现的结果是，它不像几何处理，光栅化和像素处理阶段那样分为子阶段。但是为了提高性能，该阶段通常在多个处理器上并行执行核心。在CPU设计中，这被称为超标量构造，因为它能够在同一阶段同时执行多个进程$$^1$$。第18.5节介绍了使用多个处理器内核的各种方法。

​		<font size =1.5>1.于CPU本身的流水线规模要小得多，因此可以说应用程序阶段可进一步细分为几个流水线阶段，但这与此处无关。</font>

​		在此阶段通常实现的是碰撞检测。在两个物体之间检测到碰撞之后，可以生成响应并将其发送回碰撞的物体以及力反馈设备。在应用程序阶段，还要处理来自其他来源的输入，例如键盘，鼠标或头戴式显示器。根据此输入，可以发生几种不同类型的动作。加速算法，例如特定的剔除算法（第19章），也在这里实现，以及渲染管线其余部分无法处理的其他任何事情。

### 2.3几何阶段

​		GPU上的几何处理阶段负责大部分对每个三角形和每个顶点的操作。该阶段进一步分为以下功能阶段：顶点着色，投影，裁剪和屏幕映射（图2.3）。

![1569161769020](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1569161769020.png)

​		<font size =2>图2.3几何阶段分为由几个功能阶段组成的管线。</font>

#### 2.3.1顶点着色

​		顶点着色有两个主要任务，即计算一个顶点的位置并评估程序员可能希望作为顶点输出数据的任何东西，例如法线和纹理坐标。在传统意义上，一个对象的大部分着色是通过将光线应用于每个顶点的位置和法线并仅在顶点存储结果颜色来计算的。然后将这些颜色插值到整个三角形上。因此，该可编程顶点处理单元被称为顶点着色器[1049]。随着现代GPU的出现，以及每个像素发生部分或全部着色，此顶点着色阶段变得更加通用，并且可能根本无法评估任何着色方程式，具体取决于程序员的意图。现在，顶点着色器是一个更通用的单元，专用于设置与每个顶点关联的数据。例如，顶点着色器可以使用第4.4节和第4.5节中的方法对对象进行动画处理。

​		我们首先描述如何计算顶点位置，这是始终需要的一组坐标。在进入屏幕的过程中，模型被转换为几个不同的空间或坐标系。最初，模型驻留在其自己的模型空间中，这仅表示该模型根本没有进行转换。每个模型都可以与模型变换相关联，以便可以定位和定向。可能有多个模型变换与单个模型相关联。这允许同一模型的多个副本（称为实例(instances)）在同一场景中具有不同的位置，方向和大小，而无需复制基本几何图形。

​		模型变换变换的是模型的顶点和法线。对象(object)，这里指模型本身，的坐标称为模型坐标，并且在将模型变换应用于这些坐标之后，可以说模型位于世界坐标或世界空间中。世界空间是唯一的，在对模型进行了各自的模型变换后，所有模型都存在于同一空间中。

​		如前所述，仅被摄像机（或观察者）所看到的模型被渲染。摄像机在世界空间中具有特定方向来校准摄像机视角和在特定的位置来放置摄像机。为了便于投影和裁剪操作，使用视图变换对摄像机和所有模型进行变换。视图变换的目的是将摄影机放置在原点并将其对准目标，使其沿负z轴方向看，y轴指向上方，x轴指向右侧。我们使用-z轴约定；有些文字更喜欢看向+ z轴。区别主要是语义上的，因为彼此之间的转换很简单。应用视图变换后的实际位置和方向取决于基础应用程序编程接口（API）。如此划定的空间称为相机空间(camera space)，或更普遍地称为视野空间(view space)或眼睛空间。视图转换影响相机和模型的方式示例如图2.4所示。模型变换和视图变换都可以使用4×4矩阵实现，这是第4章的主题。但是，重要的是要认识到顶点的位置和法线都可以被程序员喜欢的任何方式来计算。

![1569161848796](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1569161848796.png)

​		<font size=2>图2.4。在左图中，自上而下的视图显示了在+ z轴朝上的世界中，按用户期望的方式定位和定向的相机。视图变换可重新定向世界，以使相机位于其原点，沿其负z轴看，而相机的+ y轴朝上，如右图所示。这样做是为了使剪切和投影操作更简单，更快捷。浅蓝色区域是视图体积。在此，假定透视图，因为视图体积为平截头体。类似的技术适用于任何类型的投影。</font>

​		接下来，我们描述顶点着色的第二种输出类型。要产生逼真的场景，仅渲染对象的形状和位置是不够的，但是还必须对它们的外观进行建模。此说明包括每个对象的材料，以及任何照在该对象上的光源的效果。材质和灯光可以采用多种方式建模，从简单的颜色表示到详尽的物理描述。

​		确定光线对材料的影响的这种操作称为着色(shading)。它涉及计算模型对象上各个点的着色方程式。通常，其中一些对模型顶点的计算是在的几何图形处理期间执行的，而其他一些计算可能是在逐像素处理期间执行的。每个顶点可以存储各种材料数据，例如点的位置，法线，颜色或任何评估着色方程式所需的其他数字信息。然后将顶点着色的结果（可以是颜色，矢量，纹理坐标以及任何其他种类的着色数据）发送到光栅化和像素处理阶段以进行插值，并用于计算表面的着色。
​		在本书中，尤其将更深入地讨论GPU顶点着色器的顶点着色形式，在第3章和第5章中。

​		作为顶点着色的一部分，渲染系统先进行投影然后进行裁剪操作，这会将视图体积转换为单位立方体，其顶点位于（-1，-1，-1）和（1、1、1）。并且可以使用定义相同体积但不同范围单位立方体，例如0≤z≤1。单位立方称为规范视图体积。进行投影操作，通常在GPU上由顶点着色器完成。有两种常用的投影方法，即正交投影（也称为平行投影）和透视投影。参见图2.5。实际上，正交投影只是平行投影的一种类型。特别是在建筑领域，还有其他一些用途，例如斜投影和轴测投影。旧的街机游戏Zaxxon从后者命名。

![1569161883414](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1569161883414.png)

<font size=2>		  图2.5 左侧是正交投影或平行投影；右边是透视图。</font>

​		请注意，投影操作表示为矩阵（第4.7节），因此有时可以将其与其余的几何变换连接在一起。

​		正交视图的视图体积通常是一个矩形框，而正交投影会将此视图体积转换为单位立方体。正交投影的主要特征是，平行线在变换后保持平行，此转换是平移和缩放的组合。

​		透视投影有点复杂。在这种类型的投影中，物体离相机越远，投影后出现的越小。此外，平行线可能会聚在地平线上。因此，透视变换模仿了我们感知物体尺寸的方式。从几何学上讲，视场称为视锥，是具有矩形底面的截顶金字塔。视锥也将转换为单位立方体。正交变换和透视变换都可以使用4×4矩阵构造（第4章），并且在进行任何变换之后，都将模型称为裁剪坐标。这些实际上是齐次坐标，将在第4章中进行讨论，因此，这发生在被w除之前。 GPU的顶点着色器必须始终输出此类型的坐标，以使下一个功能阶段（裁剪）正常工作。

​		尽管这些矩阵将一个体积转换为另一个体积，但它们被称为投影，因为在显示之后，z坐标不存储在生成的图像中，而是存储在z缓冲区中，如2.5节所述。这样，模型可以从三个维度投影到两个维度。

#### 2.3.2可选的顶点处理

​		每个管道都有刚刚描述的顶点处理。完成此处理后，GPU上将按照以下顺序进行几个可选阶段：曲面细分(tessellation)，几何着色( geometry shading)和流输出(stream output)。它们的使用取决于硬件的功能（并非所有GPU都具有）以及程序员的需求。它们彼此独立，并且通常不常用。在第3章中将对每个进行更多说明。

​		第一个可选阶段是细分。假设您有一个弹跳的球物体。如果用一组三角形表示它，则可能会遇到质量或性能问题。您的球从5米远处看起来可能不错，但近距离可以看到各个三角形，尤其是沿着轮廓的三角形。如果用更多的三角形制作球以提高质量，则当球太远且仅覆盖屏幕上的几个像素时，可能会浪费大量的处理时间和内存。通过细分，可以生成具有适当数量的三角形的曲面。

​		我们已经讨论了一些三角形，但是到目前为止，我们只处理了顶点。这些可用于表示点，线，三角形或其他对象。顶点可用于描述曲面，例如球。这样的表面可以由一组面片指定，每个面片由一组顶点组成。细分阶段本身包含一系列阶段（船体着色器，细分和域着色器），这些阶段将这些面片顶点集转换为（通常）更大的顶点集，然后用于创建新的三角形集。场景的摄像头可用于确定生成了多少个三角形：靠近时会生成许多三角形，而远离时会生成很少的三角形。

​		下一个可选阶段是几何着色器。该着色器早出现于曲面细分着色器，因此在GPU上更常见。就像曲面细分着色器一样，它可以吸收各种图元并可以产生新的顶点。这是一个非常简单的阶段，因为此创建的范围受到限制，输出基元的类型受到更多的限制。几何着色器有多种用途，其中最流行的一种是粒子生成。想象一下模拟烟花爆炸。每个火球都可以由一个点，单个顶点表示。几何着色器可以获取每个点并将其变成面向观察者并覆盖多个像素的正方形（由两个三角形组成），从而为我们提供了更具说服力的图元进行着色。

​		最后一个可选阶段称为流输出。在此阶段，我们可以将GPU用作几何引擎。此时，我们可以选择将其输出到数组以进行进一步处理，而不是将处理后的顶点向下发送到要渲染到屏幕的剩余管线中。这些数据可以在以后的过程中由CPU或GPU本身使用。此阶段通常用于粒子模拟，例如我们的烟花示例。
​		这三个阶段按此顺序执行（细分，几何体着色和流输出），并且每个阶段都是可选的。不管使用哪个（如果有）选项，如果我们继续沿管线移动，我们都有一组具有齐次坐标的顶点，不论如何都可以在相机视图中查看它们。

#### 2.3.3裁剪

​		只需要将全部或部分视锥体内的图元传递到光栅化阶段（以及随后的像素处理阶段），然后将其绘制在屏幕上。完全位于视锥体内的图元将原样传递到下一个阶段。完全不在视图体积之外的基元不会进一步传递，因为它们不会被渲染。只是部分在视锥体内的图元需要被裁剪。例如，有一条直线有一个顶点在视锥体内另一个顶点在视锥体外那么这条直线需要被视锥体裁剪，将外部顶点替换为位于该线和视图体积的交点处的新顶点。投影矩阵的使用意味着将变换后的图元剪裁在单位立方体上。在裁剪之前执行视图转换和投影的优点是使裁剪问题一致。图元总是被裁剪在单位立方体上。

​		裁剪过程如图2.6所示。除了单位立方体的六个剪切平面之外，用户还可以定义其他剪切平面以可视方式剪切对象。在第818页的图19.1中显示了显示这种类型的可视化效果的图像，称为切片

​		裁剪步骤使用投影产生的4值齐次坐标执行裁剪。在透视空间中，值通常不会跨三角形线性内插。需要第四个坐标，以便在使用透视投影时正确地插入和剪切数据。最后，执行透视划分，将所得三角形的位置放入三维归一化的设备坐标中。如前所述，此视图的体积范围是（-1，-1，-1）到（1,1,1）。几何阶段的最后一步是从该空间转换为窗口坐标

![1569161909685](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1569161909685.png)

​		<font size=2>图2.6。投影变换后，仅将单位立方体内的图元（对应于视锥中的图元）进行后续处理。因此，完全位于单位立方体外的图元将被丢弃，并完全保留完全位于单位立方体内的图元。与单位立方体相交的图元被裁剪到单位立方体上，从而生成新的顶点，而旧的顶点被丢弃。</font>

#### 2.3.4屏幕映射

​		只有视图体积内的（剪切后）图元传递到屏幕映射阶段，进入该阶段时坐标仍然是三维的。每个图元的x坐标和y坐标都将转换为屏幕坐标。屏幕坐标和z坐标也称为窗口坐标。假定场景应渲染到窗口中，最小角在（x1，y1）处，最大角在（x2，y2），其中x1 <x2并且y1 <y2。然后，屏幕映射是平移，随后是缩放操作。新的x和y坐标称为屏幕坐标。 z坐标（对于OpenGL为[−1，+1]，对于DirectX为[0，1]）也映射到[z1，z2]，其中z1 = 0和z2 = 1为默认值。但是，可以使用API进行更改。窗口坐标以及此重新映射的z值将传递到光栅化器阶段。屏幕映射过程如图2.7所示。

![1569161927375](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1569161927375.png)

​		<font size =2>图2.7。投影变换后，图元位于单位立方体中，并且屏幕映射过程会在屏幕上查找坐标。</font>

​		接下来，我们描述整数和浮点值与像素（和纹理坐标）的关系。给定水平像素数组并使用笛卡尔坐标，最左像素的左边界在浮点坐标中为0.0。 OpenGL一直使用此方案，DirectX 10及其后续版本使用它。该像素的中心为0.5。因此，像素[0，9]的范围覆盖了[0.0，10.0）的范围。转换很简单
$$
d=floot(c)\qquad\qquad\qquad (2.1)
\\
c=d+0.5\qquad\quad\quad\qquad (2.2)
$$
其中d是像素的离散（整数）索引，c是像素内的连续（浮点）值。

​		尽管所有API的像素位置值都从左到右增加，但在某些情况下OpenGL和DirectX之间的上下边界零位置不一致。$$^2$$OpenGL始终偏爱笛卡尔系统，将左下角视为值最低的元素，而DirectX有时会根据上下文将左上角定义为此元素。每种都有逻辑，在不同之处没有正确答案。例如，（0，0）位于OpenGL中图像的左下角，而在DirectX中位于左上角。从一个API迁移到另一个API时，必须考虑到这一差异。

​		<font size=1>2.“ Direct3D”是DirectX的三维图形API组件。 DirectX包括其他API元素，例如输入和音频控件。除了在指定特定版本时编写“ DirectX”和在讨论该特定API时编写“ Direct3D”之间，我们没有区别，而是通篇编写“ DirectX”来遵循常用用法。</font>

### 2.4光栅化

​		给定经过变换操作和投影操作的顶点及其关联的着色数据（全部来自几何阶段），下一阶段的目标是查找要渲染的图元（例如三角形）内的所有像素（图片元素的简称）。我们称这种过程为光栅化，它分为两个功能子阶段：三角形设置（也称为图元装配）和三角形遍历。这些显示在图2.8的左侧。注意，它们也可以处理点和线，但是由于三角形是最常见的，因此子阶段的名称中带有“三角形”。光栅化，也称为扫描转换，是从屏幕空间中的二维顶点（每个顶点具有z值（深度值）以及与每个顶点相关的各种阴影信息）到屏幕上的像素的转换。光栅化也可以被视为几何处理阶段和像素处理阶段之间的同步点，因为在这里，三角形是由三个顶点形成的，并最终传递到像素处理阶段。

​		三角形是否被视为与像素重叠取决于您如何设置GPU管线。例如，您可以使用点采样来确定“内部”。最简单的情况是在每个像素的中心使用一个点采样，因此，如果该中心点在三角形内部，则相应的像素也被认为在三角形内部。您还可以使用超采样或多采样抗锯齿技术对每个像素使用一个以上的采样（第5.4.2节）。还有一种方法是使用保守光栅化，其定义是，如果像素的至少一部分与三角形重叠，则该像素“位于三角形内”（第23.1.2节）。

![1569244367703](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1569244367703.png)

​		<font size=2>图2.8。左：光栅化分为两个功能阶段，称为三角形建立和三角形遍历。右图：像素处理分为两个功能阶段，即像素处理和合并。</font>

#### 2.4.1三角形建立

​		在这一阶段，计算三角形的微分，边方程和其他数据。这些数据可用于三角形遍历（第2.4.2节），以及用于内插几何阶段产生的各种阴影数据。固定功能的硬件用于此任务。

#### 2.4.2三角形遍历

​		在这里检查每个中心（或样本）被三角形覆盖的像素，并为与三角形重叠的像素部分生成一个片段。更多详细的采样方法可以在第5.4节中找到。查找哪些样本或像素在三角形内通常被称为三角形遍历。每个三角形片段的属性都是使用在三个三角形顶点之间插值的数据生成的（第5章）。这些属性包括片段的深度，以及来自几何图形阶段的任何阴影数据。 McCormack. [1162]提供了更多关于三角形遍历的信息。在这里，也可以在三角形上执行透视校正内插[694]（第23.1.1节）。然后将图元内部的所有像素或样本发送到像素处理阶段，如下所述。

### 2.5像素处理

​		在这一点上，由于所有先前阶段的组合，已经找到了在三角形或其他图元内部考虑的所有像素。像素处理阶段分为像素着色和合并，如图2.8右侧所示。像素处理是对图元内部的像素或样本执行每个像素或每个样本的计算和操作的阶段。

#### 2.5.1像素着色

​		使用插值的着色数据作为输入，此处可以执行任何每个像素的着色计算。最终结果是一种或多种颜色将传递到下一个阶段。与通常由硬件执行的三角形设置和遍历阶段不同，像素着色阶段由可编程GPU内核执行。为此，程序员为像素着色器（或片段着色器，在OpenGL中众所周知）提供了一个程序，该程序可以包含任何所需的计算。这里可以使用多种技术，其中最重要的一种是纹理化。在第6章中将更详细地讨论纹理化。简单地说，对一个对象进行纹理化意味着出于各种目的将一个或多个图像“粘合”到该对象上。此过程的一个简单示例如图2.9所示。图像可以是一维，二维或三维图像，其中二维图像是最常见的。最简单的说，最终产品是每个片段的颜色值，并将它们传递到下一个子阶段。

![1569244499368](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1569244499368.png)

​		<font size=2>图2.9左上方显示了没有纹理的龙模型。图片中的碎片，将纹理“粘合”到龙上，结果显示在左下方。</font>

#### 2.5.2合并

​		每个像素的信息都存储在颜色缓冲区中，颜色缓冲区是颜色的矩形阵列（每种颜色的红色，绿色和蓝色分量）。合并阶段负责将像素着色阶段产生的片段颜色与当前存储在缓冲区中的颜色进行组合。此阶段也称为ROP，代表“光栅操作（管道）”或“渲染输出单元”，具体取决于您要求的人。与着色阶段不同，执行此阶段的GPU子单元通常不是完全可编程的。但是，它是高度可配置的，可实现各种效果。

​		此阶段还负责解决可见性。这意味着在渲染整个场景后，颜色缓冲区应包含场景中从相机的角度可见的基元的颜色。对于大多数甚至所有图形硬件，这都是通过z缓冲区（也称为深度缓冲区）算法[238]完成的。 Z缓冲区的大小和形状与颜色缓冲区相同，并且对于每个像素，Z缓冲区将z值存储到当前最接近的图元。这意味着，当将图元渲染到某个像素时，该图元在该像素处的z值将被计算并与同一像素处z缓冲区的内容进行比较。如果新的z值小于z缓冲区中的z值，则正在渲染的图元比之前在那个像素处最接近相机的图元更接近相机。因此，该像素的z值和颜色将使用所绘制图元的z值和颜色进行更新。如果计算的z值大于z缓冲区中的z值，则保持颜色缓冲区和z缓冲区不变。 z缓冲区算法很简单，具有O（n）收敛（其中n是要渲染的图元的数量），并且适用于可以为每个（相关）像素计算z值的任何绘图图元。还要注意，该算法允许大多数图元以任何顺序呈现，这是其普及的另一个原因。但是，z缓冲区仅在屏幕上的每个点存储一个深度，因此不能用于部分透明的图元。透明图元必须在所有不透明基元之后渲染，以从后到前的顺序或使用单独的独立于顺序的算法（第5.5节）呈现这些内容。透明度是基本z缓冲区的主要弱点之一。

​		我们已经提到了颜色缓冲区用于存储颜色，而z缓冲区用于存储每个像素的z值。但是，还有其他通道和缓冲区可用于筛选和捕获片段信息。 Alpha通道与颜色缓冲区关联，并为每个像素存储相关的不透明度值（第5.5节）。在较早的API中，alpha通道还用于通过alpha测试功能选择性地丢弃像素。如今，可以将丢弃操作插入到像素着色器程序中，并且可以使用任何类型的计算来触发丢弃。可以使用这种类型的测试来确保完全透明的片段不会影响z缓冲区（第6.6节）。

​		模板缓冲区是一个屏幕外缓冲区，用于记录渲染图元的位置。它通常每个像素包含8位。可以使用各种功能将基元渲染到模板缓冲区中，然后可以使用缓冲区的内容来控制渲染到颜色缓冲区和z缓冲区中。例如，假设已将填充圆绘制到模板缓冲区中。允许以填充圆作为父物体的后续图元和填充圆组合渲染到颜色缓冲区中。模板缓冲区可以是生成某些特殊效果的强大工具。流水线末端的所有这些功能都称为光栅操作（ROP）或混合操作。可以将当前颜色缓冲区中的颜色与三角形内要处理的像素的颜色混合。这可以实现诸如透明度或颜色样本累积的效果。如前所述，混合通常可以使用API进行配置，而不是完全可编程的。但是，某些API支持光栅顺序视图，也称为像素着色器顺序，可启用可编程混合功能。

​		帧缓冲区通常由系统上的所有缓冲区组成。
​		当图元到达并通过光栅化阶段时，从相机的角度可见的图元将显示在屏幕上。屏幕显示颜色缓冲区的内容。为了避免让人类观看者在对其进行栅格化并将其发送到屏幕时看到它们，使用了双重缓冲。这意味着场景的渲染发生在屏幕后方的缓冲区中。将场景渲染到后缓冲区中后，后缓冲区的内容将与先前在屏幕上显示的前缓冲区的内容交换。交换通常发生在垂直回扫过程中，这是安全的时间。
​		有关不同缓冲区和缓冲方法的更多信息，请参见第5.4.2、23.6和23.7节

### 2.6纵观渲染管线

​		点，线和三角形是用于构建模型或对象的渲染图元。假设该应用程序是交互式计算机辅助设计（CAD）应用程序，并且用户正在检查华夫饼制作机的设计。在这里，我们将在整个图形渲染管道中使用此模型，包括四个主要阶段：应用程序，几何，光栅化和像素处理。通过透视投影将场景渲染到屏幕上的窗口中。在这个简单的示例中，华夫饼制作机模型同时包含线（以显示零件的边缘）和三角形（以显示表面）。华夫饼制作机的盖子可以打开。一些三角形是由带有制造商徽标的二维图像制成的。对于此示例，除了在光栅化阶段发生的纹理应用之外，表面着色是在几何阶段完全计算出来的。

#### 应用程序阶段

​		CAD应用程序允许用户选择和移动模型的各个部分。例如，用户可以选择盖子，然后移动鼠标将其打开。应用阶段必须将鼠标移动转换为相应的旋转矩阵，然后确认呈现该矩阵时已将其正确应用于盖子。另一个示例：播放动画，使动画沿预定路径移动，以从不同的角度显示华夫饼制作机。然后必须由应用程序根据时间更新相机参数，例如位置和视图方向。对于要渲染的每个帧，应用程序阶段将相机的位置，照明和模型的图元传入管线中的下一个主要阶段-几何阶段。

#### 几何阶段

​		对于透视图，我们在此假定应用程序已提供了投影矩阵。同样，对于每个对象，应用程序都已计算出一个矩阵，该矩阵描述了视图变换以及对象本身的位置和方向。在我们的示例中，华夫饼制造商的底座将具有一个矩阵，而盖子则具有另一个矩阵。在几何阶段，使用此矩阵转换对象的顶点和法线，从而将对象变化到视图空间。然后，可以使用材质和光源属性来计算顶点处的阴影或其他计算。然后使用单独的用户提供的投影矩阵执行投影，将对象转换为代表眼睛所见的单位立方体的空间。单位立方体外部的所有图元都将被丢弃。将与该单位立方体相交的所有图元都裁剪到该单位立方体上，以便获得一组完全位于单位立方体内的图元。然后将这些顶点映射到屏幕上的窗口中。在完成所有这些按三角形和按顶点进行的操作之后，将所得数据传递到光栅化阶段。

#### 光栅化

​		然后光栅化所有在上一阶段幸存下来的图元，这意味着找到了图元内部的所有像素，并将它们进一步发送到管线以进行像素处理。

#### 像素处理

​		此处的目标是计算每个可见图元的每个像素的颜色。那些与任何纹理（图像）相关联的三角形将根据需要应用这些图像进行渲染。可见性通过z缓冲区算法以及可选的丢弃和模板测试来解决。依次处理每个对象，然后将最终图像显示在屏幕上。

### 结语

​		渲染管线源于针对实时渲染应用程序的数十年的API和图形硬件演变。重要的是要注意，这不是唯一的渲染管线。离线渲染管道经历了不同的进化路径。电影制作的渲染通常是通过微多边形管线完成的[289，1734]，但是光线追踪和路径追踪近来已取而代之。 11.2.2节中介绍的这些技术，这些技术也可以用于建筑和设计的预可视化。

​		多年来，应用程序开发人员使用此处描述的过程的唯一方法是通过使用中的图形API定义的固定功能管道。固定功能管道之所以如此命名，是因为实现它的图形硬件包含无法灵活编程的元素。主要的固定功能机器的最后一个例子是2006年推出的Nintendo的Wii。另一方面，可编程GPU使得可以确切确定在整个生产流程的各个子阶段中应用了哪些操作。对于本书的第四版，我们假设所有开发都是使用可编程GPU完成的。

### 进一步阅读和资源

​		布林的著作《A Trip Down the Graphics Pipeline 》 [165]是一本关于从头开始编写软件渲染器的旧书。它是学习实现渲染管线的一些精妙之处，解释关键算法（例如裁剪和透视插值）的好资源。古老的（至今仍经常更新）《 OpenGL编程指南》（又称“红皮书”）[885]提供了图形管道的完整描述以及与其使用相关的算法。本书的网站realtimerendering.com提供了指向各种管线图，渲染引擎实现等的链接。















## 3.GPU

​		从历史上看，图形加速始于与三角形重叠的每个像素扫描线上的颜色插值，然后显示这些值。包括访问图像数据的能力，它可以将纹理应用于表面。添加用于插值和和内置在可见性检查时的z深度测试的硬件。由于它们经常频繁使用，因此将此类处理过程由于专用硬件提供以提高性能。在后续几代中添加了渲染管线的更多部分，以及给予每个部分的更多功能。专用图形硬件相对于CPU的唯一计算优势是速度，但速度至关重要

​		在过去的二十年中，图形硬件经历了不可思议的转变。 1999年交付的第一款包含硬件顶点处理的消费类图形芯片（NVIDIA的GeForce256）。NVIDIA创造了图形处理单元（GPU）一词，以将GeForce 256与以前仅可光栅化的芯片区分开来，并且从那时延续至今。在接下来的几年中，GPU从复杂的可配置固定功能管线发展到高度可编程的状态，开发人员可以在其中实现自己的算法。各种可编程着色器是控制使用GPU的主要方法。为了提高效率，流水线的某些部分仍然是可配置的，而不是可编程的，但是趋势是朝着可编程性和灵活性的方向发展[175]。

​		GPU通过专注于一组高度可并行化的任务以获得高速。他们拥有专用于实现z缓冲区，快速访问纹理图像和其他缓冲区以及查找被三角形覆盖的像素的定制芯片。这些元素如何执行其功能将在第23章中介绍。现在优先需要知道的是GPU如何实现其可编程着色器的并行性。

​		3.3节介绍了着色器的功能。目前，您需要知道的是着色器核心是一个可以执行一些相对隔离的任务的小型处理器，例如将顶点从其在世界坐标上的位置转换为屏幕坐标，或者计算被一个被三角形覆盖的像素的颜色。每帧会有成千上万个三角形发送到屏幕，每秒可能有数十亿次着色器调用，运行着色器程序的地方被称之为单独实例。

​		首先，延迟是所有处理器都面临的问题。访问数据需要花费一些时间。考虑延迟的一种基本方法是，信息离处理器越远，等待时间就越长。第23.3节会详细介绍延迟。访问存储在内存中的信息将比访问本地寄存器中的信息花费更长的时间。 18.4.1节将更深入地讨论内存访问。关键是等待数据检索时意味着处理器处于停滞状态，这将h会降低性能。

### 3.1并行数据架构

​		不同的处理器架构使用不同的策略来避免停滞。CPU针对处理各种数据结构和大型代码库进行了优化。 CPU可以具有多个处理器，但是每个处理器通常都以串行方式运行代码，有限的SIMD矢量处理是个例外。为了最大程度地减少延迟带来的影响，CPU中的许多芯片都由快速本地缓存组成，这些内存中填充了接下来可能需要使用的数据。 CPU还通过使用诸如分支预测，指令重新排序，寄存器重命名和缓存预取之类的巧妙技术来避免停滞。[715]

​		GPU则采用不同的方法避免停滞。 GPU的大部分芯片区域由大量的称之为着色器核心的处理器组成，数量通常多达数千个。 GPU是流处理器，它依次处理相似数据的有序集合。由于这种相似性（例如，一组顶点或像素），GPU可以大规模并行地处理这些数据。另一个重要的因素是这些调用尽可能地独立，因此它们不需要来自相邻调用的信息，并且不共享可写的本地存储。但有时会破坏该规则以允许新的有用功能，但是此类异常的代价是潜在的延迟，因为一个处理器可能会等待直到另一个处理器完成其工作。
​		GPU针对吞吐量进行了优化，吞吐量定义为可以处理数据的最大速率。但是这种快速处理是具有成本的。由于专用于高速缓存和控制逻辑的芯片面积较小，因此每个着色器内核的等待时间通常比CPU处理器遇到的等待时间长得多[462]。

​		假设网格已光栅化，并且两千个像素具有要处理的片段；像素着色器程序将被调用2000次。想象那儿只有一个着色器处理器，使用世界上最差的GPU。它开始为2000片段中的第一个片段执行着色器程序。着色器处理器对寄存器中的值执行一些算术运算。寄存器是本地的，可以快速访问，因此不会发生停顿。然后，着色器处理器会执行一条指令，例如访问纹理；例如，对于给定的表面坐标，程序需要知道应用于这点的网格的图像的像素颜色。纹理是一个完全独立的资源，而不是像素程序本地存储的一部分，并且纹理访问可能会涉及到一定程度。内存提取可能需要数百到数千个时钟周期，在此期间GPU处理器不执行任何操作。此时，着色器处理器将停止运行，等待纹理的颜色值返回

​		为了使这个糟糕的GPU变得更好，为每个片段提供一些存储空间在本地寄存器上。现在，允许着色器处理器切换并处理另一个片段，即两千个片段中的第二个片段，而不是停止纹理获取。此切换速度非常快，除了需要注意第一片段正在执行哪条指令之外，第一个片段和第二个片段中的内容均不受影响。现在执行第二个片段。与第一个相同，执行一些算术函数，然后再次遇到获取纹理。着色器核心现在切换到另一个片段，即第三个片段。最终，所有两千个片段都以这种方式处理。此时，着色器处理器将返回片段编号1。此时，纹理颜色已被获取并且可以使用，因此着色器程序可以继续执行。处理器以相同的方式进行处理，直到遇到另一个已知会暂停执行的指令，或者程序完成。与着色器处理器始终专注于一个片段相比，执行单个片段所需的时间更长，但是整个片段的总体执行时间将大大减少。

​		在这种架构中，通过切换到另一个片段使GPU保持忙碌来隐藏延迟。 GPU通过将逻辑指令的执行与数据分离开来，使该设计更进一步。这种设计称为单指令多数据（SIMD），这种设计可以在固定数量的着色器程序上以锁定步骤的方式保证执行同一命令。 SIMD的优点是，与使用单独的逻辑和调度单元去运行每个程序相比，用于处理数据和交换的硅（和电量）要少得多。将我们的2000个片段示例转换成现代的GPU术语，每个片段的像素着色器调用都称为线程。这种类型的线程与CPU线程不同。它由作为着色器的输入值的一点内存以及任何着色器执行所需的寄存器空间组成。使用相同着色器程序的线程被分为一组，被NVIDIA称为warp，被AMD称为wavefronts。warp/wavefont被8到64之间的任意数量的GPU着色器内核计划去执行SIMD处理。每个线程都被映射到SIMD通道。

​		假设我们有两千个线程要执行。 NVIDIA GPU的warp包含32个线程。这将产生2000/32 = 62.5个warp，这意味着分配了63个warp，其中一个warp一半为空。warp的执行类似于我们的单个GPU处理器示例。着色器程序在所有32个处理器上以锁定步骤的方式执行。遇到对内存进行提取时，所有线程都会同时遇到它，因为所有线程执行相同的指令。提取操作导致warp中的线程将停止，所有线程都在等待它们的（不同的）结果。为了取代停顿，而将warp换成另一个由32个线程的组成的warp，然后由32个内核继续执行。这种交换的速度与我们的单处理器系统一样快，因为在将warp换入或换出时，每个线程内的数据都不会被触及。每个线程都有自己的寄存器，每个warp都跟踪其正在执行的指令。交换新warp只是将一组核心指向另一组要执行的线程即可。没有其他开销。warp执行或换出，直到全部完成。参见图3.1。

​		在我们的简单示例中，从内存获取纹理的等待时间可能导致swap交换，因为交换成本非常低，所以在真实的情况下将wrap换出将产生较短的延迟。还有其他几种用于优化执行的技术[945]，但warp交换是所有GPU使用的主要延迟隐藏机制。此过程的效率涉及多个因素。例如，如果线程很少，那么只会创建很少的warp，从而使延迟隐藏成为问题。

​		着色器程序的结构是影响效率的重要因素。一个主要因素是每个线程使用的寄存器数量。在我们的示例中，我们假设一次可以将2000个线程全部驻留在GPU上。与每个线程相关联的着色器程序所需的寄存器越多，则线程越少，因此wrap也就越少，进而驻留在GPU中的warp也越少。wrap的不足意味着无法通过交换来减轻停滞。处于驻留状态的warp被称为“in flight”，这个数字称为占用率。高占用率意味着有许多可用于处理的warp，因此出现空闲处理器的可能性较小。低占用率通常会导致性能不佳。从内存提取的频率也影响多少延迟需要隐藏。 Lauritzen [993]概述了着色器使用的寄存器数量和共享内存如何影响占用率。 Wronski [1911，1914]讨论了理想的占用率如何根据着色器执行的操作类型而变化。

​		影响整体效率的另一个因素是由“ if”语句和循环引起的动态分支。假设在着色器程序中遇到“ if”语句。如果所有线程求值并采用同一分支，则warp可以继续进行而不必担心其他分支。但是，如果某些线程甚至一个线程采用了替代路径，那么warp必须执行两个分支，然后丢弃每个线程不需要的结果[530，945]。这个问题称为线程发散，其中一些线程可能需要执行循环迭代或执行“ if”路径，而warp中的其他线程则不这样做，从而使它们在此期间处于空闲状态。

​		所有GPU都实现了这些架构思想，从而导致系统具有严格的限制，但每瓦的计算能力却很大。了解该系统的运行方式将有助于您作为程序员充分利用其提供的功能。在以下各节中，我们讨论GPU如何实现渲染管线，可编程着色器如何运行以及每个GPU阶段的演变和功能。

![1569425237916](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1569425237916.png)

​		<font size=2>图3.1。简化的着色器执行示例。三角形的片段（称为线程）被集合成warp。每个warp显示为四个线程，但实际上有32个线程。要执行的着色器程序长五个指令。四个GPU着色器处理器的集合处理第一个warp时执行这些指令，直到在“ txr”命令上检测到停顿条件为止，这需要时间来获取其数据。交换第二个wrap，并对其应用着色器程序的前三个指令，直到再次检测到停顿为止。交换第三个wrap并使其停止后，通过交换第一个wrap并继续执行，继续执行。如果此时尚未返回其“ txr”命令的数据，则执行将真正停止，直到这些数据可用为止。每个wrap依次完成</font>

![1569425269701](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1569425269701.png)

​		<font size=2>图3.2。渲染管线的GPU实现。这些阶段根据用户对其操作的控制程度进行颜色编码。绿色阶段是完全可编程的。虚线表示可选阶段。黄色阶段是可配置的，但不是可编程的，例如，可以为合并阶段设置各种混合模式。蓝色阶段的功能完全固定。</font>

### 3.2GPU管线概述

​		GPU实现了第2章中描述的几何处理，光栅化和像素处理管线这些阶段。这些阶段又可以分为具有不同程度的的几个硬件子阶段。图3.2根据各个子阶段的可编程性或可配置性显示不同的颜色和框线。请注意，这些划分出的物理阶段与第二章中介绍的4个功能阶段不同。

​		这里描述GPU的逻辑模型，它是通过API展示给程序员。正如第18和23章所讨论的那样，此逻辑管线（物理模型）的实现取决于硬件供应商。为了在GPU上执行此逻辑模型中固定功能的阶段，可以通过将命令添加到固定功能阶段相邻的可编程阶段。管线中的单个程序可以通过相互独立的子单元划分为多个元素来执行，也可以由完整的方式执行。此逻辑模型可以帮助您推断出哪些因素会影响性能，但不要弄错GPU实际实现的管线。

​		顶点着色器是用于实现几何处理阶段的一个完全可编程的子阶段。几何着色器是一个完全可编程的阶段，负责一个图元的顶点（点，线或三角形）的处理。它可用于执行每个图元的着色操作，销毁图元或创建新的图元。曲面细分阶段和几何着色器都是可选的，并非所有GPU都支持它们，尤其是在移动设备上。

​		裁剪，三角形设置和三角形遍历阶段由硬件实现的固定功能。屏幕映射受窗口和视口设置的影响，在内部形成简单的比例尺并重新定位。像素着色器阶段是完全可编程的。尽管合并阶段不是可编程的，但是它是高度可配置的，并可以设置执行多种操作。它实现了“合并”阶段的功能，负责修改颜色，z缓冲区，混合，模板和任何其他与输出相关的缓冲区。像素着色器的执行与合并阶段一起构成了第2章中介绍的像素处理阶段。

​		随着时间的流逝，GPU管线已从硬编码操作演变为增加灵活性和控制能力。可编程着色器阶段的引入是这一发展过程中最重要的一步。下一节描述了各个可编程阶段的通用特征

### 3.3可编程着色器阶段

​		现代着色器程序使用统一的着色器设计标准。这意味着与顶点，像素，几何和曲面细分相关联的着色器共享一个公共的编程模型。在各自的着色器内部，它们具有相同的指令集结构（ISA）。实现此模型的处理器在DirectX中称为“通用着色器核心”，具有此类核心的GPU称为具有统一的着色器结构。这种结构背后的想法是，着色器处理器可以在各种角色中使用，GPU可以根据需要分配它们。例如，与由两个三角形组成的大正方形相比，一组带有小三角形的网格将需要更多的顶点着色器处理。GPU使用单独的顶点着色器核心池和像素着色器核心池意味着理想工作状态下的使所有核心保持忙碌的分配规则是预先严格定义好的。而使用统一的着色器核心，GPU可以决定如何平衡此负载。

​		描述整个着色器编程模型已经超出了本书的范围，并且已经有许多文档，书籍和网站。着色器使用类C的着色语言进行编程，例如DirectX的高级着色语言（HLSL）和OpenGL着色语言（GLSL）。 DirectX的HLSL可以编译为虚拟机字节码，也称为中间语言（IL或DXIL），以提供硬件独立性。中间表示还可以允许着色器程序被编译和离线存储。驱动程序将此中间语言转换为特定GPU的ISA。控制台编程通常避免中间语言步骤，因为那时系统只有一个ISA。

​		基本数据类型是32位单精度浮点标量和向量，尽管向量只是着色器代码的一部分，并且如上所述在硬件中不受支持。在现代GPU上还支持32位整形和64位浮点数。浮点向量通常包含位置（xyzw），法线，矩阵行，颜色（rgba）或纹理坐标（uvwq）等数据。整形最常用于表示计数器，索引或位掩码。还支持聚合数据类型，例如结构，数组和矩阵。

​		一个draw call调用图形API来绘制一组图元，从而使图形管线执行并运行其着色器。每个可编程着色器阶段都有两种类型的输入：统一输入（uniform inputs），其值在整个draw call期间保持不变（但可以在多个draw call之间进行更改），以及变化的输入（varying inputs），即来自三角形顶点或光栅化的数据。例如，像素着色器可以将光源的颜色作为一个uniform值。并且三角形表面的位置每像素都会变化，因此是个varying值。纹理是一种特殊的uniform inputs，它总是应用于表面的色彩图像，但现在可以认为是任何大型数据的数组。

​		底层虚拟机为不同类型的输入和输出提供特殊的寄存器。用于uniform的可用常数寄存器的数量比用于varying的输入或输出的可用寄存器的数量大得多。发生这种情况是因为需要为每个以varying 值输入或者输出的顶点或像素分配额外的存储，因此对于需要多少个输入存在限制。uniform inputs只存储一次，并且在draw call时所有顶点或像素数据会被重复使用。虚拟机还具有用于暂存空间的通用临时寄存器。可以在临时寄存器中用整形值以数组方式对所有类型的寄存器进行索引。着色器虚拟机的输入和输出如图3.3所示。

![1569425303277](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1569425303277.png)

​		<font size=2>图3.3。 Shader Model 4.0下的统一虚拟机结构和寄存器布局。每个资源旁边都会显示最大可用数量。用斜杠分隔的三个数字表示顶点，几何和像素着色器的限制（从左到右）。</font>

​		图形计算中常见的操作可在现代GPU上高效执行。着色语言通过*和+等运算符实现了这些运算中最常见的运算（例如加法和乘法）。其余的通过内置函数实现，例如atan（），sqrt（），log（）以及许多针对GPU优化的其他函数。也存在执行更复杂的操作的函数，例如矢量归一化和反射，叉积，矩阵转置和行列式计算。

​		术语流控制是指使用分支指令来更改代码执行流。与流控制相关的指令用于实现高级语言构造，例如“ if”和“ case”语句，以及各种类型的循环。着色器支持两种类型的流控制。静态流控制分支基于uniform inputs的输入值。这意味着代码流在draw call期间中是恒定的。静态流控制的主要好处是允许将相同的着色器用于各种不同的情况（例如，不同数量的灯光）。由于所有调用都采用相同的代码路径，因此没有线程差异。动态流控制基于uniform inputs的输入值，这意味着每个片段可以执行不同的代码。这比静态流控制强大得多，但会降低性能，尤其是在着色器调用之间发生代码流的不规则变化。

### 3.4可编程着色器和API的演变

​		可编程着色框架的构想可以追溯到1984年，当时库克（Cook）的阴影树[287]。一个简单的着色器及其相应的着色树如图3.4所示。 RenderMan着色语言[63，1804]是在1980年代后期从这个想法发展而来的。如今，它与其他不断发展的规范（例如开放着色语言（OSL）项目[608]）一起用于电影制作渲染。

​		消费级图形硬件是3dfx Interactive于1996年10月1日首次成功引入的。有关今年的时间表，请参见图3.5。他们的Voodoo图形卡能够以高品质和性能渲染《 Quake》游戏，因此很快就被采用。该硬件实现了全部由固定功能的组成的管线。在GPU支持可编程着色器之前，曾多次尝试通过多次渲染来实现可编程着色操作。 Quake III：Arena脚本语言是1999年在该领域的首个成功广泛商业化。如本章开头所述，NVIDIA的GeForce256是第一个被称为GPU的硬件，尽管它是不可编程的，但是它是可配置的。

![1569425341790](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1569425341790.png)

​		<font size=2>图3.4。一个简单的铜着色器的着色树及其相应的着色器语言程序。 （在库克[287]之后。）</font>

![1569425360463](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1569425360463.png)

​		<font size=2>图3.5。一些API和图形硬件版本的时间表。</font>

​		在2001年初，NVIDIA的GeForce 3是第一个支持可编程顶点着色器[1049]的GPU，该着色器通过DirectX 8.0和OpenGL扩展公开。这些着色器以一种类似于汇编的语言进行编程，该语言被驱动程序即时转换为微代码。像素着色器也包含在DirectX 8.0中，但是像素着色器没有达到实际的可编程性-驱动程序将受支持的有限“程序”转换为纹理混合状态，然后将其连接到硬件“寄存器组合器”。这些“程序”是不仅限于长度（不超过12条指令），而且缺少重要的功能。 Peercy等人确定了相关的纹理读取和浮点数据。 [1363]对于真正的可编程性至关重要，来自他们对RenderMan的研究。

​		着色器此时不允许进行流控制（分支），因此必须通过计算两个项以及在结果之间进行选择或差值来模拟条件。 DirectX定义了着色器模型（Shader Model，SM）的概念，以区分具有不同着色器功能的硬件。 2002年，包括Shader Model 2.0在内的DirectX 9.0发行了，该版本具有真正可编程的顶点和像素着色器。在OpenGL下，使用各种扩展也出现了类似的功能。添加了对任意依赖的纹理读取的支持以及16位浮点值的存储，最终完成了Peercy等人确定的一组要求。诸如指令，纹理和寄存器之类的着色器资源的限制增加了，因此着色器变得能够实现更复杂的效果。还增加了对流量控制的支持。着色器的长度和复杂性不断增长，使得汇编编程模型变得越来越麻烦。幸运的是，DirectX 9.0还包含HLSL。这种着色语言是由Microsoft与NVIDIA合作开发的。大约在同一时间，OpenGL ARB（架构审查委员会）发布了GLSL，一种与OpenGL非常相似的语言[885]。这些语言在很大程度上受到C编程语言的语法和设计理念的影响，其中还包括来自RenderMan着色语言的元素。

​		Shader Model 3.0于2004年推出，并添加了动态流控制，使着色器功能更加强大。它还将可选功能转变为需求，进一步增加了资源限制，并增加了对顶点着色器中纹理读取的有限支持。当在2005年末（微软的Xbox 360）和2006年末（索尼计算机娱乐公司的PLAYSTATION 3系统）推出新一代游戏机时，它们配备了Shader Model 3.0级GPU。任天堂的Wii控制台是最后一批著名的固定管线的GPU之一，该GPU最初于2006年末交付。纯固定管线在这一点上早已一去不复返了。着色器语言已经发展到可以使用各种工具来创建和管理它们的地步。图3.6显示了使用库克（Cook）的阴影树概念的一种此类工具的屏幕截图。

​		可编程性的下一个重大步骤也是在2006年底左右。DirectX 10.0 [175]中包含的Shader Model 4.0引入了几个主要功能，例如几何着色器和流输出。 Shader Model 4.0包括适用于所有着色器（顶点，像素和几何图形）的统一编程模型，这是先前描述的统一着色器设计。资源限制进一步增加，并且增加了对整形数据类型（包括按位运算）的支持。 OpenGL 3.3中GLSL 3.30的引入提供了类似的着色器模型。

![1569425383020](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1569425383020.png)

​		<font size=2>图3.6。用于着色器设计的可视着色器图形系统。各种操作封装在功能框中，可在左侧选择。选中后，每个功能框都有可调参数，如右图所示。每个功能框的输入和输出相互链接以形成最终结果，如中间框架的右下方所示。 （摘自“心理磨坊”，mental images inc。）</font>

​		2009年发布了DirectX 11和Shader Model 5.0，添加了细分阶段着色器和计算着色器，也称为DirectCompute。该版本还专注于更有效地支持CPU多处理，这是第18.5节中讨论的主题。 OpenGL在4.0版中添加了曲面细分着色器，在4.3版中添加了计算着色器。 DirectX和OpenGL的发展不同。两者都设置了特定版本发行所需的一定级别的硬件支持。 Microsoft控制DirectX API，因此直接与独立硬件供应商（IHV）（例如AMD，NVIDIA和Intel）以及游戏开发商和计算机辅助设计软件公司合作，以确定要发布的功能。 OpenGL由非营利组织Khronos Group管理的硬件和软件供应商联盟开发。由于涉及的公司数量众多，API功能通常在DirectX中引入之后的一段时间内OpenGL就会出现。但是，OpenGL允许扩展不论是特定供应商的或更广泛的受众提供的，这些最新的GPU扩展功能在官方发行版正式支持之前使用。

​		API的下一个重大变化是由AMD在2013年推出了MantleAPI。Mantle与视频游戏开发商DICE合作开发的，其目的是消除大部分图形驱动程序的开销，并将此控制直接交给开发人员。除了这种重构之外，还进一步支持有效的CPU多处理器。这类新的API专注于大大减少CPU在驱动程序中花费的时间，以及更有效的CPU多处理器支持（第18章）。在Mantle中开创的创意被Microsoft采纳，并在2015年以DirectX 12的形式发布。请注意，DirectX 12并不专注于公开新的GPU功能-DirectX 11.3公开了相同的硬件功能。这两个API均可用于将图形发送到虚拟现实系统，例如Oculus Rift和HTC Vive。但是，DirectX 12是对API的彻底重新设计，可以更好地映射到现代GPU架构。低开销的驱动程序对于以下应用程序很有用：CPU驱动程序成本引起瓶颈，或者使用更多CPU处理器进行图形处理可能会提高性能[946]。从较早的API移植可能很困难，并且天真的实现可能会导致性能降低[249、699、1438]。

​		苹果在2014年发布了自己的低开销API（称为Metal）。Metal首次在iPhone 5S和iPad Air等移动设备上可用，一年后，可通过OS X El Capitan访问较新的Macing。除效率外，减少CPU使用率还可以节省功耗，这是移动设备上的重要因素。该API具有自己的着色语言，适用于图形和GPU计算程序。

​		AMD将其Mantle工作捐赠给了Khronos Group，后者于2016年初发布了自己的新API，名为Vulkan。与OpenGL一样，Vulkan可在多种操作系统上工作。 Vulkan使用一种称为SPIR-V的新高级中间语言，该语言可用于着色器表示和通用GPU计算。预编译的着色器是可移植的，因此可以在任何GPU支持的所需功能上使用[885]。 Vulkan也可以用于非图形GPU计算，因为它不需要显示窗口[946]。 Vulkan与其他低开销驱动程序的显着区别是，它旨在与多种系统一起使用，从工作站到移动设备。

​		在移动设备上，规范是使用OpenGL ES。 “ ES”代表嵌入式系统，因为该API是为移动设备而开发的。当时的标准OpenGL在其某些调用结构中相当庞大且缓慢，并且需要支持很少使用的功能。 OpenGL ES 1.0于2003年发布，是OpenGL 1.3的简化版本，是固定管线。虽然DirectX的发布与支持它们的图形硬件的发布是同步的，但是开发针对移动设备的图形支持的方式却并不相同。例如，2010年发布的第一台iPad实施了OpenGL ES 1.1。 OpenGL ES 2.0规范于2007年发布，提供了可编程着色。它基于OpenGL 2.0，但没有固定功能组件，因此与OpenGL ES 1.1不向后兼容。 OpenGL ES 3.0于2012年发布，提供了多个渲染目标，纹理压缩，变换反馈，实例化，更广泛的纹理格式和模型以及着色器语言改进等功能。 OpenGL ES 3.1添加了计算着色器，而3.2添加了几何和曲面细分着色器，以及其他功能。第23章将更详细地讨论移动设备架构。

​		OpenGL ES的一个分支是基于浏览器的API WebGL，可通过JavaScript调用。该API的第一版于2011年发布，可在大多数移动设备上使用，因为它的功能等效于OpenGL ES 2.0。与OpenGL一样，扩展允许访问更高级的GPU功能。 WebGL 2假定支持OpenGL ES 3.0。

​		WebGL特别适合在教室中试用功能或使用：

* 它是跨平台的，可在所有个人计算机和几乎所有移动设备上使用。
* 驱动程序批准由浏览器处理。即使一个浏览器不支持特定的GPU或扩展，通常另一个浏览器也支持。
* 代码被解释而不是编译，并且仅需要文本编辑器即可进行开发。
* 大多数浏览器都内置了调试器，可以检查在任何网站上运行的代码。
* 可以通过将程序上传到网站或Github来进行部署。

​		更高级别的场景图形和效果库（例如three.js [218]）使您可以轻松访问代码，以获取各种更复杂的效果，例如阴影算法，后处理效果，基于物理的着色和延迟渲染。

### 3.5顶点着色器

​		顶点着色器是图3.2所示功能管线中的第一阶段。虽然这是直接在程序员控制下的第一阶段，但值得注意的是，一些数据操作在此阶段之前发生。在DirectX所谓的输入汇编器[175、530、1208]中，可以将几个数据流编织在一起，以形成沿管道发送的一组顶点和图元。例如，一个对象可以由一个位置阵列和一个颜色阵列表示。输入汇编器将通过创建具有位置和颜色的顶点来创建此对象的三角形（或直线或点）。第二个对象可以使用相同的位置数组（以及不同的模型转换矩阵）和不同的颜色数组表示。数据表示将在16.4.5节中详细讨论。输入汇编器中也支持执行实例化。这允许一个对象被绘制多次，每个实例具有一些不同的数据，所有这些都可以通过一个绘制调用进行。第18.4.2节介绍了实例化的使用。

​		三角形网格由一组顶点表示，每个顶点与模型表面上的特定位置相关联。除了位置之外，每个顶点还有其他可选属性，例如颜色或纹理坐标。曲面法线也定义在网格顶点上，这似乎是一个奇怪的选择。从数学上讲，每个三角形都有一个定义明确的表面法线，直接将三角形的法线用于阴影似乎更有意义。但是，渲染时，通常使用三角形网格来表示基础曲面，而使用顶点法线来表示该表面的方向，而不是三角形网格本身的方向。 16.3.4节将讨论计算顶点法线的方法。图3.7显示了两个三角形网格的侧视图，这些三角形网格代表曲面，一个是平滑的，另一个是带有锐利折痕的三角形。

​		顶点着色器是处理三角形网格的第一阶段。顶点着色器无法获得描述形成三角形的数据。顾名思义，它专门处理传入的顶点。顶点着色器提供了一种修改，创建或忽略与每个三角形的顶点关联的值的方法，例如其颜色，法线，纹理坐标和位置。通常，顶点着色器程序会将顶点从模型空间转换为同构剪辑空间（第4.7节）。顶点着色器至少必须始终输出此位置。

![1569425413580](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1569425413580.png)

​		<font size=2>图3.7。三角形曲面（黑色，具有顶点法线）的侧视图，代表曲面（红色）。在左侧，平滑的顶点法线用于表示平滑表面。在右侧，中间顶点已被复制并指定了两个法线，表示折痕。</font>

​		顶点着色器与前面描述的统一着色器几乎相同。传入的每个顶点都由顶点着色器程序处理，该程序然后输出在三角形或直线上内插的多个值。顶点着色器既不能创建也不能破坏顶点，并且一个顶点生成的结果不能传递到另一个顶点。由于每个顶点都是独立处理的，因此可以将GPU上任意数量的着色器处理器并行应用于传入的顶点流。

​		输入汇编通常表示为在执行顶点着色器之前发生的过程。这是一个物理模型通常与逻辑模型不同的示例。从物理上讲，获取数据以创建顶点的操作可能发生在顶点着色器中，并且驱动程序将悄悄地为每个着色器添加适当的指令，这些指令对于程序员是不可见的。

​		接下来的章节介绍了几种顶点着色器效果，例如用于动画关节的顶点混合和轮廓渲染。顶点着色器的其他用途包括：

  * 对象生成，通过仅创建一次网格并使其由顶点着色器变形即可。

  * 使用蒙皮和变形技术对角色的身体和面部进行动画处理。

  * 程序变形，例如旗帜，布料或水的移动[802，943]。

  * 通过发送退化的（无区域）网格沿管道生成粒子，并根据需要为其分配区域。

  * 通过将整个帧缓冲区的内容用作经过屏幕变形的屏幕对齐网格上的纹理，可以使镜头变形，热雾，水波纹，页面卷曲和其他效果。

  * 通过使用顶点纹理获取[40，1227]应用地形高度场。 


​		使用顶点着色器完成的一些变形如图3.8所示。

​		顶点着色器的输出可以通过几种不同的方式使用。然后为每个实例的图元（例如三角形）生成常用路径，并对其进行栅格化，生成的各个像素片段将发送到像素着色器程序以进行继续处理。在某些GPU上，数据也可以发送到细分阶段或几何着色器，或存储在内存中。这些可选
以下各节将讨论这些阶段。

![1569425434435](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1569425434435.png)

​		<font size=2>图3.8。左边是一个普通的茶壶。由顶点着色器程序执行的简单剪切操作将生成中间图像。在右侧，噪声函数会创建一个使模型失真的字段。 （图像由FX Composer 2制作，由NVIDIA Corporation提供。）</font>

### 3.6曲面细分阶段

​		细分阶段允许我们渲染曲面。 GPU的任务是获取每个表面描述，并将其变成一组代表性的三角形。此阶段是可选的GPU功能，该功能首先在DirectX 11中可用（并且是DirectX 11所必需的）。OpenGL4.0和OpenGL ES 3.2也支持该功能。

​		使用细分阶段有几个优点。曲面描述通常比提供相应的三角形本身更紧凑。除了节省内存外，此功能还可以防止CPU和GPU之间的总线成为其形状在改变每一帧的动画角色或对象的瓶颈。通过为给定视图生成适当数量的三角形，可以有效地渲染表面。例如，如果一个球远离相机，则仅需要几个三角形。近距离观察时，最好用数千个三角形来表示。这种控制细节水平的能力还可以使应用程序控制其性能，例如，在较弱的GPU上使用较低质量的网格以保持帧速率。通常用平坦表面表示的模型可以转换为三角形的细网格，然后根据需要进行变形[1493]，或者可以对其进行细分，以便更不频繁地执行昂贵的阴影计算[225]。

​		细分阶段始终由三个元素组成。使用DirectX的术语，它们是船体着色器，细分和域着色器。在OpenGL中，外壳着色器是曲面细分控制着色器，而域着色器是曲面细分评估着色器，虽然较为冗长，但更具描述性。固定功能细分器在OpenGL中称为原始生成器，并且可以看到，确实是它的功能。

​		在第17章中详细讨论了如何指定和细分曲面和曲线。在此，我们简要概述了每个细分阶段的目的。首先，外壳着色器的输入是一个特殊的补丁原语。它由几个控制点组成，这些控制点定义了细分曲面，贝泽尔面片或其他类型的弯曲元素。外壳着色器具有两个功能。首先，它告诉镶嵌器应生成多少个三角形以及采用哪种配置。其次，它对每个控制点执行处理。同样，可选地，外壳着色器可以修改传入的补丁说明，根据需要添加或删除控制点。船体着色器将其控制点集以及细分控制数据输出到域着色器。参见图3.9。

![1569425459428](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1569425459428.png)

​		<font size=2>图3.9。细分阶段。外壳着色器采用由控制点定义的补丁。它将细分因子（TF）和类型发送给固定功能细分器。控制点集由外壳着色器根据需要进行转换，并与TF和相关的修补程序常量一起发送到域着色器。镶嵌对象将创建一组顶点及其重心坐标。然后由域着色器对其进行处理，从而生成三角形网格（显示控制点以供参考）。</font>

​		镶嵌细分是管线中的固定功能阶段，仅与镶嵌细分着色器一起使用。它的任务是为域着色器添加多个新顶点以进行处理。船体着色器向镶嵌器发送有关所需镶嵌曲面类型的信息：三角形，四边形或等值线。等值线是线带的集合，有时用于毛发渲染[1954]。船体着色器发送的其他重要值是细分因子（OpenGL中的细分级别）。它们有两种类型：内边缘和外边缘。这两个内部因素决定了三角形或四边形内部发生了多少细分。外部因素决定每个外部边缘被分割多少（第17.6节）。图3.10显示了增加镶嵌因子的示例。通过允许使用单独的控件，我们可以使相邻曲面的边缘在镶嵌中匹配，而无论内部如何镶嵌。匹配的边缘可避免在补丁相遇之处出现裂缝或其他阴影瑕疵。为顶点分配了重心坐标（第22.8节），这些值指定了所需表面上每个点的相对位置。

​		船体着色器始终输出补丁，一组控制点位置。但是，它可以通过向镶嵌器发送零或更低（或非数字，NaN）的外部镶嵌水平来发出信号，表示将要丢弃补丁。否则，镶嵌器将生成网格并将其发送到域着色器。域着色器的每次调用都使用来自外壳着色器的曲面的控制点，以计算每个顶点的输出值。域着色器具有类似于顶点着色器的数据流模式，来自镶嵌细分器的每个输入顶点都经过处理并生成相应的输出顶点。然后将形成的三角形沿管道向下传递。

![1569425478635](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1569425478635.png)

​		<font size=2>图3.10。改变镶嵌因子的效果。犹他州茶壶由32个小块组成。从左到右的内部和外部镶嵌因子分别为1、2、4和8（Rideout和Van Gelder [1493]通过演示生成的图像。）</font>

​		尽管此系统听起来很复杂，但为提高效率而采用这种结构，每个着色器可能都非常简单。传递到船体着色器中的修补程序通常很少或根本不做修改。该着色器还可以使用补丁的估计距离或屏幕大小来动态计算镶嵌因子，就像地形渲染一样[466]。或者，外壳着色器可以简单地为应用程序计算和提供的所有修补程序传递一组固定的值。镶嵌器执行一个涉及但固定功能的过程，生成顶点，为其指定位置并指定它们形成的三角形或直线。此数据放大步骤是在着色器外部执行的，以提高计算效率[530]。域着色器采用为每个点生成的重心坐标，并在补丁的评估方程式中使用这些坐标，以生成位置，法线，纹理坐标以及所需的其他顶点信息。有关示例，请参见图3.11。

![1569425494925](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1569425494925.png)

​		<font size=2>图3.11。左侧是大约6000个三角形的基础网格。在右侧，使用PN三角形细分细分每个三角形并进行置换。 （图像由NVIDIA公司提供，来自NVIDIA SDK 11 [1301]的示例，由4A Games提供的Metro 2033型号。）</font>

![1569425512835](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1569425512835.png)

​		<font size=2>图3.12。几何着色器程序的几何着色器输入为某些单一类型：点，线段，三角形。最右边的两个图元包括与直线和三角形对象相邻的顶点。更精细的补丁类型是可能的。</font>

### 3.7几何着色器

​		几何着色器可以将图元转换为其他图元，这是销售阶段无法做到的。例如，可以通过让每个三角形创建线边缘，将三角形网格转换为线框视图。或者，可以将这些线替换为面向观察者的四边形，从而使线框渲染的边缘更粗[1492]。几何着色器是在2006年底随DirectX 10发行版添加到硬件加速的图形管道中的。它位于管道中的细分着色器之后，并且可以选择使用。虽然是Shader Model 4.0的必需部分，但在较早的着色器模型中未使用它。 OpenGL 3.2和OpenGL ES 3.2也支持这种类型的着色器。

​		几何着色器的输入是单个对象及其关联的顶点。对象通常由带状，线段或简单点中的三角形组成。扩展的图元可以由几何着色器定义和处理。特别是，可以传入三角形外部的三个附加顶点，并且可以使用折线上的两个相邻顶点。参见图3.12。使用DirectX 11和Shader Model 5.0，您可以传入多达32个控制点的更精细的补丁程序。也就是说，细分阶段对于补丁生成更有效[175]。

​		几何着色器处理该图元并输出零个或多个顶点，这些顶点被视为点，折线或三角形带。请注意，几何着色器根本无法生成任何输出。通过这种方式，可以通过编辑顶点，添加新图元以及删除其他图元来选择性地修改网格。

​		几何着色器设计用于修改传入的数据或制作有限数量的副本。例如，一种用途是生成六个转换后的数据副本，以同时渲染立方体贴图的六个面；参见第10.4.3节。它也可以用来有效地创建级联的阴影贴图，以生成高质量的阴影。利用几何着色器的其他算法包括从点数据创建尺寸可变的粒子，沿着轮廓拉伸鳍以进行毛发渲染，以及为阴影算法找到对象边缘。有关更多示例，请参见图3.13。这些和其他用途将在本书的其余部分中讨论。

​		DirectX 11增加了几何着色器使用实例化的功能，其中几何着色器可以在任何给定的图元上运行设定的次数[530，1971]。在OpenGL 4.0中，这是通过调用计数指定的。几何着色器最多也可以输出四个流。可以在渲染管道上发送一个流以进行进一步处理。所有这些流都可以选择发送到流输出渲染目标。

![1569425554991](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1569425554991.png)

​		<font size=2>图3.13。几何着色器（GS）的某些用途。在左侧，使用GS快速进行元球等值面细分。在中间，使用GS完成线段的分形细分并将其输出，而GS生成广告牌以显示闪电。在右侧，通过使用流出的顶点和几何着色器执行布料模拟。 （图片来自NVIDIA SDK 10 [1300]示例，由NVIDIA Corporation提供。）</font>

​		保证几何着色器以与输入相同的顺序从图元输出结果。这会影响性能，因为如果多个着色器内核并行运行，则必须保存和排序结果。此因素和其他因素不利于在单个调用中用于复制或创建大量几何图形的几何着色器[175，530]。

​		发出绘制调用后，管线中只有三个位置可以在GPU上创建工作：栅格化，细分阶段和几何体着色器。其中，考虑到所需的资源和内存，几何着色器的行为是最不可预测的，因为它是完全可编程的。实际上，几何着色器通常用很少，因为它无法很好地映射到GPU的优势。在某些移动设备上，它是通过软件实现的，因此在此积极地建议不要使用它[69]。

#### 3.7.1流输出

​		GPU管道的标准用法是通过顶点着色器发送数据，然后栅格化生成的三角形并在像素着色器中进行处理。过去，总是通过管道传递数据，而中间结果无法访问。流输出的想法是在Shader Model 4.0中引入的。在顶点着色器（以及可选的细分和几何着色器）处理了顶点之后，除了可以发送到栅格化阶段之外，还可以将它们输出到流（即有序数组）中。实际上，光栅化可以完全关闭，然后将流水线纯粹用作非图形流处理器。可以将通过这种方式处理的数据通过管道发送回去，从而允许进行迭代处理。如第13.8节所述，这种类型的操作可用于模拟流水或其他粒子效果。它也可以用于为模型蒙皮，然后使这些顶点可重复使用（第4.4节）。

​		流输出仅以浮点数的形式返回数据，因此可能会产生明显的内存开销。流输出在图元上起作用，而不是在顶点上起作用。如果将网格沿管道发送，则每个三角形将生成自己的三个输出顶点集。原始网格中共享的所有顶点都将丢失。因此，更典型的用法是仅通过管道将顶点发送为点集图元。在OpenGL中，流输出阶段称为变换反馈，因为它的大部分使用重点是变换顶点并将其返回以进行进一步处理。保证按输入顺序将基元发送到流输出目标，这意味着将保持顶点顺序[530]。

### 3.8像素着色器

​		顶点，曲面细分和几何体着色器执行完操作后，便会裁剪并设置图元以进行栅格化，如上一章所述。流水线的这一部分在其处理步骤中是相对固定的，即，不是可编程的，而是有些可配置的。遍历每个三角形以确定其覆盖哪些像素。光栅化器还可以粗略计算出三角形覆盖每个像素的像元区域的数量（第5.4.2节）。部分或完全重叠像素的三角形称为片段。

​		三角形顶点的值（包括z缓冲区中使用的z值）将在每个像素的三角形表面上插值。这些值将传递到像素着色器，然后由该着色器处理片段。在OpenGL中，像素着色器称为片段着色器，这也许是一个更好的名称。为了保证一致性，我们在本书中始终使用“像素着色器”。沿管线发送的点和线图元也会为所覆盖的像素创建片段。

​		跨整个三角形执行的插值类型由像素着色器程序指定。通常，我们使用透视校正内插法，以使像素表面位置之间的世界空间距离随着对象后退距离的增加而增加。一个示例是渲染延伸到地平线的铁轨。铁轨在铁轨较远的地方间距更近，因为每个接近地平线的连续像素行进的距离都更大。其他插值选项也可用，例如屏幕空间插值，其中不考虑透视投影。 DirectX 11进一步控制何时以及如何执行插值[530]。

​		用编程术语来说，顶点着色器程序的输出（插在三角形（或线）上）实际上成为像素着色器程序的输入。随着GPU的发展，其他输入也已公开。例如，片段的屏幕位置可用于Shader Model 3.0及更高版本中的像素着色器。同样，三角形的哪一侧可见是输入标志。该知识对于一次通过每个三角形的正面和背面渲染不同的材质非常重要。

![1569425576993](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1569425576993.png)

​		<font size=2>图3.14。用户定义的剪切平面。在左侧，单个水平裁剪平面将对象切片。在中间，嵌套球被三个平面修剪。在右侧，仅当球体的曲面在所有三个剪切平面的外部时，才对其进行剪切。 （来自Three.js示例中的webgl剪切和webgl剪切交集[218]。）</font>

​		有了输入，通常像素着色器会计算并输出片段的颜色。它还可能会产生不透明度值，并可以选择修改其z深度。在合并期间，这些值用于修改存储在像素处的内容。光栅化阶段生成的深度值也可以由像素着色器修改。模板缓冲区值通常是不可修改的，而是传递到合并阶段。 DirectX 11.3允许着色器更改此值。雾计算和Alpha测试等操作已从合并操作转变为成为SM 4.0中的像素着色器计算[175]。

​		像素着色器还具有丢弃传入片段（即不产生任何输出）的独特功能。图3.14显示了如何使用碎片丢弃的一个示例。剪切平面功能以前是固定功能管道中的可配置元素，后来在顶点着色器中指定。有了片段丢弃功能之后，就可以用像素着色器中所需的任何方式来实现此功能，例如确定剪切量应进行“与”运算还是“或”运算。

​		最初，像素着色器只能输出到合并阶段，以进行最终显示。随着时间的推移，像素着色器可以执行的指令数量已大大增加。这种增加引起了多个渲染目标（MRT）的想法。不仅可以将像素着色器程序的结果仅发送到颜色和z缓冲区，还可以为每个片段生成多组值并将其保存到不同的缓冲区，每个缓冲区称为渲染目标。渲染目标通常具有相同的x和y维度；一些API允许使用不同的大小，但是渲染区域将是其中最小的。一些架构要求渲染目标必须具有相同的位深，甚至可能具有相同的数据格式。取决于GPU，可用的渲染目标数量为四个或八个。

​		即使有这些限制，MRT功能还是更有效地执行渲染算法的有力辅助。一次渲染过程可以在一个目标中生成彩色图像，在另一个目标中生成对象标识符，在第三个目标中生成世界空间距离。此功能还引起了另一种类型的渲染管道，称为延迟着色，其中可见性和着色是在单独的通道中完成的。第一遍存储有关每个像素处对象位置和材质的数据。然后，连续通过可以有效地施加照明和其他效果。此类渲染方法在第20.1节中进行了描述。

​		像素着色器的局限性在于，它通常只能在传递给目标的片段位置上写入渲染目标，而不能从相邻像素读取当前结果。也就是说，执行像素着色器程序时，它无法将其输出直接发送到相邻像素，也无法访问其他人的最新更改。而是，它计算仅影响其自身像素的结果。但是，此限制并不像听起来那样严重。一次通过创建的输出图像可以让像素着色器在后续通过中访问其任何数据。可以使用第12.1节中所述的图像处理技术来处理相邻像素。

​		像素着色器无法了解或影响相邻像素的结果的规则是有例外的。一种是像素着色器可以在计算梯度或导数信息时立即访问相邻片段的信息（尽管是间接的）。像素着色器具有沿x和y屏幕轴每个像素的任何插值变化的量。这些值可用于各种计算和纹理寻址。这些梯度对于诸如纹理过滤（第6.2.2节）之类的操作尤为重要，因为我们想知道多少图像覆盖了一个像素。所有现代GPU都通过以2×2为一组处理片段（称为四边形）来实现此功能。当像素着色器请求梯度值时，将返回相邻片段之间的差异。参见图3.15。统一核心具有访问相邻数据（保留在同一扭曲中的不同线程中）的功能，因此可以计算用于像素着色器的渐变。此实现的一个结果是，无法在受动态流控制影响的着色器的某些部分（例如，“ if”语句或具有可变迭代次数的循环）中访问渐变信息。一组中的所有片段都必须使用相同的指令集进行处理，以便所有四个像素的结果对于计算梯度都是有意义的。这是一个基本限制，即使在脱机渲染系统中也存在[64]。

​		DirectX 11引入了一种缓冲区类型，该类型允许对任何位置（无序访问视图（UAV））的写访问。最初仅适用于像素和计算着色器，对UAV的访问已扩展到DirectX 11.1中的所有着色器[146]。 OpenGL 4.3将此称为着色器存储缓冲区对象（SSBO）。这两个名称以其自己的方式进行描述。像素着色器以任意顺序并行运行，并且此存储缓冲区在它们之间共享。

​		通常需要某种机制来避免数据竞争情况（也称为数据危险），在这种情况下，两个着色器程序都在“竞相”以影响相同的值，从而可能导致任意结果。例如，如果两次调用像素着色器试图在大约同一时间将其添加到相同的检索值中，则可能会发生错误。两者都将检索原始值，都将在本地对其进行修改，但是，无论哪个调用最后写入其结果，都将抹去另一个调用的作用，只会发生一次添加。 GPU通过使用着色器可以访问的专用原子单元来避免此问题[530]。但是，原子意味着某些着色器可能在等待访问另一个着色器进行读/修改/写操作的存储位置时停滞。

![1569425601443](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1569425601443.png)

​		<font size=2>图3.15。在左侧，将三角形栅格化为四边形，每组2×2像素。然后，在右侧显示了带有黑点标记的像素的梯度计算。针对四边形中四个像素位置的每一个，显示了v的值。请注意，三角形中没有覆盖三个像素，但是GPU仍对其进行处理，以便可以找到渐变。通过使用左下像素的两个四边形邻居，可以计算出x和y屏幕方向上的渐变。</font>

​		尽管原子避免了数据危害，但许多算法都需要特定的执行顺序。例如，您可能需要绘制一个更远的透明蓝色三角形，然后再用红色透明三角形覆盖它，将红色混合在蓝色上面。一个像素可能对一个像素进行两次像素着色器调用，每个三角形调用一次，以这样一种方式执行：红色三角形的着色器先于蓝色着色器完成。在标准管道中，片段结果将在合并阶段进行排序，然后再进行处理。在DirectX 11.3中引入了栅格化程序顺序视图（ROV）以强制执行顺序。这些就像无人机。着色器可以以相同的方式读取和写入它们。关键区别在于ROV保证以正确的顺序访问数据。这大大增加了这些着色器可访问缓冲区的有用性[327、328]。例如，ROV使像素着色器可以编写自己的混合方法，因为它可以直接访问和写入ROV中的任何位置，因此不需要合并阶段[176]。代价是，如果检测到乱序访问，像素着色器调用可能会停顿，直到处理了先前绘制的三角形。

### 3.9合并阶段

​		如第2.5.2节所述，合并阶段是将各个片段（在像素着色器中生成）的深度和颜色与帧缓冲区组合在一起。 DirectX将此阶段称为输出合并； OpenGL将其称为每个样本的操作。在大多数传统管线图（包括我们自己的管线图）上，此阶段是模具缓冲区和z缓冲区操作发生的地方。如果片段可见，则此阶段中发生的另一种操作是颜色混合。对于不透明的表面，不涉及真正的混合，因为片段的颜色会简单地替换以前存储的颜色。片段和所存储颜色的实际混合通常用于透明度和合成操作（第5.5节）。

​		想象一下，通过光栅化生成的片段通过像素着色器运行，然后在应用z缓冲区时被某些先前渲染的片段隐藏。这样就不需要在像素着色器中进行所有处理。为了避免这种浪费，许多GPU在执行像素着色器之前执行一些合并测试[530]。片段的z深度（以及其他正在使用的东西，例如模板缓冲区或剪刀）用于测试可见性。如果隐藏该片段，则将其剔除。此功能称为Early-z [1220，1542]。像素着色器具有更改片段的z深度或完全丢弃片段的能力。如果发现像素着色器程序中存在这两种类型的操作，则通常无法使用Early-Z，然后通常将其关闭，这通常会使管线效率降低。 DirectX 11和OpenGL 4.2允许像素着色器强制进行Early-Z测试，尽管有很多限制[530]。有关早期z和其他z缓冲区优化的更多信息，请参见第23.7节。有效使用Early-z会对性能产生很大影响，这将在18.4.5节中详细讨论。

​		合并阶段占据了固定功能阶段（例如三角形设置）和完全可编程着色器阶段之间的中间地带。尽管它不是可编程的，但它的操作是高度可配置的。可以将颜色混合设置为执行大量不同的操作。最常见的是涉及颜色和Alpha值的乘法，加法和减法的组合，但是其他操作（例如最小值和最大值）以及按位逻辑运算也是可能的。 DirectX 10添加了将像素着色器中的两种颜色与帧缓冲区颜色混合的功能。此功能称为双源颜色混合，不能与多个渲染目标一起使用。 MRT否则支持混合，DirectX 10.1引入了在每个单独的缓冲区上执行不同混合操作的功能。

​		如上一节末尾所述，DirectX 11.3提供了一种通过ROV进行混合编程的方法，尽管这是以性能为代价的。 ROV和合并阶段都保证了绘制顺序，也就是输出不变性。不管生成像素着色器结果的顺序如何，API要求都按照输入结果的顺序（对象，对象和三角形，以及三角形）对结果进行排序并将其发送到合并阶段。

### 3.10计算着色器

​		除了实现传统的图形管线外，GPU还可以用于更多用途。在计算领域，有许多非图形用途，例如计算股票期权的估计价值和训练用于深度学习的神经网络。以这种方式使用硬件称为GPU计算。诸如CUDA和OpenCL之类的平台可作为大型并行处理器来控制GPU，而无需真正的需求或访问特定于图形的功能。这些框架通常使用带有扩展功能的C或C ++等语言以及为GPU制作的库。

​		DirectX 11中引入了计算着色器，它是GPU计算的一种形式，因为它是未锁定在图形管线中某个位置的着色器。它与渲染过程紧密相关，因为它由图形API调用。它与顶点，像素和其他着色器一起使用。它使用与管道中使用的统一着色器处理器池相同的池。与其他着色器一样，它是着色器，因为它具有一组输入数据，并且可以访问缓冲区（例如纹理）以进行输入和输出。扭曲和线程在计算着色器中更明显。例如，每个调用都会获取一个可以访问的线程索引。还有一个线程组的概念，它由DirectX 11中的1到1024个线程组成。这些线程组由x，y和z坐标指定，主要是为了简化在着色器代码中的使用。每个线程组都有少量的内存，这些内存在线程之间共享。在DirectX 11中，这等于32 kB。计算着色器由线程组执行，因此保证该组中的所有线程可以同时运行[1971]。

​		计算着色器的一个重要优点是它们可以访问在GPU上生成的数据。从GPU向CPU发送数据会产生延迟，因此如果可以将处理和结果保留在GPU上，则可以提高性能[1403]。在后期处理中，以某种方式修改了渲染的图像，这是计算着色器的常见用法。共享内存意味着来自采样图像像素的中间结果可以与相邻线程共享。例如，已经发现使用计算着色器确定图像的分布或平均亮度的运行速度是在像素着色器上执行此操作的两倍[530]。

​		计算着色器还可用于粒子系统，网格处理（例如面部动画[134]，剔除[1883、1884]，图像过滤[1102、1710]，提高深度精度[991]，阴影[865]，景深[ 764]，以及可以承担一组GPU处理器的任何其他任务。 Wihlidal [1884]讨论了计算着色器如何比曲面细分船体着色器更有效。其他用途请参见图3.16。

​		至此，我们对GPU的渲染管线实现的审查结束了。有多种方法可以使用和组合GPU功能来执行各种与渲染相关的过程。调整以利用这些功能的相关理论和算法是本书的重点。现在，我们将重点放在变换和着色上。

![1569425627411](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1569425627411.png)

​		<font size=2>图3.16。计算着色器示例。左侧是计算着色器，用于模拟受风影响的头发，并使用细分阶段渲染头发本身。在中间，计算着色器执行快速模糊操作。在右侧，模拟了海浪。 （图像来自NVIDIA SDK 11 [1301]示例，由NVIDIA Corporation提供。）</font>

### 进一步阅读和资源

​		吉森（Giesen）的图形管道之旅[530]详细讨论了GPU的许多方面，并解释了元素为何以它们的方式工作。 Fatahalian和Bryant的课程[462]在一系列详细的讲义幻灯片集中讨论了GPU并行性。尽管着眼于使用CUDA进行GPU计算，但Kirk和Hwa的书[903]的介绍部分讨论了GPU的发展和设计理念。

​		要学习着色器编程的形式方面，需要花费一些工作。诸如OpenGL Superbible [1606]和OpenGL Programming Guide [885]之类的书都包含有关着色器编程的材料。旧书OpenGL Shading Language [1512]没有涵盖较新的着色器阶段，例如几何和细分着色器，但确实专注于与着色器相关的算法。有关最新和推荐的图书，请参见本书的网站realtimerendering.com。





​		



​			

​							

​    

​    

​    

## 4.变换

​		变换是一种操作，它接受点，向量或颜色等实体，并以某种方式对其进行转换。对于计算机图形从业者来说，掌握转换极为重要。使用它们，您可以定位，重塑形状和设置对象，灯光和照相机的动画。您还可以确保所有计算都在同一坐标系中进行，并将对象以不同的方式投影到平面上。这些只是可以通过转换执行的操作中的少数操作，但是它们足以说明转换角色在实时图形或任何形式的计算机图形中的重要性。

​		线性变换是保留矢量加法和标量乘法的变换。特别，

​		
$$
f(x)+f(y)=f(x+y)\qquad\qquad\qquad\quad(4.1)\\
kf(x)=f(kx)\qquad\qquad\qquad\qquad\qquad(4.2)
$$
​		例如，f（x）= 5x是一个采用向量并将每个元素乘以5的变换。为了证明这是线性的，需要满足两个条件（公式4.1和4.2）。第一个条件成立，因为任何两个向量乘以五然后相加将与将向量相加然后相乘相同。标量乘法条件（方程式4.2）已明确满足。此功能称为缩放变换，因为它可以更改对象的缩放比例（大小）。旋转变换是另一个使向量围绕原点旋转的线性变换。比例变换和旋转变换，实际上是三元素矢量的所有线性变换，都可以使用3×3矩阵表示。

​		但是，矩阵的大小通常不够大。三元素向量x的函数（例如f（x）= x +（7，3，2））不是线性的。在两个单独的向量上执行此功能将把（7，3，2）的每个值相加两次以形成结果。将固定向量添加到另一个向量会执行翻译，例如，它将所有位置移动相同的数量。这是一种有用的变换类型，我们想结合各种变换，例如，将对象缩放到一半大小，然后将其移动到其他位置。到目前为止，将函数保持在简单的形式上很难使它们轻松组合。

​		可以使用仿射变换将线性变换和平移结合起来，通常以4×4矩阵形式存储。仿射变换是先执行线性变换然后执行平移的变换。为了表示四元素向量，我们使用同质记法，以相同的方式表示点和方向（使用粗体小写字母）。方向向量表示为v =（vx vy vz 0）T，点表示为v =（vx vy vz 1）T。在本章中，我们将广泛使用在realtimerendering.com上可下载的线性代数附录中解释的术语和运算。

​		所有平移，旋转，缩放，反射和剪切矩阵都是仿射的。仿射矩阵的主要特征是它保留了线的平行性，但不一定保留长度和角度。仿射变换也可以是各个仿射变换的串联的任何序列。

​		本章将从最基本的基本仿射变换开始。本部分可以看作是简单转换的“参考手册”。然后描述了更专业的矩阵，随后对四元数（一种强大的转换工具）进行了讨论和描述。然后是顶点融合和变形，这是表达网格动画的两种简单但有效的方法。最后，描述了投影矩阵。这些转换中的大多数，它们的符号，功能和特性总结在表4.1中，其中正交矩阵是其逆矩阵为转置矩阵。

​		变换是用于操纵几何的基本工具。大多数图形应用程序编程接口允许用户设置任意矩阵，有时库可能与实现本章讨论的许多转换的矩阵运算一起使用。但是，仍然有必要了解函数调用背后的实际矩阵及其相互作用。知道这样的函数调用之后矩阵的功能是一个开始，但是了解矩阵本身的属性将使您更进一步。例如，这种理解使您可以辨别何时处理正交矩阵（正交是其转置），从而可以更快地进行矩阵求逆。这样的知识可以导致代码加速。

​		



### 4.1基础变换

​		本节介绍最基本的变换，例如平移，旋转，缩放，剪切，变换级联，刚体变换，法线变换（不是正常的）和逆计算。对于有经验的读者，可以将其用作简单转换的参考手册，对于新手，则可以作为本主题的入门。本材料是本章其余部分和本书其他各章的必要背景。我们从最简单的转换开始-翻译。

| 符号 | 名字 | 行为 |
| :--: | :--: | :--: |
|  我  |      |      |
|  我  |      |      |
|  我  |      |      |
|      |      |      |
|      |      |      |
|      |      |      |
|      |      |      |
|      |      |      |
|      |      |      |

​		<font size=2>表4.1。本章讨论的大多数转换的摘要。</font>

#### 4.1.1变换

​		从一个位置到另一个位置的变化由转换矩阵T表示。此矩阵通过向量t =（tx，ty，tz）转换实体。 T由下面的公式4.3给出：
$$
\textbf{T}(\textbf{t})=
\textbf{T}(t_x,t_y,t_z)=
\begin{gather*}
\begin{pmatrix}
1 & 0& 0 & t_x \\
0 & 1& 0 & t_y \\
0 & 0& 1 & t_z \\ 
0 & 0& 0 & 1
\end{pmatrix}
\end{gather*}
\qquad \qquad (4.3)
$$
​		图4.1显示了转换转换效果的示例。容易证明，将点p =（px，py，pz，1）与T（t）相乘会产生一个新的点p'=（px + tx，py + ty，pz + tz，1），很显然是平移。 Noticethata向量v =（vx，vy，vz，0）不受T乘法的影响，因为方向向量无法转换。相反，其余的仿射变换都会影响点和向量。平移矩阵的逆是T-1（t）= T（-t），即向量t取反。

​		<font size=2>图4.1。左侧的正方形通过平移矩阵T（5，2，0）进行变换，从而使正方形向右移动5个距离单位，向上移动2个距离单位。</font>

​		在这一点上，我们应该提到的是，有时在计算机图形学中也可以看到的另一种有效的符号方案是使用矩阵，其底行带有平移矢量。例如，DirectX使用这种形式。在该方案中，矩阵的顺序将被颠倒，即，应用的顺序将从左到右读取。因为矢量是行，所以用这种表示法表示的矢量和矩阵都是行主形式。在本书中，我们使用列主形式。无论使用哪种方式，这纯粹是一种符号上的差异。当矩阵存储在内存中时，十六进制的最后四个值是三个转换值，后跟一个。

#### 4.1.2旋转

​		旋转变换将矢量（位置或方向）绕经过原点的给定轴旋转给定角度。像平移矩阵一样，它是一个刚体变换，即它保留了变换后的点之间的距离，并保留了惯用性（即它从不导致左右两侧互换）。在计算机图形学中，这两种类型的转换对于定位和定向对象非常有用。方位矩阵是与摄像机视图或对象相关联的旋转矩阵，它定义了其在空间中的方位，即其向上和向前的方向。

​		在二维中，旋转矩阵很容易得出。假设我们有一个向量v =（vx，vy），我们将其参数化为v =（vx，vy）=（rcosθ，rsinθ）。如果我们将矢量旋转φ弧度（逆时针），则将得到u =（r cos（θ+φ），r sin（θ+φ））。这可以重写为

​		
$$
\begin{gather*}
\textbf{u}=
\begin{pmatrix}
r \quad cos(\theta+\phi) \\
r \quad sin(\theta+\phi) \\
\end{pmatrix}=
\begin{pmatrix}
r (cos\theta\cos\phi-sin\theta\sin\phi) \\
r (sin\theta\cos\phi+cos\theta\sin\phi) \\
\end{pmatrix}\\
=
\underbrace {
\begin{pmatrix}
cos\theta\qquad-sin\phi \\
sin\theta\qquad cos\phi
\end{pmatrix}}_{\textbf{R}(\phi)}
\underbrace {
\begin{pmatrix}
rcos\theta\\
rsin\theta
\end{pmatrix}}_{\textbf{v}}
=\textbf{R}(\phi)\textbf{v}
\end{gather*}
\qquad\qquad(4.4)
$$
​		这里我们使用角度和关系来展开cos（θ+φ）和sin（θ+φ）。在三个维度上，常用的旋转矩阵是Rx（φ），Ry（φ）和Rz（φ），它们分别绕x，y和z轴旋转实体φ弧度。它们由公式4.5–4.7给出：

​		
$$
\textbf{R}_{x}(\phi)=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
1 & 0& 0 & 0\\
0& cos\phi&-\sin\phi& 0 \\
0 &sin\phi&\cos\phi& 0 \\ 
0 & 0& 0 & 1
\end{matrix}
\end{pmatrix}
\end{gather*}
\qquad \qquad (4.5)
$$

$$
\textbf{R}_{y}(\phi)=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
cos\phi & 0& sin\phi & 0\\
0& 1&0& 0 \\
-sin\phi &0&\cos\phi& 0 \\ 
0 & 0& 0 & 1
\end{matrix}
\end{pmatrix}
\end{gather*}
\qquad \qquad (4.6)
$$

$$
\textbf{R}_{z}(\phi)=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
cos\phi&sin\phi&0 & 0\\
sin\phi&\cos\phi&0& 0 \\
0 & 0&1&0 \\ 
0 & 0& 0 & 1
\end{matrix}
\end{pmatrix}
\end{gather*}
\qquad \qquad (4.7)
$$

​		如果从4×4矩阵中删除最底行和最右列，则将获得3×3矩阵。对于绕任意轴旋转φ弧度的每3×3旋转矩阵R，迹线（矩阵中对角元素的总和）与轴无关，是恒定的，计算公式为[997]：

​		
$$
tr(\textbf{R})=1+2cos\phi\qquad\qquad(4.8)
$$
​		旋转矩阵的效果可以在第65页的图4.4中看到。表征旋转矩阵Ri（φ）的原因除了它绕着轴i旋转φ弧度外，还在于旋转中的所有点。轴，i，不变。注意，R也将用于表示围绕任何轴的旋转矩阵。上面给出的轴旋转矩阵可以在一系列三个变换中使用，以执行任意轴旋转。该过程在第4.2.1节中讨论。第4.2.4节介绍了直接绕任意轴旋转。

​		所有旋转矩阵的行列式均为1，并且是正交的。这对于任何数量的这些转换的串联也成立。还有另一种求逆的方法：R-1（φ）= Ri（-φ），即绕同一轴线沿相反方向旋转。

​		示例：绕点旋转。假设我们要围绕z轴旋转φ弧度的对象，并且旋转中心为某个点p。什么是转换？图4.2中描述了这种情况。由于绕点旋转的特征在于该点本身不受旋转的影响，因此变换首先通过平移对象使p与原点重合开始，这是通过T（-p）完成的。此后跟随实际旋转：Rz（φ）。最后，必须使用T（p）将对象平移回其原始位置。然后，得到的变换X由下式给出

​		
$$
\textbf{X}=\textbf{T}(\textbf{p})\textbf{R}_{z}(\phi)\textbf{T}(-\textbf{p})
\qquad\qquad(4.9)
$$
​		注意上面矩阵的顺序。

​		<font size=2>图4.2。围绕特定点p旋转的示例。</font>

#### 4.1.3尺度变换

​		缩放矩阵S（s）= S（sx，sy，sz）分别沿x，y和z方向缩放因子为sx，sy和sz的实体。这意味着可以使用缩放矩阵来放大或缩小对象。 si（i∈{x，y，z}）越大，则缩放实体在该方向上越大。将s的任何分量设置为1自然可以避免该方向缩放的更改。公式4.10显示S：

​		
$$
\textbf{S}(s)=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
S_{x}&0&0 & 0\\
0&S_{y}&0& 0 \\
0 & 0&S_{z}&0 \\ 
0 & 0& 0 & 1
\end{matrix}
\end{pmatrix}
\end{gather*}
\qquad \qquad (4.10)
$$
​		<font size=2>第65页上的图4.4说明了缩放矩阵的作用。如果sx = sy = sz，则缩放操作称为均匀操作，否则称为非均匀操作。有时，使用等向性和各向异性缩放来代替均匀和非均匀性。倒数是S-1（s）= S（1 / sx，1 / sy，1 / sz）。</font>

​		使用齐次坐标，创建统一缩放矩阵的另一种有效方法是通过操作位置（3,3）处的矩阵元素，即右下角的元素。该值会影响齐次坐标的w分量，因此会缩放矩阵转换后的点（而非方向矢量）的每个坐标。例如，要均匀地缩放5倍，可以将缩放矩阵中（0，0），（1、1）和（2，2）的元素设置为5，或将（3， 3）可以设置为1/5。执行此操作的两种不同矩阵如下所示：

​		
$$
\textbf{S}(s)=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
5&0&0 & 0\\
0&5&0& 0 \\
0 & 0&5&0 \\ 
0 & 0& 0 & 1
\end{matrix}
\end{pmatrix},
\qquad\qquad
\textbf{S}^{'}=
\begin{pmatrix}
\begin{matrix}
1&0&0 & 0\\
0&1&0& 0 \\
0 & 0&1&0 \\ 
0 & 0& 0 & 1/5
\end{matrix}
\end{pmatrix}.
\end{gather*}
\qquad \qquad (4.11)
$$
​		与使用S进行均匀缩放相反，必须始终在使用S'之后进行均质化。这可能是低效的，因为它涉及均质化过程中的分歧。如果右下角的元素（位置（3，3））为1，则不需要除法。当然，如果系统总是在不进行1测试的情况下进行该划分，则不会产生任何额外费用。

​		s的一个或三个分量上的负值给出一种反射矩阵，也称为镜像矩阵。如果只有两个比例因子为-1，那么我们将旋转π弧度。应当注意，与反射矩阵连接的旋转矩阵也是反射矩阵。因此，以下是反射矩阵：

​		
$$
\begin{gather*}
\underbrace {
\begin{pmatrix}
cos(\pi/2)&sin(\pi/2) \\
-sin(\pi/2)&cos(\pi/2) \\
\end{pmatrix}}_{旋转}
\underbrace {
\begin{pmatrix}
1&0\\0&1
\end{pmatrix}}_{反射}=
\begin{pmatrix}
0&-1\\-1&0
\end{pmatrix}.
\end{gather*}
\qquad\qquad(4.12)
$$
​		反射矩阵通常在检测到时需要特殊处理。例如，当顶点由反射矩阵转换时，其顶点具有逆时针顺序的三角形将获得顺时针顺序。此顺序更改可能导致不正确的照明和背面剔除。要检测给定矩阵是否以某种方式反射，请计算矩阵左上3×3个元素的行列式。如果该值为负，则矩阵是反射性的。例如，公式4.12中矩阵的行列式为0·0 −（-1）·（-1）= -1。

​		示例：沿特定方向缩放。缩放矩阵S仅沿x轴，y轴和z轴缩放。如果应在其他方向执行缩放，则需要复合转换。假设缩放应沿着正交，右向向量fx，fy和fz的轴进行。首先，构造矩阵F，以更改基础，如下所示：

​		
$$
\textbf{F}=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
\textbf{f}^x&\textbf{f}^y&\textbf{f}^z& 0\\
0 & 0& 0 & 1
\end{matrix}
\end{pmatrix}
\end{gather*}
\qquad \qquad (4.13)
$$
​		想法是使三个轴给定的坐标系与标准轴重合，然后使用标准缩放矩阵，然后变换回去。第一步是通过乘以F的转置即它的逆来进行的。然后完成实际的缩放，然后再变换回去。转换如公式4.14所示：

​		
$$
\textbf{X}=
\textbf{FS}(\textbf{s})
\textbf{F}^{T}.
\qquad \qquad (4.13)
$$

#### 4.1.4 剪切

​		另一类转换是剪切矩阵集。例如，这些可以用于游戏中以扭曲整个场景，以产生迷幻效果或扭曲模型的外观。有六个基本剪切矩阵，分别表示为Hxy（s），Hxz（s），Hyx（s），Hyz（s），Hzx（s）和Hzy（s）。第一个下标用于表示剪切矩阵正在更改哪个坐标，而第二个下标表示进行剪切的坐标。剪切矩阵Hxz（s）的示例如公式4.15所示。注意，下标可用于在下面的矩阵中找到参数s的位置； x（其数字索引为0）标识第零行，而z（其数字索引为2）标识第二列，因此s位于此处：

​		
$$
\textbf{H}_{xz}(s)=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
1&0&s & 0\\
0&1&0& 0 \\
0 & 0&1&0 \\ 
0 & 0& 0 & 1
\end{matrix}
\end{pmatrix}.
\qquad\qquad(4.15)
\end{gather*}
$$
​		<font size=2>图4.3。用Hxz剪切单位平方的效果。 y值和z值都不受转换的影响，而x值是旧x值和s乘以z值的总和，从而导致平方倾斜。这种变换是保留区域的，这可以通过虚线区域相同来看出。</font>

​		将该矩阵与点p相乘会产生一个点：（px + spz pypz）。图4.3中以单位平方的形式显示了这一点。 Hij的倒数（相对于第j个坐标剪切第i个坐标，其中i̸= j）是通过沿相反方向剪切而生成的，即，H-1（s）= Hij（-s）。

​		
$$
\textbf{H}^{'}_{xz}(s,t)=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
1 & 0 & s & 0\\
0 & 1 & t & 0 \\
0 & 0 & 1 & 0 \\ 
0 & 0 & 0 & 1
\end{matrix}
\end{pmatrix}.
\qquad\qquad(4.16)
\end{gather*}
$$
​		但是，在此，两个下标均用于表示这些坐标将被第三坐标剪切。这两种不同类型的描述之间的联系是H'ij（s，t）= Hik（s）Hjk（t），其中k用作第三坐标的索引。正确使用的基质取决于口味。最后，应该注意的是，由于任何剪切矩阵的行列式| H | = 1，这是一个保留体积的转换，如图4.3所示。

​		<font size=2>图4.4。这说明了矩阵相乘时的顺序依赖性。在第一行中，应用旋转矩阵Rz（π/ 6），然后缩放S（s），其中s =（2，0.5，1）。这样，合成矩阵为S（s）Rz（π/ 6）。在底行中，以相反的顺序应用矩阵，得出Rz（π/ 6）S（s）。结果明显不同。对于任意矩阵M和N，一般认为MN ＝ NM。</font>

####4.1.5连接变换

​		由于矩阵上乘法运算的不可交换性，因此矩阵出现的顺序很重要。因此，变换的级联被认为是顺序相关的。

​		作为顺序依赖性的示例，请考虑两个矩阵S和R。S（2，0.5，1）将x分量缩放为两倍，将y分量缩放为0.5。 Rz（π/ 6）绕z轴逆时针旋转π/ 6弧度（在右手坐标系中从本书的页面向外指向）。这些矩阵可以用两种方法相加，结果完全不同。这两种情况如图4.4所示。

​		将一系列矩阵连接为单个矩阵的明显原因是为了提高效率。例如，假设您的游戏场景具有数百万个顶点，并且场景中的所有对象都必须缩放，旋转并最终平移。现在，不是将所有顶点与这三个矩阵中的每一个相乘，而是将这三个矩阵连接到一个矩阵中。然后将此单个矩阵应用于顶点。该复合矩阵为C = TRS。注意这里的顺序。比例矩阵S应该首先应用于顶点，因此在合成中显示在右侧。该排序意味着TRSp =（T（R（Sp））），其中p是要转换的点。顺便说一句，TRS是场景图系统常用的顺序。

​		值得注意的是，虽然矩阵级联是依赖于顺序的，但是矩阵可以根据需要进行分组。例如，假设您要使用TRSp计算一次刚体运动变换TR。将这两个矩阵（TR）（Sp）分组在一起并用中间结果替换是有效的。因此，矩阵级联是关联的。

#### 4.1.6刚体变换

​		当一个人抓住一个坚固的物体时，例如从桌子上用笔将其移动到另一个位置，也许移动到衬衫的口袋里，只有物体的方向和位置会发生变化，而物体的形状通常不会受到影响。这种仅由平移和旋转的串联组成的变换称为刚体变换。它具有保留长度，角度和惯用性的特性。

​		可以将任何刚体矩阵X表示为平移矩阵T（t）和旋转矩阵R的串联。因此，X在公式4.17中具有矩阵的外观：

​		
$$
\textbf{X}=\textbf{T}(\textbf{t)}\textbf{R}=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
r_{00} & r_{01} & r_{02} & t_{x}\\
r_{10} & r_{11} & r_{12} & t_{y} \\
r_{20} & r_{21} & r_{22} & t_{z} \\ 
0 & 0 & 0 & 1
\end{matrix}
\end{pmatrix}.
\qquad\qquad(4.17)
\end{gather*}
$$
​		X的倒数计算为X-1 =（T（t）R）-1 = R-1T（t）-1 = RT T（-t）。因此，为了计算逆，对R的左上3×3矩阵进行转置，并且T的转换值改变符号。将这两个新矩阵以相反的顺序相乘以获得逆。计算X的逆的另一种方法是考虑R（使R出现为3×3矩阵）和X的符号如下（符号在第6页的公式1.2中描述）：

​		
$$
\mathbf{\bar{R}}=(\textbf{r}_{,0}\quad\textbf{r}_{,1}\quad\textbf{r}_{,2})=
\begin{pmatrix}
\begin{matrix}
\textbf{r}^{T}_{0,}\\
\textbf{r}^{T}_{1,}\\
\textbf{r}^{T}_{2,}\\
\end{matrix}
\end{pmatrix},
\\
\textbf{X}=
\begin{pmatrix}
\begin{matrix}
\overset{\Longrightarrow}{\mathbf{\bar{R}}}&\textbf{t}\\
\mathbf{0}^{T}&\textbf{1}\\
\end{matrix}
\end{pmatrix}.
\qquad \qquad(4.18)
$$
​		其中r，0表示旋转矩阵的第一列（即逗号表示从0到2的任何值，而第二个下标为0），而rT0是该列矩阵的第一行。请注意，0是填充有零的3×1列向量。一些计算得出公式4.19中所示表达式的反函数：

​		
$$
\textbf{X}^{-1}=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
\textbf{r}_{0,} & \textbf{r}_{1,} & \textbf{r}_{2,} & -\mathbf{\bar{R}}^{T}t\\
0 & 0 & 0 & 1
\end{matrix}
\end{pmatrix}.
\qquad\qquad(4.19)
\end{gather*}
$$
​		<font size=2>图4.5。涉及计算转换的几何形状，该转换将相机定位在c处，矢量为u'向上，以查看点l。为此，我们需要计算r，u和v。</font>

​		示例：调整相机的方向。图形中的常见任务是调整相机的方向，使其对准特定位置。在这里，我们将介绍gluLookAt（）（来自OpenGL Utility Library，简称GLU）的作用。即使现在很少使用此函数调用，该任务仍然很常见。假设摄像机位于c处，我们希望摄像机看着目标l，并且摄像机的给定方向为u'，如图4.5所示。我们要计算一个由三个向量{r，u，v}组成的基数。我们从计算视点向量为v =（c − l）/ ||| c − l ||开始，即从目标到摄像机位置的归一化向量。然后可以将向右看的向量计算为r =-（v×u'）/ || v×u'||。通常不能保证u'向量指向正上方，因此最终的向上向量是另一个叉积u = v×r，由于v和r都通过构造进行了标准化和垂直处理，因此可以保证对其进行归一化。在我们将构建的相机变换矩阵M中，其思想是首先转换所有内容，使相机位置位于原点（0，0，0），然后更改基数，以使r与（1 ，0，0），u（0、1、0）和v（0、0、1）。这是通过

​		
$$
\begin{gather*}
\textbf{M}=
\underbrace {
\begin{pmatrix}
\begin{matrix}
r_{x} & r_{y} & r_{z} & 0\\
u_{x} & u_{y} & u_{z} & 0 \\
v_{x} & v_{y} & v_{z} & 0 \\ 
0 & 0 & 0 & 1
\end{matrix}
\end{pmatrix}}_{基础变换}
\underbrace {
\begin{pmatrix}
\begin{matrix}
1 & 0 & 0 & -t_{x}\\
0 & 1 & 0 & -t_{y} \\
0 & 0 & 1 & -t_{z} \\ 
0 & 0 & 0 & 1
\end{matrix}
\end{pmatrix}}_{变换}=
\begin{pmatrix}
\begin{matrix}
r_{x} & r_{y} & r_{z} & -\mathbf{t\cdot r} \\
u_{x} & u_{y} & u_{z} & -\mathbf{t\cdot u} \\
v_{x} & v_{y} & v_{z} & -\mathbf{t\cdot v} \\ 
0 & 0 & 0 & 1
\end{matrix}
\end{pmatrix}
\end{gather*}
\qquad\qquad(4.20)
$$
​		注意，当将转换矩阵与基本矩阵的变化连接在一起时，转换-t在右边，因为应该首先应用它。记住将r，u和v的分量放在哪里的一种方法如下。我们希望r变成（1，0，0），所以当将基础矩阵的变化乘以（1，0，0）时，我们可以看到矩阵的第一行必须是r的元素，因为r· r =1。此外，第二行和第三行必须由与r垂直的向量组成，即r·x =0。当对u和v应用相同的思维时，我们得出基矩阵的变化以上。

​		<font size=2>图4.6。左侧是原始几何图形，三角形以及从侧面显示的法线。中间的插图显示了如果模型沿x轴缩放0.5且法线使用相同的矩阵会发生什么。右图显示了法线的正确变换。</font>

#### 4.1.7法线变换

​		单个矩阵可用于一致地变换点，线，三角形和其他几何形状。相同的矩阵还可以沿这些线或在三角形的曲面上变换切线向量。但是，此矩阵不能始终用于变换一个重要的几何属性，即表面法线（和顶点照明法线）。图4.6显示了如果使用相同的矩阵会发生什么。

​		适当的方法不是使用矩阵本身乘以，而是使用矩阵的伴随项的转置[227]。伴随的计算在我们的在线线性代数附录中进行了描述。伴随关系始终保证存在。规范不保证变换后具有单位长度，因此通常需要将其标准化。

​		转换法线的传统答案是计算逆矩阵的转置[1794]。此方法通常有效。但是，完全逆不是必需的，并且有时无法创建。逆是伴随数除以原始矩阵的行列式。如果该行列式为零，则矩阵是奇异的，并且不存在逆。

​		即使只计算一个完整的4×4矩阵的伴随，也可能很昂贵，并且通常没有必要。由于法线是矢量，因此翻译不会对其产生影响。此外，大多数建模转换都是仿射的。它们不会更改传入的齐次坐标的w分量，即，它们不会执行投影。在这些（常见）情况下，正常变换所需的全部是计算左上3×3分量的伴随。

​		通常甚至不需要这种伴随计算。假设我们知道变换矩阵完全由平移，旋转和均匀缩放操作（无拉伸或压扁）的级联组成。翻译不影响正常。统一的缩放因子仅改变法线的长度。剩下的就是一系列旋转，总是产生某种形式的净旋转，仅此而已。逆的转置可用于变换法线。旋转矩阵是通过其转置为逆来定义的。代替以获得正态变换，两个转置（或两个逆）给出原始旋转矩阵。综上所述，原始变换本身也可以在这些情况下直接用于变换法线。

​		最后，并不总是需要完全正常化生成的法线。如果仅平移和旋转连接在一起，则法线在通过矩阵进行变换时不会更改长度，因此不需要重新归一化。如果还连接了统一的缩放比例，则可以使用整体缩放比例因子（如果已知或提取，请参见第4.2.3节）直接对生成的法线进行规格化。例如，如果我们知道应用了一系列缩放，使对象变大了5.2倍，则直接通过此矩阵转换的法线通过将它们除以5.2来重新归一化。另外，要创建一个将产生归一化结果的法线变换矩阵，原始矩阵的左上3×3可以被该比例因子除一次。

​		请注意，在变换后，表面法线是从三角形导出的系统中（例如，使用三角形边缘的叉积），法线变换不是问题。切向量本质上与法线不同，并且总是由原始矩阵直接转换。

#### 4.1.8逆计算

​		在许多情况下，例如在坐标系之间来回切换时，需要反向。根据有关转换的可用信息，可以使用以下三种计算矩阵逆的方法之一：

  * 如果矩阵是单个变换或具有给定参数的简单变换序列，则可以通过“反转参数”和矩阵顺序轻松地计算矩阵。例如，如果M ＝ T（t）R（φ），则M-1 ＝ R（-φ）T（-t）。这很简单，并且保留了转换的准确性，这在渲染巨大世界时很重要[1381]。

  * 如果已知矩阵是正交的，则M-1 = MT，即转置为逆。旋转的任何顺序都是旋转，因此是正交的。

  * 如果一无所知，则可以使用伴随方法，克莱默法则，LU分解或高斯消去法来计算逆。通常最好使用Cramer规则和伴随方法，因为它们的分支操作较少；在现代体系结构上最好避免使用“如果”测试。请参阅第4.1.7节，了解如何使用伴随来反转变换法线。		

​		优化时也可以考虑逆计算的目的。例如，如果将逆函数用于矢量转换，则通常只需要对矩阵的左上3×3部分取反（请参见上一节）。

### 4.8特殊矩阵变换和运算

​		在本节中，将介绍和导出对实时图形必不可少的几种矩阵变换和运算。首先，我们介绍欧拉变换（及其参数提取），这是描述方向的直观方法。然后，我们谈到从单个矩阵中检索一组基本变换。最终，得出一种绕任意轴旋转实体的方法。

#### 4.2.1欧拉变换

​		这种转换是构造矩阵以将自己（即摄像机）或任何其他实体定向到某个方向的一种直观方法。它的名字来自伟大的瑞士数学家莱昂哈德·欧拉（Leonhard Euler，1707–1783年）。

​		首先，必须建立某种默认的视图方向。如图4.7所示，它通常沿负z轴放置，头部沿y轴放置。欧拉变换是三个矩阵的乘积，即图中所示的旋转。更正式地说，表示为E的变换由公式4.21给出：

​		
$$
\mathbf{E}(h,p,r)=\mathbf{R}_{z}(r)\mathbf{R}_{x}(p)\mathbf{R}_{y}(h)
\qquad\qquad(4.21)
$$
​		矩阵的顺序可以用24种不同的方式选择[1636]；这可以通过选择矩阵的顺序来实现。我们介绍这个是因为它是常用的。由于E是旋转的串联，因此它也显然是正交的。因此，它的逆可以表示为E-1 = ET =（RzRxRy）T = RTy RTx RTz，尽管当然，直接使用E的转置会更容易。

​		欧拉角h，p和r表示头，俯仰和横滚应按其顺序旋转以及绕其各自的轴旋转多少。有时，所有角度都称为“侧倾”，例如，我们的“头”为“ y侧”，我们的“俯仰”为“ x侧”。此外，“头”有时也称为“偏航”，例如如在飞行模拟中。

​		这种转换很直观，因此很容易用外行的语言进行讨论。例如，改变头角度会使观看者摇头“不”，改变音调会使他们点头，而滚动则使他们的头向侧面倾斜。而不是谈论围绕x，y和z轴的旋转，我们谈论的是改变头，俯仰和横滚。请注意，此变换不仅可以定向摄影机，还可以定向任何对象或实体。可以使用世界空间的全局轴或相对于局部参考系执行这些变换。

​		重要的是要注意，一些欧拉角的表示将z轴作为初始向上方向。这种差异纯粹是一种符号上的变化，尽管可能会造成混淆。在计算机图形学中，在如何看待世界以及如何形成内容方面存在分歧：y向上或z向上。大多数制造工艺（包括3D打印）都认为z方向在世界范围内是向上的。航空和海上交通工具认为-z上升。建筑和GIS通常使用z-up，因为建筑平面图或地图是二维的x和y。与媒体相关的建模系统通常将y方向视为世界坐标上的方向，以匹配我们始终在计算机图形学中描述相机的屏幕向上方向的方式。这两个世界矢量选择之间的差异仅相差90°旋转（并且可能是反射），但不知道假定哪个会导致问题。在本卷中，除非另有说明，否则我们使用y向上的世界方向。

​		<font size=2>图4.7。欧拉变换及其与更改头，俯仰和横滚角的方式之间的关系。显示默认视图方向，沿负z轴看，向上方向沿y轴看。</font>

​		我们还想指出，相机在其视野中的向上方向与世界的向上方向没有特别关系。转动头，视野就会倾斜，其世界空间向上方向与世界方向不同。再举一个例子，假设世界使用y-up，而我们的相机则直视下方的地形，鸟瞰。此方向表示相机已向前倾斜90o，因此其在世界空间中的向上方向为（0,0，−1）。在这种方向上，相机没有y分量，而是认为-z在世界空间中向上，但根据定义，“ y在上方”在视图空间中仍然适用。

​		欧拉角虽然对较小的角度变化或观看者方向有用，但还有其他一些严重的限制。很难同时使用两组欧拉角。例如，在一组和另一组之间进行插值并不是对每个角度进行插值的简单问题。实际上，两组不同的欧拉角可以给出相同的方向，因此任何插值都不应旋转对象。这些是使用本章稍后讨论的替代方向表示形式（例如四元数）值得追求的一些原因。使用欧拉角，您还可以获得称为万向节锁定的东西，这将在4.2.2节中介绍。

####4.2.2从欧拉变换中提取参数

​		在某些情况下，使用从正交矩阵中提取Euler参数h，p和r的过程很有用。此过程如公式4.22所示：

​		
$$
\textbf{E}(h,p,r)=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
e_{00} & e_{01} & e_{02} \\
e_{10} & e_{11} & e_{12} \\
e_{20} & e_{21} & e_{22} \\ 
\end{matrix}
\end{pmatrix}=
\mathbf{R}_{z}(r)\mathbf{R}_{x}(p)(h).
\qquad\qquad(4.22)
\end{gather*}
$$
​		在这里，我们放弃了3×3矩阵的4×4矩阵，因为后者提供了旋转矩阵的所有必要信息。也就是说，等效的4×4矩阵的其余部分始终在右下位置包含零和一个1。

​		将方程式4.22中的三个旋转矩阵串联起来

​		
$$
\textbf{E}=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
\cos r\cos h-\sin r\sin p\sin h & -\sin r\cos p & \cos r\sin h+\sin r\sin p\cos h \\
\sin r\cos h+\cos r\sin p\sin h & \cos r\cos p & \sin r\sin h-\cos r\sin p\cos h  \\
-\cos p\sin h&  \sin  p & \cos  p\cos h \\ 
\end{matrix}
\end{pmatrix}.
\qquad\qquad(4.23)
\end{gather*}
$$
​		由此可见，音高参数由sin p = e21给出。同样，将e01除以e11，并类似地将e20除以e22，会产生以下用于头和侧倾参数的提取方程式：

​		
$$
\frac{e_{01}}{e_{11}}=
\frac{-\sin r}{\cos r}=
-\tan r \quad and \quad
\frac{e_{20}}{e_{22}}=
\frac{-\sin h}{\cos h}=
-\tan h 
\qquad\qquad(4.24)
$$
​		因此，如方程式4.25所示，使用函数atan2（y，x）（请参阅第1章第8页）从矩阵E提取欧拉参数h（头），p（俯仰）和r（横滚）：

​		
$$
\begin{align}
h=&\textbf{atan2}(-e_{20},e_{22}),\\
p=&\textbf{arcsin}(-e_{21}),\qquad\qquad(4.25)\\
r=&\textbf{atan2}(-e_{01},e_{11}).
\end{align}
$$
​		但是，有一种特殊情况需要处理。如果cos p = 0，则具有万向节锁定（第4.2.2节），旋转角度r和h将绕同一轴旋转（尽管可能沿不同的方向，这取决于p旋转角度是-π/ 2还是π/ 2），因此仅需要导出一个角度。如果我们任意设置h = 0 [1769]，我们得到

​		
$$
\textbf{E}=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
\cos r & \sin r\cos p & \sin r\sin p \\
\sin p & \cos r\cos p & -\cos r\sin p \\
0 & \sin p & \cos p \\ 
\end{matrix}
\end{pmatrix}.
\qquad\qquad(4.26)
\end{gather*}
$$
​		由于p不影响第一列中的值，因此当cosp = 0时，我们可以使用sin r / cos r = tan r = e10 / e00，得出r = atan2（e10，e00）。

​		请注意，根据arcsin的定义，-π/ 2≤p≤π/ 2，这意味着，如果使用该间隔之外的p值创建E，则无法提取原始参数。 h，p和r不是唯一的，这意味着可以使用一组以上的Euler参数来产生相同的变换。有关欧拉角转换的更多信息，请参见Shoemake的1994年文章[1636]。上面概述的简单方法可能会导致数值不稳定的问题，这在速度方面会付出一定的代价来避免[1362]。

​		当您使用Euler变换时，可能会发生万向节锁定[499，1633]。这发生在旋转时，失去了一个自由度。例如，假设转换顺序为x / y / z。考虑仅绕y轴旋转π/ 2，即第二次旋转。这样做会旋转局部z轴以使其与原始x轴对齐，因此围绕z的最终旋转是多余的。

​		在数学上，我们已经在公式4.26中看到了万向节锁定，其中我们假设cos p = 0，即p =±π/ 2 +2πk，其中k是整数。有了这样的p值，我们损失了一个自由度，因为矩阵仅取决于一个角度r + h或r-h（但不是同时取决于两个角度）。

​		虽然在建模系统中通常以x / y / z顺序表示欧拉角，但绕每个局部轴旋转时，其他顺序也是可行的。例如，动画中使用z / x / y，动画和物理学中都使用z / x / z。所有都是指定三个单独旋转的有效方法。最后的z / x / z顺序在某些应用中可能更好，因为只有当绕x旋转π弧度（半旋转）时，云台才会发生锁定。没有完美的序列可以避免云台锁定。尽管如此，通常还是使用Euler角度，因为动画师更喜欢曲线编辑器来指定角度如何随时间变化[499]。

​		示例：约束变换。想象您拿着一把（虚拟的）扳手紧紧地抓住螺栓。为了将螺栓固定到位，您必须绕x轴旋转扳手。现在假设您的输入设备（鼠标，VR手套，太空球等）为扳手的运动提供了旋转矩阵，即旋转。问题在于，将这种变换应用于扳手，扳手应该仅绕x轴旋转，这可能是错误的。要将输入变换（称为P）限制为绕x轴旋转，只需使用本节中介绍的方法提取欧拉角h，p和r，然后创建一个新矩阵Rx（p） 。然后，这是一种受欢迎的变换，它将使扳手绕x轴旋转（如果P现在包含这样的运动）。

#### 4.2.3矩阵分解

​		到目前为止，我们一直在假设我们知道所使用的转换矩阵的起源和历史的情况下进行工作。通常情况并非如此。

​		例如，仅连接的矩阵可以与某个变换后的对象相关联。从级联矩阵中检索各种变换的任务称为矩阵分解。

​		检索一组转换的原因很多。用途包括：

* 仅提取对象的比例因子。
* 查找特定系统所需的转换。 （例如，某些系统可能不允许使用任意4×4矩阵。
* 确定模型是否仅经历了刚体变换。
* 在动画的关键帧之间进行插值，其中仅用于对象可用
* 从旋转矩阵上移除剪子。

​		我们已经提出了两种分解方法，分别是为刚体变换导出平移和旋转矩阵（第4.1.6节），以及从正交矩阵导出欧拉角（第4.2.2节）。

​		如我们所见，检索转换矩阵很简单，因为我们只需要4×4矩阵的最后一列中的元素。我们还可以通过检查矩阵的行列式是否为负来确定是否发生了反射。要分离出旋转，缩放和剪切，需要花费更多的精力。

​		幸运的是，有几篇关于该主题的文章以及在线提供的代码。托马斯[1769]和戈德曼[552，553]分别针对各种类型的转换提出了一些不同的方法。 Shoemake [1635]改进了其仿射矩阵的技术，因为他的算法与参考系无关，并尝试分解矩阵以获得刚体变换。

#### 4.2.4绕任意轴旋转

​		有时使用使实体绕任意轴旋转某个角度的过程会很方便。假设旋转轴r已归一化，并且应该创建一个使r弧度围绕r旋转的变换。

​		为此，我们首先变换到一个空间，我们要围绕其旋转的轴是x轴。这是通过一个称为M的旋转矩阵完成的。然后执行实际旋转，然后使用M-1变换回[314]。此过程如图4.8所示。

​		为了计算M，我们需要找到两个正交的轴，分别与r和r正交。我们着重于找到第二根轴s，知道第三根轴t将是第一根轴和第二根轴的叉积，t = r×s。一种数字稳定的方法是找到r的最小成分（绝对值），并将其设置为0。交换剩余的两个成分，然后取反它们中的第一个（实际上，两个非零成分都可以被否定）。在数学上，这表示为[784]：

​		
$$ {\}
\begin{align}
\bar s&=
\begin{cases}
(0,-r_{z},r_{y}),\quad if\quad|r_{x}|\le|r_{y}|\quad and \quad|r_{x}|\le|r_{z}|,\\
(0,-r_{z},r_{y}),\quad if\quad|r_{x}|\le|r_{y}|\quad and \quad|r_{x}|\le|r_{z}|,\\
(0,-r_{z},r_{y}),\quad if\quad|r_{x}|\le|r_{y}|\quad and \quad|r_{x}|\le|r_{z}|.
\qquad\qquad(4.27)\\
\end{cases}
\\s&=\bar s/||\bar s||,
\\\mathbf{t}&=\mathbf{r}\times \mathbf{s}.
\end{align}
$$
​		这保证̄s与r正交（垂直），并且（r，s，t）是正交的基础。 Frisvad [496]提出了一种在代码中没有任何分支的方法，该方法速度更快，但准确性较低。马克斯[1147]和达夫（Duff）等。 [388]提高了Frisvad方法的准确性。无论采用哪种技术，都会使用这三个向量来创建旋转矩阵：

​		
$$
\textbf{M}=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
\mathbf{r}^T \\
\mathbf{s}^T \\
\mathbf{t}^T\\ 
\end{matrix}
\end{pmatrix}.
\qquad\qquad(4.28)
\end{gather*}
$$
​		该矩阵将向量r转换为x轴，将s转换为y轴，将t转换为z轴。因此，然后使围绕标准化向量r旋转α弧度的最终变换为

​		
$$
\mathbf{X}=\mathbf{M}^T\mathbf{R}_x(\alpha)\mathbf{M}
\qquad\qquad(4.29)
$$
​		换句话说，这意味着首先我们进行变换，使r为x轴（使用M），然后围绕该x轴旋转α弧度（使用Rx（α）），然后使用M的逆函数进行变换，在这种情况下为MT，因为M是正交的。

​		高德曼[550]提出了另一种通过φ弧度绕任意归一化轴r旋转的方法。在这里，我们只介绍他的变换：

​		
$$
\textbf{R}=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
\cos\phi+(1+\cos\phi)r_x^2 
& (1-\cos\phi)r_xr_y-r_z\sin\phi 
&(1-\cos\phi)r_xr_z+r_y\sin\phi
\\
 (1-\cos\phi)r_xr_y+r_z\sin\phi 
 & \cos\phi+(1-\cos\phi)r_y^2 
 & (1-\cos\phi)r_yr_z-r_x\sin\phi 
 \\
 (1-\cos\phi)r_xr_z+r_y\sin\phi 
 &(1-\cos\phi)r_yr_z+r_x\sin\phi 
 & \cos\phi+(1-\cos\phi)r_z^2 
\\ 
\end{matrix}
\end{pmatrix}.
\qquad\qquad(4.30)
\end{gather*}
$$
​		在第4.3.2节中，我们提出了使用四元数解决此问题的另一种方法。在该部分中，还有针对相关问题（例如，从一个向量到另一个向量的旋转）的更有效算法。

### 4.3四元数

​		尽管四元数是威廉·罗恩·汉密尔顿爵士于1843年发明的，它是复数的扩展，但直到1985年，Shoemake [1633]才将它们引入计算机图形学领域。1四元数用于表示旋转和方向。它们在几个方面都优于欧拉角和矩阵。任何三维定向都可以表示为围绕特定轴的单个旋转。考虑到该轴和角度表示，四元数的平移或从四元数的平移都是简单的，而在任一方向上的欧拉角转换都具有挑战性。四元数可用于稳定和恒定的方向插值，而欧拉角无法很好地完成这些操作。

​	复数具有实部和虚部。每个均由两个实数表示，第二个实数乘以V 1。同样，四元数有四个部分。前三个值与旋转轴密切相关，旋转角影响所有四个部分（有关更多信息，请参见第4.3.2节）。每个四元数由四个实数表示，每个实数与一个不同的部分相关联。由于四元数具有四个分量，因此我们选择将它们表示为向量，但是为了区分它们，我们在它们上加了一个帽子：qˆ。我们从四元数的一些数学背景开始，然后将其用于构建各种有用的转换。

#### 4.3.1数学背景

​		我们从四元数的定义开始。

​		定义。四元数qˆ可以用以下所有等效的方式定义。

​		
$$
\begin{align}
\hat{\mathbf{q}}&=(\mathbf{q}_v,q_w)=iq_x+jq_y+kq_z+q_w=\mathbf{q}_v+q_w,\\
\mathbf{q}_v&=iq_x+jq_y+kq_z=(q_x,q_y,q_y),\qquad\qquad\qquad\qquad(4.31)
\\
i^2&=j^2=k^2=-1,jk=-kj=i,ki=-ik=j,ij=-ji=k
\end{align}
$$
​		变量qw被称为四元数q的实部。虚部为qu，i，j和k称为虚部。

​		对于虚部qv，我们可以使用所有法向矢量运算，例如加法，缩放，点积，叉积等等。使用四元数的定义，可以得出两个四元数qˆ和ˆr之间的乘法运算，如下所示。注意，虚部的乘法是不可交换的。

​		
$$
\begin{align}
乘法:\mathbf{\hat{q}\hat{r}}&=(iq_x+jq_y+kq_z+q_w)(ir_x+jr_y+kr_z+r_w)\\
&=i(q_yr_z-q_zr_y)+r_wq_x+q_wr_x)
\\&+j(q_zr_x-q_xr_z+r_wq_y+q_wr_y)\qquad\qquad(4.32)
\\&+k(q_xr_y-q_yr_x+r_wq_z+q_wr_z)
\\&+q_wr_w-q_xr_x-q_yr_y-q_zr_z
\\=&(\mathbf{q}_v\times\mathbf{r}_v+r_w\mathbf{q}_v+q_w\mathbf{r}_v,
q_wr_w-\mathbf{q}_v\cdot\mathbf{r}_v).
\end{align}
$$
​		从该方程式可以看出，我们使用叉积和点积来计算两个四元数的乘法。

​		除了四元数的定义外，还需要加法，共轭，范数和恒等式的定义：

​		
$$
\begin{align}
&加法:\hat{\mathbf{q}}+\hat{\mathbf{r}}=
(\mathbf{q}_v,q_w)+(\mathbf{r}_v,r_w)=
(\mathbf{q}_v+\mathbf{r}_v,q_w+r_w).\\
&共轭：\mathbf{\hat{q}}^*=(\mathbf{q}_v,q_w)^*=(-\mathbf{q}_v,q_w).\\
&归一化：n(\mathbf{\hat{q}})=\sqrt{\hat{\mathbf{q}}^*\hat{\mathbf{q}}}
=\sqrt{\mathbf{q}_v\cdot\mathbf{q}_v+q_w^2}\qquad\qquad(4.33)\\
&\qquad\qquad\quad=\sqrt{q_x^2+q_y^2+q_z^2+q_w^2}.\\
&特征:\mathbf{\hat{i}}=(\textbf 0,1)
\end{align}
$$
​		当简化n（qˆ）= √qˆqˆ ∗时（如上所示），虚部将抵消，仅保留实部。规范有时表示为|| qˆ || = n（qˆ）[1105]。上面的结果是，可以导出由q -1表示的乘法逆。方程qˆ−1qˆ = qˆqˆ−1 = 1对于逆必须成立（对于乘法逆来说是常见的）。我们从规范的定义中得出一个公式：

​		
$$
n(\mathbf{\hat{q}})^2=
\mathbf{\hat{q}\hat{q}^*}
\Longleftrightarrow
\frac{\mathbf{\hat{q}\hat{q}^*}}{n(\mathbf{\hat{q}})^2}=1
\qquad\qquad(4.34)
$$
​		这给出了乘法逆，如下所示：

​		
$$
乘法逆：
\mathbf{\hat{q}}^{-1}=
\frac{1}{n(\mathbf{\hat{q}})^2}\mathbf{\hat{q}}^*.
\qquad\qquad(4.35)
$$
​		逆公式使用标量乘法，它是从公式4.3.1中看到的乘法得出的运算：sqˆ =（0，s）（qv，qw）=（sqv，sqw），q，s =（qv，qw ）（0，s）=（sqv，sqw），这意味着标量乘法是可交换的：sqˆ = qˆs =（sqv，sqw）。

​		以下规则集合很容易从定义中得出：

​		
$$
\begin{align}
(\hat{\mathbf{q}})^*=&\hat{\mathbf{q}},\\
(\hat{\mathbf{q}}+\hat{\mathbf{r}})^*=&\hat{\mathbf{q}}^*+\hat{\mathbf{r}}^*,
\qquad\qquad(4.36)\\
(\hat{\mathbf{q}}\hat{\mathbf{r}})^*=&\hat{\mathbf{r}}^*\hat{\mathbf{q}}^*.
\end{align}
$$
​		
$$
\begin{align}
n(\hat{\mathbf{q}}^*)=&n(\hat{\mathbf{q}}),\\
n(\hat{\mathbf{q}}\hat{\mathbf{r}})=&n(\hat{\mathbf{q}})n(\hat{\mathbf{r}}).
\qquad\qquad(4.37)
\end{align}
$$

$$
\begin{align}
\hat{\mathbf{p}}(s\hat{\mathbf{q}}+t\hat{\mathbf{r}})=&
s\hat{\mathbf{p}}\hat{\mathbf{q}}+t\hat{\mathbf{p}}\hat{\mathbf{r}},
\\
(s\hat{\mathbf{p}}+t\hat{\mathbf{q}})\hat{\mathbf{r}}=&
s\hat{\mathbf{q}}\hat{\mathbf{r}}+t\hat{\mathbf{q}}\hat{\mathbf{r}}.
\qquad\qquad(4.38)
\end{align}
$$

​		
$$
\hat{\mathbf{p}}(\hat{\mathbf{q}}\hat{\mathbf{r}})=
(\hat{\mathbf{p}}\hat{\mathbf{q}})\hat{\mathbf{r}}
$$

$$
\hat{\mathbf{q}}=(\sin\phi\mathbf{u}_q,\cos\phi)=
\sin\phi\mathbf{u}_q+\cos\phi,
\qquad\qquad(4.39)
$$

​	
$$
\begin{align}
n(\hat{\mathbf{q}})&=n(\sin\phi\mathbf{u}_q,\cos\phi)=
\sqrt{\sin^2\phi(\mathbf{u}_q\cdot\mathbf{u}_q)+\cos^2\phi}\\
&=\sqrt{\sin^2\phi+\cos^2\phi}=1
\qquad\qquad(4.40)
\end{align}
$$

$$
\hat{\mathbf{q}}=\sin\phi\mathbf{u}_q+
\cos\phi=e^{\phi\mathbf{u}_q}.
\qquad\qquad(4.41)
$$

$$
\begin{align}
&\log(\hat{\mathbf{q}})=\log(e^{\phi\mathbf{u}_q})=\phi\mathbf{u}_q,
\\
&\hat{\mathbf{q}}^t=(\sin\phi\mathbf{u}_q+\cos\phi)^t=
e^{\phi t\mathbf{u}_q}=\sin(\phi t)\mathbf{u}_q+\cos(\phi t).
\qquad\qquad(4.42)
\end{align}
$$

#### 4.3.2 四元数变换

$$
\hat{\mathbf{q}}\hat{\mathbf{p}}\hat{\mathbf{q}}^{-1}
\qquad\qquad(4.43)
$$

$$
\hat{\mathbf{r}}(\hat{\mathbf{q}}\hat{\mathbf{p}}\hat{\mathbf{q}}^*)\hat{\mathbf{r}}^*=
(\hat{\mathbf{r}}\hat{\mathbf{q}})\hat{\mathbf{p}}
(\hat{\mathbf{r}}\hat{\mathbf{q}})^*=
\hat{\mathbf{c}}\hat{\mathbf{p}}\hat{\mathbf{c}}^*.
\qquad\qquad(4.44)
$$



## 5.着色基础

​		渲染三维对象的图像时，模型不仅应具有适当的几何形状，而且还应具有所需的视觉外观。根据应用程序的不同，其范围可以从写实感（外观与真实物体的照片几乎相同）到出于创造性原因选择的各种类型的风格化外观。有关两者的示例，请参见图5.1。

​		本章将讨论同样适用于真实感渲染和风格化渲染的那些方面。第15章专门致力于风格化渲染，而本书的重要部分（第9章至第14章）则着重于通常基于物理的真实感渲染方法。

### 5.1着色模型

​		确定渲染对象外观的第一步是选择一个着色模型，用于描述对象的颜色如何根据表面取向，视图方向和光照等因素而产生变化。

​		例如，我们将使用Gooch着色模型[561]的变体。这是第15章讨论的非真实感渲染的一种形式。Gooch着色模型旨在提高技术插图(类似工艺品)中细节的清晰度。

​		Gooch着色背后的基本思想是将表面法线与光源的位置进行比较。如果法线指向灯光，则使用较暖的色调为表面着色；如果指向不对，则使用较冷的色调。介于两者之间的角度在这些色调之间进行插值，这取决于用户提供的表面颜色。在此示例中，我们向模型添加了风格化的“突出显示”效果，以使表面具有光泽外观。图5.2显示了实际的着色模型。

​		着色模型通常具有用于控制外观变化的属性。设置这些属性的值是确定对象外观的下一步。我们的示例模型只有一种属性，即表面颜色，如图5.2的底部图像所示。

![1570721010717](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1570721010717.png)

​		<font size=2>图5.1。顶部图像来自使用虚幻引擎渲染的真实风景场景。底部图片来自Campo Santo的游戏Firewatch，该游戏采用说明性艺术风格设计。 （上图由G̈okhanKaradayi提供，下图由Campo Santo提供。）</font>

​	![1570721041515](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1570721041515.png)

​		<font size=2>图5.2。风格化的着色模型，结合了Gooch着色和高光效果。顶部图像显示了具有中性表面颜色的复杂对象。下图显示了具有各种不同表面颜色的球体。 （来自计算机图形档案[1172]的中国龙网格，来自斯坦福3D扫描存储库的原始模型。）</font>

![1570721057335](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\1570721057335.png)

​		<font size=2>图5.3。单位长度矢量输入到示例阴影模型（以及其他大多数着色模型）：表面法线n，视图矢量v和光照方向l。</font>

​		与大多数着色模型一样，此示例受与表面取向相关的视点和照明方向的影响。为了方便着色，这些方向通常表示为归一化（单位长度）向量，如图5.3所示。

​		现在，我们已经定义了阴影模型的所有输入，接下来可以看一下模型本身的数学定义：

​		
$$
\mathbf{c}_{shaded}=
s\textbf{c}_{highlight}+(1-s)(t\textbf{c}_{warm}+(1-t)\textbf{c}_{cool}).
\qquad\qquad(5.1)
$$
​		在此方程式中，我们使用了以下中间计算：
$$
\begin{align}
\textbf{c}_{cool}&=(0,0,0.55)+0.25\textbf{c}_{surface},\\
\textbf{c}_{warm}&=(0.3,0.3,0)+0.25\textbf{c}_{surface},\\
\textbf{c}_{highlight}&=(1,1,1),\\
t&=\frac{\mathbf{n}\cdot\mathbf{l}+1}{2},
\qquad\qquad(5.2)
\\
r&=2(\mathbf{n}\cdot\mathbf{l})\mathbf{n}-\mathbf{l},\\
s&=(100(\mathbf{r}\cdot\mathbf{v})-97)^{\mp}.
\end{align}
$$

​		该定义中的几个数学表达式也经常在其他着色模型中找到。着色操作中通常会进行区间限定操作，通常区间限定到0或在0到1之间。这里，我们将在1.2节中介绍的x表示法用于计算高光混合因子s，限制在0和1之间的区间。点积运算符出现3次，每次出现在两个单位长度的矢量之间；这是一种极为常见的运算。两个向量的点积是它们的长度与它们之间夹角的余弦的乘积。因此，两个单位长度向量的点积就是夹角的余弦，它是两个向量彼此相似程度的度量。由余弦组成的简单函数通常是最令人愉悦且最准确的数学表达式，用于说明着色模型中两个方向（例如，光线方向和表面法线）之间的关系。

​		另一种常见的着色操作是在两种颜色之间基于0到1之间的标量值的线性插值。该操作采用tca +（1- t）cb的形式，随着t的值在1和0之间移动，它会分别在ca和cb各自进行插值。此操作在此着色模型中出现了两次，第一是在$$\mathbf{c}_{warm}$$和$$\mathbf{c}_{cool}$$之间进行插值，第二是将第一的插值结果与$$\mathbf{c}_{hightlight}$$之间进行插值。线性插值在着色器中出现的频率很高，以至于在我们已经看到的每种着色语言中，它都是一个内置函数，称为lerp或mix。

​		线“ r = 2（n·l）n-l”计算反射光矢量，将l反射大约n。尽管不像前两个操作那样普遍，但是对于大多数着色语言来说，它也具有内置的反射功能就足够了。

​		通过将这些操作以不同的方式与各种数学表达式和着色参数组合在一起，可以为多种风格化和逼真的外观定义着色模型

### 5.2光源

​		

## 6.纹理

## 7.阴影

## 8.光和颜色

## 9.基于物理的着色

## 10.局部光照

## 11.全局光照

## 12.图像空间特效

## 13.超越多边形

## 14.体积和半透明渲染

## 15.非真实图像渲染

## 17.曲线和曲面

## 18管线优化

## 19.加速算法

## 20.高效着色

## 21.虚拟现实和增强现实

## 22.交叉测试方法

## 23.图形硬件



