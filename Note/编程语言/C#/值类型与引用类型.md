# 值类型与引用类型

**引用类型**:class,数组(即使元素类型是值类型),委托,接口

**值类型**:struct,枚举

差异点:

1.存储位置不同:<font color=#f05b72>见误区第二点</font>

2.值类型不可以派生出其他类型:

对于引用类型来说,每个对象的开头都包含一个数据块,它标识了对象的实际类型,同时还提供了其他的一些信息.

**永远不能改变对象的类型**,当执行简单的强制类型转换时,运行时会获取一个引用,检查它引用的对象是不是目标类型的一个有效对象.如果有效就返回原始引用,否则就抛出异常.

引用本身并不知道对象的类型,所有同一个引用"值"可用于(引用)不同类型的多个变量.

```
Stream stream=new MemoryStream();
MemoryStream memorystream=(MemoryStream)stream;
```

第二行检查stream的值,引用的是不是一个MemoryStream(或子类)对象,并将memorystream的值设为相同的值.

## 关于值类型和引用类型的误区

**1.结构是轻量级的类**

结构和类都可以拥有函数

从使用角度上看:具体使用结构还是类,要根据设计时所需要的语义,值类型或者是引用类型,而不是根据这个类型简单与否.(eg.DateTime被作为结构但也提供了相应的操作函数).

从性能角度上看:结构(值类型),它不需要垃圾回收(除非被装箱).类(引用类型),它在作为函数参数等操作时,只需要复制较少的字节而结构需要整个被复制.两者都有不同的适用情况,要从具体的上下文来决定.不能简单的说结构比类更加轻量(高效).

不管是类还是结构,拥有多少函数并不重要,每个关于结构或者类的实例所占用的内存不会受到影响.(**代码本身会消耗内存,但这只会发生一次,而不是每个实例都发生**). <font color=#f05b72>代码在存储时消耗一次内存,在调用对象的函数的时候,实际上是通过寻址到函数的地址进行调用,可以理解为同一类型的对象共享同一片代码</font>

 

**2.引用类型保存在堆上,值类型保存在栈上**

第一部分是正确的,引用类型保存在堆上.<font color=#f05b72>静态变量也保存在堆上</font>

但第二部分有问题,**变量的值是在它声明的位置存储的**.所以假定一个类中有一个int类型的成员变量,那么在这个类的任何实例中,该变量的值总是和该实例的其他数据在一起,也就是在堆上.

**只有局部变量(函数内部声明的变量)和函数参数在栈上**.(有例外,如匿名函数)<font color=#f05b72>也就是说引用类型的函数参数(注意这是个引用不是实际的对象)的也是保存在栈上的</font>



**3.对象在C#中默认是通过引用传递**

先理解传递分为值传递和引用传递,**无论是引用传递还是值传递,永远不会传递对象本身.**

* 值传递:就是直接传递,这样值类型是一个副本,引用类型是一个引用

* 引用传递:就是在传入的参数之前添加ref和out关键字,这样值类型和引用类型都会改变原始的变量

**引用类型作为函数参数使用时,参数默认是以值传递方法来传递的,但值(括号内的形参)本身是一个引用.**

## 装箱和拆箱

装箱:它允许**根据值类型创建一个对象**,然后使用对这个新对象的一个引用.

拆箱:装箱的逆过程,复制箱内的值,**在赋值后,和引用类型不再有关系**,如下代码块中的o和j.

```
int i=5;
object 0=i;//装箱,o是一个新对象的一个引用,用当前i的值创建的
int j=(int)o//拆箱,对j的改变不会改变i,j是值类型
//到这,三者之间再也没有任何关系,2个值类型,一个引用类型
```

**隐式发生的装箱:**

1.为一个类型的值调用ToString,Equals,GetHashCode方法时,如果该类型没有覆盖这些方法,也会发生装箱.

2.将值赋给一个接口类型的变量,或者把它作为接口类型的参数来传递,也会发生装箱.(eg.IComparable x=5,会对数字5进行装箱).

装箱和拆箱**会加剧程序本身的操作开销,还会创建数量庞大的对象,而这些对象会加重垃圾回收器的负担**.