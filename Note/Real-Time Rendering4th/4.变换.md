## 4.变换

​		变换是一种操作，它接受点，向量或颜色等实体，并以某种方式对其进行转换。对于计算机图形从业者来说，掌握转换极为重要。使用它们，您可以定位，重塑形状和设置对象，灯光和照相机的动画。您还可以确保所有计算都在同一坐标系中进行，并将对象以不同的方式投影到平面上。这些只是少数可以通过变换执行的操作，但是它们足以说明变换在实时图形或任何形式的计算机图形中的重要性。

​		线性变换是保留矢量加法和标量乘法的变换。特别，

​		
$$
f(x)+f(y)=f(x+y)\qquad\qquad\qquad\quad(4.1)\\
kf(x)=f(kx)\qquad\qquad\qquad\qquad\qquad(4.2)
$$
​		例如，f（x）= 5x是一个采用向量并将每个元素乘以5的变换。为了证明这是线性的，需要满足两个条件（公式4.1和4.2）。第一个条件成立，因为任何两个向量乘以五然后相加将与将向量相加然后相乘相同。标量乘法条件（方程式4.2）已明确满足。此功能称为缩放变换，因为它可以更改对象的缩放比例（大小）。旋转变换是另一个线性变换，使向量围绕原点旋转。比例变换和旋转变换，实际上是三元素矢量的所有线性变换，都可以使用3×3矩阵表示。

​		但是，矩阵的大小通常不够大。三元素向量x的函数（例如f（x）= x +（7，3，2））不是线性的。在两个单独的向量上执行此函数将把（7，3，2）的每个值相加两次以形成结果。将一个定值的向量添加到另一个向量会执行变换，例如，它将所有位置移动相同的数量。这是一种有用的变换类型，我们想结合各种变换，例如，将对象缩放到一半大小，然后将其移动到其他位置。到目前为止，将函数保持在简单的形式上很难使它们轻松组合。

​		可以使用仿射变换将线性变换和平移结合起来，通常以4×4矩阵形式存储。仿射变换是先执行线性变换然后执行平移的变换。为了表示四个元素的向量，我们使用齐次记法，以相同的方式表示点和方向（使用粗体小写字母）。方向向量表示为$$v =（v_x v_y v_z 0）^T$$，点表示为$$v =（v_x v_y v_z 1）^T$$。在本章中，我们将广泛使用在realtimerendering.com上可下载的线性代数附录中解释的术语和运算。

​		所有平移，旋转，缩放，反射和剪切矩阵都是仿射的。仿射矩阵的主要特征是它保留了线的平行性，但不一定保留长度和角度。仿射变换也可以是各个仿射变换的串联的任何序列。

​		本章将从最基本的基本仿射变换开始。本部分可以看作是简单转换的“参考手册”。然后描述了更特殊的矩阵，随后对四元数（一种强大的转换工具）进行了讨论和描述。然后是顶点融合和变形，这是两种表达网格动画的简单但有效的方法。最后，描述了投影矩阵。这些转换中的大多数，它们的符号，功能和特性总结在表4.1中，其中正交矩阵其逆矩阵是其转置矩阵。

​		变换是用于操纵几何的基本工具。大多数图形应用程序编程接口允许用户设置任意矩阵，有时库可能使用了许多实现了本章讨论的转换的矩阵运算。但是，仍然有必要了解函数调用背后的实际矩阵及其相互作用。知道这样的函数调用之后矩阵的功能是一个开始，但是了解矩阵本身的属性将使您更进一步。例如，这种理解使您处理正交矩阵时（其逆矩阵是其转置矩阵），从而可以更快地进行矩阵求逆。这样的知识可以加速代码运行效率。

​		



### 4.1基础变换

​		本节介绍最基本的变换，例如平移，旋转，缩放，切边，变换级联，刚体变换，法线变换（不是正常的）和逆计算。对于有经验的读者，可以将其用作简单转换的参考手册，对于新手，则可以作为本主题的入门。本材料是本章其余部分和本书其他各章的必要背景。我们从最简单的变换开始-平移。

|                 符号                  |     名字     |                             行为                             |
| :-----------------------------------: | :----------: | :----------------------------------------------------------: |
|      $$\textbf{T}(\textbf{t})$$       |   变换矩阵   |                       平移一个点，仿射                       |
|        $$\textbf{R}_x(\rho)$$         |   旋转矩阵   |     绕x轴旋转ρ弧度。 y轴和z轴的表示法相似。 正交和仿射。     |
|            $$\mathbf{R}$$             |   旋转矩阵   |                   任意旋转矩阵，正交，仿射                   |
|           $$\mathbf{S}(s)$$           |   缩放矩阵   |                   根据s同时缩放xyz轴，仿射                   |
|        $$\mathbf{H}_{ij}(s)$$         |   切变矩阵   |  相对于分量j，将分量i根据因子s切变。i，j∈{x，y，z}。 仿射。  |
|       $$\mathbf{E}(h,\rho,r)$$        |   欧拉变换   | 欧拉角给出的取向矩阵，head（yaw），pitch，roll 。 正交和仿射。 |
|          $$\mathbf{P}_o(s)$$          |   正交投影   |               平行投影到某一片面或者体积，仿射               |
|          $$\mathbf{P}_p(s)$$          |   透视投影   |                  透视投影到某一片面或者体积                  |
| $$\text{slerp}{(\hat{q},\hat{r},t)}$$ | 球面线性插值 |          生成关于四元数q和r以及参数t的插值四元数。           |

​		<font size=2>表4.1。本章讨论的大多数转换的摘要。</font>

#### 4.1.1平移变换

​		从一个位置到另一个位置的变化由平移矩阵$$\mathbf{T}$$表示。此矩阵通过向量$$\mathbf{t}$$ =（$$t_x，t_y，t_z$$）平移实体。 $$\mathbf{T}$$由下面的公式4.3给出：
$$
\textbf{T}(\textbf{t})=
\textbf{T}(t_x,t_y,t_z)=
\begin{gather*}
\begin{pmatrix}
1 & 0& 0 & t_x \\
0 & 1& 0 & t_y \\
0 & 0& 1 & t_z \\
0 & 0& 0 & 1
\end{pmatrix}
\end{gather*}
\qquad \qquad (4.3)
$$
​		图4.1显示了平移变换效果的示例。容易证明，将点p =（$$p_x，p_y，p_z，1$$）与$$\mathbf{T}$$（t）相乘会产生一个新的点p'=（$$p_x + t_x，p_y + t_y，p_z + t_z，1$$），很显然是平移。 注意向量v =（$$v_x，v_y，v_z，0$$）不受与矩阵T乘法的影响，因为方向向量无法平移。相反，其余的仿射变换都会影响点和向量。平移矩阵的逆是$$\mathbf{T}^{-1}（t）=\mathbf{T}(-t)$$，即向量$$\mathbf{t} $$取反。

​	![image-20191118213722377](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191118213722377.png)

​		<font size=2>图4.1。左侧的正方形通过平移矩阵T（5，2，0）进行变换，从而使正方形向右移动5个距离单位，向上移动2个距离单位。</font>

​		在这一点上，我们应该提到的是，有时在计算机图形学中也可以看到的另一种有效的符号方案是使用矩阵和行向量。例如，DirectX使用这种形式。在该方案中，矩阵的顺序将被颠倒，即，应用的顺序将从左到右读取。因为向量是行，所以用这种表示法表示的矢量和矩阵都是行形式。在本书中，我们使用列形式。无论使用哪种方式，这纯粹是一种符号上的差异。当矩阵存储在内存中时，十六个值的最后四个值是三个转换值，跟上一个1。

#### 4.1.2旋转变换

​		旋转变换将向量（位置或方向）绕经过原点的给定轴旋转给定角度。像平移矩阵一样，它是一个刚体变换，即它保留了变换后的点之间的距离，并保留了惯用性（即它从不导致左右两侧互换）。在计算机图形学中，这两种类型的转换对于定位和定向对象非常有用。方位矩阵是与摄像机视图或对象相关联的旋转矩阵，它定义了其在空间中的方位，即其向上和向前的方向。

​		在二维中，旋转矩阵很容易得出。假设我们有一个向量$$\mathbf{v}=(v_x,v_y)$$，我们将其参数化为$$\mathbf{v}=(v_x,v_y)=（r\cos\theta,r\sin\theta）$$。如果我们将向量旋转$$\phi$$弧度（逆时针），则将得到$$\mathbf{u}=(r\cos(\theta+\phi),r\sin(\theta+\phi))$$。这可以重写为

​		
$$
\begin{gather*}
\textbf{u}=
\begin{pmatrix}
r cos(\theta+\phi) \\
r sin(\theta+\phi) \\
\end{pmatrix}=
\begin{pmatrix}
r(cos\theta\cos\phi-sin\theta\sin\phi) \\
r(sin\theta\cos\phi+cos\theta\sin\phi) \\
\end{pmatrix}\\
=
\underbrace {
\begin{pmatrix}
cos\theta\qquad-sin\phi \\
sin\theta\qquad cos\phi
\end{pmatrix}}_{\textbf{R}(\phi)}
\underbrace {
\begin{pmatrix}
rcos\theta\\
rsin\theta
\end{pmatrix}}_{\textbf{v}}
=\textbf{R}(\phi)\textbf{v}
\end{gather*}
\qquad\qquad(4.4)
$$
​		这里我们使用角度和关系来展开$$r\cos(\theta+\phi)$$和$$r\sin(\theta+\phi)$$。在三维上，常用的旋转矩阵是$$\mathbf{R}_x(\phi),\mathbf{R}_y(\phi),\mathbf{R}_z(\phi)$$，它们分别绕x，y和z轴旋转$$\phi $$弧度。它们由公式4.5–4.7给出：

​		
$$
\textbf{R}_{x}(\phi)=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
1 & 0& 0 & 0\\
0& cos\phi&-\sin\phi& 0 \\
0 &sin\phi&\cos\phi& 0 \\
0 & 0& 0 & 1
\end{matrix}
\end{pmatrix}
\end{gather*}
\qquad \qquad (4.5)
$$

$$
\textbf{R}_{y}(\phi)=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
cos\phi & 0& sin\phi & 0\\
0& 1&0& 0 \\
-sin\phi &0&\cos\phi& 0 \\
0 & 0& 0 & 1
\end{matrix}
\end{pmatrix}
\end{gather*}
\qquad \qquad (4.6)
$$

$$
\textbf{R}_{z}(\phi)=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
cos\phi&sin\phi&0 & 0\\
sin\phi&\cos\phi&0& 0 \\
0 & 0&1&0 \\
0 & 0& 0 & 1
\end{matrix}
\end{pmatrix}
\end{gather*}
\qquad \qquad (4.7)
$$

​		如果从4×4矩阵中删除最底行和最右列，则将获得3×3矩阵。对于绕任意轴旋转$$\phi$$弧度的每3×3旋转矩阵R，迹线（矩阵中对角元素的总和）与轴无关，是恒定的，计算公式为[997]：

​		
$$
tr(\textbf{R})=1+2cos\phi\qquad\qquad(4.8)
$$
​		旋转矩阵的效果可以在第65页的图4.4中看到。旋转矩阵$$\mathbf{R}_i(\phi)$$的特点除了它绕着轴i旋转$$\phi $$弧度外，还在于它将旋转轴i上的所有点保持不变。注意，$$\mathbf{R} $$也将用于表示围绕任何轴的旋转矩阵。上面给出的轴旋转矩阵可以在一系列三个变换(分解为x,y,z轴3个分量)中使用，以执行绕任意轴旋转。该过程在第4.2.1节中讨论。第4.2.4节介绍了直接绕任意轴旋转。

​		所有旋转矩阵的行列式均为1，并且是正交的。这对于任何数量的旋转变换的串联也成立。还有另一种求逆的方法：$$\mathbf{R}_i^{-1}(\phi)=\mathbf{R}_i(-\phi)$$，即绕同一轴线沿相反方向旋转。

​		示例：绕点旋转。假设我们要围绕z轴旋转一个对象$$\phi $$弧度，并且旋转中心为某个确定点$$\mathbf{P}$$。如何转换？图4.2中描述了这种情况。由于绕点旋转的特点在于该点本身不受旋转的影响，因此变换首先通过平移对象使$$\mathbf{P}$$点与原点重合开始，这是通过$$\mathbf{T}(\mathbf{-p})$$完成的。此后跟随实际旋转：$$\mathbf{R}_z(\mathbf{\phi})$$。最后，必须使用$$\mathbf{T}(\mathbf{p})$$将对象平移回其原始位置。然后，得到的变换$$\mathbf{X}$$由下式给出

​		
$$
\textbf{X}=\textbf{T}(\textbf{p})\textbf{R}_{z}(\phi)\textbf{T}(-\textbf{p})
\qquad\qquad(4.9)
$$
​		注意上面矩阵的顺序。

![image-20191118213802325](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191118213802325.png)

​		<font size=2>图4.2。围绕特定点p旋转的示例。</font>

#### 4.1.3缩放变换

​		缩放矩阵$$\mathbf{S}(\mathbf{s})=\mathbf{S}(s_x,s_y,s_z)$$分别沿x，y和z方向缩放因子为$$s_x,s_y$$和$$s_z$$的实体。这意味着可以使用缩放矩阵来放大或缩小对象。$$s_i,i\in\{x,y,z\}$$越大，则实体在该方向上缩放越大。将s的任何分量设置为1自然可以避免该方向缩放的更改。公式4.10显示S：

​		
$$
\textbf{S}(s)=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
S_{x}&0&0 & 0\\
0&S_{y}&0& 0 \\
0 & 0&S_{z}&0 \\
0 & 0& 0 & 1
\end{matrix}
\end{pmatrix}
\end{gather*}
\qquad \qquad (4.10)
$$
​		<font size=2>第65页上的图4.4说明了缩放矩阵的作用。如果$s_x=s_y=s_z$，则缩放操作称为均匀操作，否则称为非均匀操作。有时，使用等向性和各向异性缩放来代替均匀和非均匀性。逆运算是$S^{-1}（s）= S（1 / s_x，1 / s_y，1 / s_z）$。</font>

​		使用齐次坐标，创建统一缩放矩阵的另一种有效方法是通过操作位置（3,3）处的矩阵元素，即右下角的元素。该值会影响齐次坐标的w分量，因此会缩放矩阵变换后的点（而非表示方向的向量）的每个坐标分量。例如，要均匀地缩放5倍，可以将缩放矩阵中（0，0），（1、1）和（2，2）的元素设置为5，或将（3， 3）可以设置为1/5。执行此操作的两种不同矩阵如下所示：

​		
$$
\textbf{S}(s)=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
5&0&0 & 0\\
0&5&0& 0 \\
0 & 0&5&0 \\
0 & 0& 0 & 1
\end{matrix}
\end{pmatrix},
\qquad\qquad
\textbf{S}^{'}=
\begin{pmatrix}
\begin{matrix}
1&0&0 & 0\\
0&1&0& 0 \\
0 & 0&1&0 \\
0 & 0& 0 & 1/5
\end{matrix}
\end{pmatrix}.
\end{gather*}
\qquad \qquad (4.11)
$$
​		与使用$$\mathbf{S}$$进行均匀缩放相反，使用$$\mathbf{S'}$$必须始终在之后进行归一化。这可能是低效的，因为它涉及归一化过程中的除法。如果右下角的元素（位置（3，3））为1，则不需要除法。当然，如果系统总是在不进行1测试的情况下进行除法，则不会产生任何额外费用。

​		$$\mathbf{S}$$的一个或三个分量上的负值给出一种反射矩阵，也称为镜像矩阵。如果只有两个比例因子为-1，那么我们将旋转π弧度。应当注意，与反射矩阵连接的旋转矩阵也是反射矩阵。因此，以下是反射矩阵：

​		
$$
\begin{gather*}
\underbrace {
\begin{pmatrix}
cos(\pi/2)&sin(\pi/2) \\
-sin(\pi/2)&cos(\pi/2) \\
\end{pmatrix}}_{旋转}
\underbrace {
\begin{pmatrix}
1&0\\0&1
\end{pmatrix}}_{反射}=
\begin{pmatrix}
0&-1\\-1&0
\end{pmatrix}.
\end{gather*}
\qquad\qquad(4.12)
$$
​		通常反射矩阵在检测到时需要特殊处理。例如，当三角形的具有逆时针顺序的顶点经过反射矩阵转换后，其顶点将获得顺时针顺序。此顺序更改可能导致不正确的照明和背面剔除。要检测给定矩阵是否以某种方式反射，请计算矩阵左上3×3个元素的行列式。如果该值为负，则矩阵是反射性的。例如，公式4.12中矩阵的行列式为0·0 −（-1）·（-1）= -1。

​		示例：沿特定方向缩放。缩放矩阵$$\mathbf{S}$$仅沿x轴，y轴和z轴缩放。如果应在其他方向执行缩放，则需要复合转换。假设缩放沿着正交的轴进行，右向向量$$\mathbf{f}^x,\mathbf{f}^y$$和$$\mathbf{f}^z$$。首先，构造矩阵$$\mathbf{F}$$，以更改基底，如下所示：

​		
$$
\textbf{F}=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
\textbf{f}^x&\textbf{f}^y&\textbf{f}^z& 0\\
0 & 0& 0 & 1
\end{matrix}
\end{pmatrix}
\end{gather*}
\qquad \qquad (4.13)
$$
​		想法是使给定的坐标系的三个轴与标准轴重合，然后使用标准缩放矩阵，然后变换回去。第一步是通过乘以$$\mathbf{F}$$的转置即它的逆来进行的。然后完成实际的缩放，然后再变换回去。转换如公式4.14所示：

​		
$$
\textbf{X}=
\textbf{FS}(\textbf{s})
\textbf{F}^{T}.
\qquad \qquad (4.13)
$$

#### 4.1.4切变变换

​		另一类变换是其切变矩阵集。例如，这些可以用于游戏中以扭曲整个场景，以产生迷幻效果或扭曲模型的外观。有六个基本切变矩阵，分别表示为$$\mathbf{H}_{xy}(s)，\mathbf{H}_{xz}(s)，\mathbf{H}_{yx}(s)，\mathbf{H}_{yz}(s)，\mathbf{H}_{zx}(s)）$$和$$\mathbf{H}_{zy}(s)$$。第一个下标用于表示切变矩阵更改哪个坐标轴分量，而第二个下标表示使用哪个坐标轴分量进行剪切的。剪切矩阵$$\mathbf{H}_{xz}(s)$$的示例如公式4.15所示。注意，下标可用于在下面的矩阵中找到参数s的位置； x（其数字索引为0）标识第零行，而z（其数字索引为2）标识第二列，因此s位于此处：

​		
$$
\textbf{H}_{xz}(s)=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
1&0&s & 0\\
0&1&0& 0 \\
0 & 0&1&0 \\
0 & 0& 0 & 1
\end{matrix}
\end{pmatrix}.
\qquad\qquad(4.15)
\end{gather*}
$$
​		![image-20191118231628089](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191118231628089.png)

​		<font size=2>图4.3。用Hxz剪切单位正方形的效果。 y值和z值都不受转换的影响，而x值是旧x值和s乘以z值的总和，从而导致平方倾斜。这种变换是保留区域的，这可以通过虚线区域相同来看出。</font>

​		将该矩阵与点p相乘会产生一个点：$$(p_x+sp_z\quad p_y\quad p_z)^{T}$$。图4.3中以单位正方形的形式显示了这一点。$$\mathbf{H}_{ij}(s) $$的逆运算（根据第j个坐标轴剪切第i个坐标轴，其中i$$ \neq $$ j）是通过沿相反方向切变而生成的，即，$$\mathbf{H}_{ij}^{-1}(s)=\mathbf{H}_{ij}(-s)$$。

​		你还可以使用略有不同的一种切变矩阵：
$$
\textbf{H}^{'}_{xz}(s,t)=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
1 & 0 & s & 0\\
0 & 1 & t & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{matrix}
\end{pmatrix}.
\qquad\qquad(4.16)
\end{gather*}
$$
​		但是此处，两个下标均用于表示这些坐标轴将被第三坐标轴剪切。这两种不同类型的描述之间的联系是$$\mathbf{H}_{ij}'(s,t)=\mathbf{H}_{ij}(s)\mathbf{H}_{ij}(t)$$，其中k用作第三坐标轴的索引。使用的矩阵取决于个人。最后，应该注意的是，由于任何切变矩阵的行列式| H | = 1，这是一个保留体积的变换，如图4.3所示。

#### 4.1.5变换的级联

​		由于矩阵上乘法运算的不可交换性，因此矩阵出现的顺序很重要。因此，变换的级联被认为是与顺序相关的。

​		作为顺序依赖性的示例，请考虑两个矩阵$$\mathbf{S} $$和$$ \mathbf{R}$$。$$\mathbf{S}(2,0.5,1)$$将x分量缩放为两倍，将y分量缩放为0.5。 $$\mathbf{R}_z(\pi/6)$$绕z轴逆时针旋转π/ 6弧度（右手坐标系从本书的页面指向向外）。这些矩阵可以用两种方法相乘，结果完全不同。这两种情况如图4.4所示。

![image-20191118234057271](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191118234057271.png)

​		<font size=2>图4.4。这说明了矩阵相乘时的顺序依赖性。在第一行中，应用旋转矩阵$R_z（π/ 6）$，然后缩放$S(s)$，其中$s$ =（2，0.5，1）。这样，合成矩阵为$S(s)R_z（π/ 6）$。在底行中，以相反的顺序应用矩阵，得出$R_z（π/ 6）S(s)$。结果明显不同。对于任意矩阵M和N，一般认为MN $\neq$ NM。</font>

​		将一系列矩阵连接为单个矩阵的明显原因是为了提高效率。例如，假设您的游戏场景具有数百万个顶点，并且场景中的所有对象都必须缩放，旋转并最终平移。现在，不是将所有顶点与这三个矩阵中的每一个相乘，而是将这三个矩阵连接到一个矩阵中。然后将此矩阵应用于顶点。该复合矩阵为$$\mathbf{C=TRS}$$。注意这里的顺序。缩放矩阵$$\mathbf{S} $$应该首先应用于顶点，因此在合成中显示在右侧。该排序意味着$$\mathbf{TRSp =(T(R(Sp)))}$$，其中p是要转换的点。顺便说一句，$$\mathbf{TRS}$$是场景图系统常用的顺序。

​		值得注意的是，虽然矩阵级联是依赖于顺序的，但是矩阵可以根据需要进行组合。例如，假设您要使用$$\mathbf{TRSp}$$计算一次刚体变换$$\mathbf{TR}$$。将这两个矩阵$$(\mathbf{TR})(\mathbf{Sp})$$组合在一起并用中间结果替换原先的$$\mathbf{TRSp} $$是有效的。因此，矩阵的级联满足结合律的。

#### 4.1.6刚体变换

​		当一个人抓住一个坚固的物体时，例如从桌子上将笔移动到另一个位置，也许移动到衬衫的口袋里，只有物体的方向和位置会发生变化，而物体的形状通常不会受到影响。这种仅由平移和旋转的串联组成的变换称为刚体变换。它具有保留长度，角度和惯用性的特性。

​		可以将任何刚体矩阵$$\mathbf{X} $$表示为平移矩阵$$\mathbf{T}(\mathbf{t})$$和旋转矩阵$$ \mathbf{R} $$的串联。因此，矩阵$$\mathbf{X} $$在公式4.17中具有的形式：

​		
$$
\textbf{X}=\textbf{T}(\textbf{t)}\textbf{R}=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
r_{00} & r_{01} & r_{02} & t_{x}\\
r_{10} & r_{11} & r_{12} & t_{y} \\
r_{20} & r_{21} & r_{22} & t_{z} \\
0 & 0 & 0 & 1
\end{matrix}
\end{pmatrix}.
\qquad\qquad(4.17)
\end{gather*}
$$
​		$$\mathbf{X} $$的逆计算为$$\mathbf{X}^{-1}=(\mathbf{T}(\mathbf{t})\mathbf{R})^{-1}=\mathbf{R}^{-1}\mathbf{T}(\mathbf{t})^{-1}=\mathbf{R}^T\mathbf{T}(-\mathbf{t})$$。因此，为了计算逆矩阵，对矩阵$$\mathbf{R}$$的左上3×3矩阵进行转置，并且矩阵$$\mathbf{T}$$的平移值$$\mathbf{t}$$改变符号。将这两个新矩阵以相反的顺序相乘以获得逆矩阵。计算$$\textbf{X}$$的逆的另一种方法是考虑$$\mathbf{R}$$（使$$\mathbf{R}$$出现为3×3矩阵）和$$\mathbf{X}$$的符号如下（符号在第6页的公式1.2中描述）：

​		
$$
\mathbf{\bar{R}}=(\textbf{r}_{,0}\quad\textbf{r}_{,1}\quad\textbf{r}_{,2})=
\begin{pmatrix}
\begin{matrix}
\textbf{r}^{T}_{0,}\\
\textbf{r}^{T}_{1,}\\
\textbf{r}^{T}_{2,}\\
\end{matrix}
\end{pmatrix},
\\
\textbf{X}=
\begin{pmatrix}
\begin{matrix}
\overset{\Longrightarrow}{\mathbf{\bar{R}}}&\textbf{t}\\
\mathbf{0}^{T}&\textbf{1}\\
\end{matrix}
\end{pmatrix}.
\qquad \qquad(4.18)
$$
​		其中$$r_{，0}$$表示旋转矩阵的第一列（即逗号表示从0到2的任何值，同时第二个下标为0），而$$r_0^T$$是该列矩阵的第一行。注意，$$\text{0}$$是内部为零的3×1列向量。经过一些计算得出逆运算的表达式如公式4.19中所示：

​		
$$
\textbf{X}^{-1}=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
\textbf{r}_{0,} & \textbf{r}_{1,} & \textbf{r}_{2,} & -\mathbf{\bar{R}}^{T}t\\
0 & 0 & 0 & 1
\end{matrix}
\end{pmatrix}.
\qquad\qquad(4.19)
\end{gather*}
$$
​		![image-20191119224954611](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191119224954611.png)

​		<font size=2>图4.5。涉及计算转换的几何形状，该转换将相机定位在c处，矢量为u'向上，以查看点l。为此，我们需要计算r，u和v。</font>

​		示例：调整相机的方向。图形中的常见任务是调整相机的方向，使其对准特定位置。在这里，我们将介绍gluLookAt（）（来自OpenGL Utility Library，简称GLU）的作用。即使现在很少使用此函数调用，该任务仍然很常见。假设摄像机位于$$\textbf c$$处，我们希望摄像机看着目标$$\textbf l$$，并且给定的摄像机向上的方向为$$\mathbf{u}'$$，如图4.5所示。我们要计算一个由三个向量$$\{\textbf{r,u,v}\}$$组成的基底。我们从计算视点向量$$\mathbf{v}=(\mathbf{c}-\mathbf{l})/||\mathbf{c}-\mathbf{l}||$$开始，即从目标到摄像机位置的归一化向量。然后向右看的向量可以计算为$$\mathbf{r}=-(\mathbf{v}-\mathbf{u}')/||\mathbf{v}-\mathbf{u}'||$$。通常不能保证$$\mathbf{u}'$$向量指向正上方，因此最终的向上向量是另一个叉积，$$\mathbf{u}=\mathbf{v}\times\mathbf{r}$$，由于$$\mathbf{v}$$和$$\mathbf{r}$$都通过构造进行了归一化和相互垂直处理，因此可以保证对其进行归一化。在我们将构建的相机变换矩阵$$\mathbf{M}$$中，其思想是首先转换所有内容，使相机位置位于原点（0，0，0），然后更改基底，使$$\mathbf{r}$$与（1 ，0，0），$$\mathbf{u}$$与（0、1、0）和$$\mathbf{v}$$与（0、0、-1）对齐。这是通过

​		
$$
\begin{gather*}
\textbf{M}=
\underbrace {
\begin{pmatrix}
\begin{matrix}
r_{x} & r_{y} & r_{z} & 0\\
u_{x} & u_{y} & u_{z} & 0 \\
-v_{x} & -v_{y} & -v_{z} & 0 \\
0 & 0 & 0 & 1
\end{matrix}
\end{pmatrix}}_{基底变换}
\underbrace {
\begin{pmatrix}
\begin{matrix}
1 & 0 & 0 & -t_{x}\\
0 & 1 & 0 & -t_{y} \\
0 & 0 & 1 & -t_{z} \\
0 & 0 & 0 & 1
\end{matrix}
\end{pmatrix}}_{平移变换}=
\begin{pmatrix}
\begin{matrix}
r_{x} & r_{y} & r_{z} & -\mathbf{t\cdot r} \\
u_{x} & u_{y} & u_{z} & -\mathbf{t\cdot u} \\
-v_{x} & -v_{y} & -v_{z} & \mathbf{t\cdot v} \\
0 & 0 & 0 & 1
\end{matrix}
\end{pmatrix}
\end{gather*}
\qquad\qquad(4.20)
$$
​		注意，当将转换矩阵与基本矩阵的变化连接在一起时，转换$$\mathbf{-t}$$在右边，因为应该首先应用它。记住将$$\mathbf{r}$$，$$\mathbf{u}$$和$$\mathbf{v}$$的分量放在哪里的一种方法如下。我们希望$$\mathbf{r}$$变成（1，0，0），所以当将基础矩阵的变化乘以（1，0，0）时，我们可以看到矩阵的第一行必须是$$\mathbf{r}$$的元素，因为$$\mathbf{r}\cdot\mathbf{r}=1$$。此外，第二行和第三行必须由与$$\mathbf{r}$$垂直的向量组成，即$$\mathbf{r}\cdot\mathbf{x}=0$$。应用相同的思维对$$\mathbf{u}$$和$$\mathbf{v}$$，我们可以得出基底变换矩阵$$\mathbf{M}$$。

​		

#### 4.1.7法线变换

​		单个矩阵可一致地用于变换点，线，三角形和其他几何形状。相同的矩阵还可以在这些线或在三角形的曲面上变换其切线向量。但是，此矩阵始终不能用于变换一个重要的几何属性，即表面法线（和顶点光照法线）。图4.6显示了如果使用相同的矩阵会发生什么。

![image-20191119225232300](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191119225232300.png)

​		<font size=2>图4.6。左侧是原始几何图形，三角形以及从侧面显示的法线。中间的插图显示了如果模型沿x轴缩放0.5且法线使用相同的矩阵会发生什么。右图显示了法线的正确变换。</font>

​		正确的方法不是乘以矩阵本身，而是使用矩阵的伴随矩阵计算其逆矩阵的转置矩阵[227]。伴随矩阵的计算在我们的在线线性代数附录中进行了描述。伴随矩阵始终保证存在。不能保证经过变换后单位长度依旧具有单位长度，因此通常需要将其归一化。

​		变换法线的传统方法是计算逆矩阵的转置[1794]。此方法通常有效。但是，完全逆矩阵不是必需的，并且有时无法创建。逆矩阵是原始矩阵的行列式除以伴随矩阵。如果该行列式为零，则矩阵是奇异的，并且不存在逆矩阵。

​		即使只计算一个完整的4×4矩阵的伴随矩阵，也可能很昂贵，并且通常没有必要。由于法线是向量，因此平移不会对其产生影响。此外，大多数模型转换都是仿射的。它们不会更改传入的齐次坐标的w分量，即，它们不会执行投影。在这些（常见）情况下，法线变换所需的全部计算是计算左上3×3分量的伴随矩阵。

​		甚至通常不需要计算伴随矩阵。假设我们知道变换矩阵完全由平移，旋转和均匀缩放操作（无拉伸或压缩）的级联组成。平移不影响法线。统一的缩放因子仅改变法线的长度。剩下的就是一系列旋转，总是产生某种形式的旋转，仅此而已。逆矩阵的转置可用于变换法线。事实上旋转矩阵的转置矩阵就是它的逆矩阵。代替以获得正态变换，两个转置（或两个逆）给出原始旋转矩阵。综上所述，原始变换本身这些情况下也可以在直接用于变换法线。

​		最后，并不总是需要重新归一化生成的法线。如果仅平移和旋转连接在一起，则法线在通过矩阵进行变换时不会更改长度，因此不需要重新归一化。如果还连接了统一的缩放比例，则可以使用整体缩放比例因子（如果已知或提取，请参见第4.2.3节）直接对生成的法线进行归一化。例如，如果我们知道应用了一系列缩放，使对象变大了5.2倍，则通过此矩阵转换的法线直接通过将它们除以5.2来重新归一化。另外，要创建一个将产生归一化结果的法线变换矩阵，该比例因子需要除一次原始矩阵的左上3×3部分。

​		请注意，从三角形导出的表面法线（例如，使用三角形边的叉积）经过法线变换后不是一个问题。切向量本质上与法线不同，并且总是可以使用原始矩阵直接转换。

#### 4.1.8逆计算

​		在许多情况下都需要逆计算，例如在坐标系之间来回切换时。根据变换的有关信息，可以使用以下三种方法之一计算逆矩阵的：

  * 如果矩阵是单个变换或是具有给定参数的简单变换序列，则可以通过“反转参数”和矩阵顺序轻松地计算矩阵。例如，如果$$\mathbf{M}＝\mathbf{T}(\mathbf{t})\mathbf{R}(\phi)$$，则$$\mathbf{M}^{-1}＝ \mathbf{R}(-\phi)\mathbf{T}(-\mathbf{t})$$。这很简单，并且保留了转换的准确性，这在渲染巨大世界时很重要[1381]。

  * 如果已知矩阵是正交的，则$$\mathbf{M}^{-1}=\mathbf{M}^{T}$$，即矩阵的转置为逆矩阵。任何顺序的旋转都是旋转，因此是旋转矩阵是正交的。

  * 如果一无所知，则可以使用伴随矩阵方法，克莱默法则，LU分解或高斯消去法来计算逆矩阵。通常最好使用克莱默法则和伴随矩阵方法，因为它们的分支操作较少；在现代体系结构上最好避免使用“如果”测试。请参阅第4.1.7节，了解如何使用伴随矩阵得出逆矩阵进而变换法线。		

​		优化时可以考虑逆计算的目的。例如，如果将逆矩阵用于向量变换，则通常只需要对矩阵的左上3×3部分取反（请参见上一节）。

### 4.2特殊矩阵变换和运算

​		在本节中，将介绍和导出对实时图形必不可少的几种矩阵变换和运算。首先，我们介绍欧拉变换（及其参数提取），这是描述方向的直观方法。然后，我们谈到利用单个矩阵变换一组基底。最终，得出一种绕任意轴旋转实体的方法。

#### 4.2.1欧拉变换

​		这种变换是构造矩阵以将自己（即摄像机）或任何其他的实体定向到某个方向的一种直观方法。它的名字来自伟大的瑞士数学家莱昂哈德·欧拉（Leonhard Euler，1707–1783年）。

​		首先，必须建立某种默认的视图方向。如图4.7所示，它通常沿负z轴放置，头部沿y轴放置。欧拉变换是三个矩阵的乘积，即图中所示的旋转。更正式地说，表示为E的变换由公式4.21给出：

​		
$$
\mathbf{E}(h,p,r)=\mathbf{R}_{z}(r)\mathbf{R}_{x}(p)\mathbf{R}_{y}(h)
\qquad\qquad(4.21)
$$
​		矩阵的顺序可以有24种不同的方式选择[1636]；这可以通过选择矩阵的顺序来实现。我们介绍这种顺序是因为它是常用的。由于$$\mathbf{E}$$是旋转矩阵的级联，因此显然它也是正交的。因此它的逆矩阵可以表示为$$\mathbf{E}^{-1}=\mathbf{E}^{T}=(\mathbf{R}_z\mathbf{R}_x\mathbf{R}_y)^T=\mathbf{R}_y^T\mathbf{R}_x^T\mathbf{R}_z^T$$，所以直接使用$$\mathbf{E} $$的转置矩阵会更容易。

​		欧拉角h，p和r表示按head，pitch和roll的顺序旋转以及绕其各自的轴旋转多少。有时，所有角度都称为“rolls”，例如，我们的“head”为“ y-roll”，我们的“pitch”为“ x-roll”。此外，“head”有时也称为“yaw(偏航)”，例如如在飞行模拟中。

​		这种变换很直观，因此很容易用外行的语言进行讨论。例如，改变head角度会使观察者摇头“不”，改变pitch会使他们点头，而roll则使他们的头向侧面倾斜。而不是谈论围绕x，y和z轴的旋转，我们谈论的是改变head，pitch和roll。请注意，此变换不仅可以定向摄影机，还可以定向任何对象或实体。可以使用世界空间的全局轴或相对于局部参考系执行这些变换。

​		重要的是要注意，一些欧拉角的表示将z轴作为初始向上的方向。这纯粹是一种符号上的差异，尽管可能会造成混淆。在计算机图形学中，在如何看待世界以及如何形成内容方面存在分歧：y向上或z向上。大多数制造工艺（包括3D打印）都认为z方向在世界范围内是向上的。航空和海上交通工具认为-z上升。建筑和GIS通常使用z-up，因为建筑平面图或地图是二维的x和y。与媒体相关的建模系统通常将y方向视为世界坐标上的方向，以匹配我们始终在计算机图形学中描述相机屏幕向上的方向。这两个世界向量选择之间的差异仅相差90°旋转（并且可能是反射），但不知道假定哪个会导致问题。在本书中，除非另有说明，否则我们使用y向上的世界方向。

![image-20191124200627128](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191124200627128.png)

​		<font size=2>图4.7。欧拉变换及其与更改头，俯仰和横滚角的方式之间的关系。显示默认视图方向，沿负z轴看，向上方向沿y轴看。</font>

​		我们还想指出，相机在其视图中的向上方向与世界空间的向上方向没有特别关系。转动头，视野就会倾斜，其视图的向上方向与世界空间的向上方向不同。再举一个例子，假设世界使用y-up，而我们的相机则直视下方的地形，鸟瞰视野。此方向表示相机已向前pitch90°，因此其在世界空间中的向上方向为（0,0，−1）。在这种方向上，相机没有y分量，而是认为-z在世界空间中向上，但根据定义，“ y在上方”在视图空间中仍然适用。

​		欧拉角虽然对较小的角度变化或观察者的方向有用，但有一些严重的限制。很难同时使用两组欧拉角。例如，在一组和另一组之间进行插值并不是简单的对每个角度进行插值。实际上，两组不同的欧拉角可以给出相同的方向，因此任何插值都不应旋转对象。这些是本章稍后讨论的使用其他表示方向的形式（例如四元数）的一些原因。使用欧拉角，您还将遇到称为万向锁的东西，这将在4.2.2节中介绍。

#### 4.2.2从欧拉变换中提取参数

​		在某些情况下，从一个正交矩阵中提取欧拉角所需的参数h，p和r很有用。此过程如公式4.22所示：

​		
$$
\textbf{E}(h,p,r)=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
e_{00} & e_{01} & e_{02} \\
e_{10} & e_{11} & e_{12} \\
e_{20} & e_{21} & e_{22} \\
\end{matrix}
\end{pmatrix}=
\mathbf{R}_{z}(r)\mathbf{R}_{x}(p)(h).
\qquad\qquad(4.22)
\end{gather*}
$$
​		在这里，我们放弃了4×4矩阵而使用3×3矩阵，因为后者提供了旋转矩阵的所有必要信息。也就是说，等效的4×4矩阵的其余部分是始终在其右下位置包含一个零或一个1。

​		将方程式4.22中的三个旋转矩阵连接起来

​		
$$
\textbf{E}=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
\cos r\cos h-\sin r\sin p\sin h & -\sin r\cos p & \cos r\sin h+\sin r\sin p\cos h \\
\sin r\cos h+\cos r\sin p\sin h & \cos r\cos p & \sin r\sin h-\cos r\sin p\cos h  \\
-\cos p\sin h&  \sin  p & \cos  p\cos h \\
\end{matrix}
\end{pmatrix}.
\qquad\qquad(4.23)
\end{gather*}
$$
​		由此可见，pitch参数由sin p = e21给出。同样，将e01除以e11，并类似地将e20除以e22，会产生以下用于提取head和roll参数的方程式：

​		
$$
\frac{e_{01}}{e_{11}}=
\frac{-\sin r}{\cos r}=
-\tan r \quad and \quad
\frac{e_{20}}{e_{22}}=
\frac{-\sin h}{\cos h}=
-\tan h
\qquad\qquad(4.24)
$$
​		因此，如方程式4.25所示，使用函数atan2（y，x）（请参阅第1章第8页）从矩阵E提取欧拉参数h（head），p（pitch）和r（roll）：

​		
$$
\begin{align}
h=&\textbf{atan2}(-e_{20},e_{22}),\\
p=&\textbf{arcsin}(e_{21}),\qquad\qquad(4.25)\\
r=&\textbf{atan2}(-e_{01},e_{11}).
\end{align}
$$
​		但是，有一种特殊情况需要处理。如果cos p = 0，则具有万向锁（第4.2.2节），旋转角度r和h将绕同一轴旋转（尽管可能沿不同的方向，这取决于p旋转角度是-π/ 2还是π/ 2），因此仅需要导出一个角度。如果我们任意设置h = 0 [1769]，我们得到

​		
$$
\textbf{E}=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
\cos r & \sin r\cos p & \sin r\sin p \\
\sin p & \cos r\cos p & -\cos r\sin p \\
0 & \sin p & \cos p \\
\end{matrix}
\end{pmatrix}.
\qquad\qquad(4.26)
\end{gather*}
$$
​		由于p不影响第一列中的值，因此当cosp = 0时，我们可以使用sin r / cos r = tan r = e10 / e00，得出r = atan2（e10，e00）。

​		请注意，根据arcsin的定义，-π/ 2≤p≤π/ 2，这意味着，如果使用该间隔之外的p值创建E，则无法提取原始参数。 h，p和r不是唯一的，这意味着可以使用一组以上的欧拉参数来产生相同的变换。有关欧拉角转换的更多信息，请参见Shoemake的1994年文章[1636]。上面概述的简单方法可能会导致数值不稳定的问题，这可以在速度方面会付出一定的代价来避免[1362]。

​		当您使用欧拉变换时，可能会发生万向锁[499，1633]。这发生在旋转时，并失去了一个自由度。例如，假设转换顺序为x / y / z。考虑仅绕y轴旋转π/ 2，即第二次旋转。这样做会旋转局部z轴以使其与原始x轴对齐，因此围绕z的最终旋转是多余的。

​		在数学上，我们已经在公式4.26中看到了万向锁，其中我们假设cos p = 0，即p =±π/ 2 +2πk，其中k是整数。因为这样的p值，我们损失了一个自由度，因为矩阵仅取决于一个角度r + h或r-h（但不能同时取决于两个角度）。

​		虽然在建模系统中通常以x / y / z顺序表示欧拉角，但绕每个局部轴旋转时，其他顺序也是可行的。例如，动画中使用z / x / y，动画和物理学中都使用z / x / z。这些都是指定三个独立旋转的有效方法。最后的z / x / z顺序在某些应用中可能更好，当因为只有当绕x旋转π弧度（半旋转）时才会出现万向锁。没有完美的顺序可以避免万向锁。尽管如此，但通常还是使用欧拉角，因为动画师更喜欢曲线编辑器来指定角度如何随时间变化[499]。

​		示例：约束变换。想象您拿着一把（虚拟的）扳手紧紧地抓住螺栓。为了将螺栓固定到位，您必须绕x轴旋转扳手。现在假设您的输入设备（鼠标，VR手套，空间球等）为扳手的运动提供了旋转矩阵，即旋转。问题在于，将这种变换应用于扳手可能是错误的，扳手应该仅绕x轴旋转。要将输入变换（称为$$\mathbf{p}$$）限制为绕x轴旋转，只需使用本节中介绍的方法提取欧拉角，h，p和r，然后创建一个新矩阵$$\mathbf{R}_x(p)$$ 。然后，这是一种受欢迎的变换，它将使扳手绕x轴旋转（如果$$\mathbf{p}$$现在包含这样的运动）。

#### 4.2.3矩阵分解

​		到目前为止，我们一直在假设我们知道所使用的转换矩阵的起源和历史的情况下进行工作。通常情况并非如此。例如，无非是将级联矩阵与某个变换后的对象相关联。从级联矩阵中取回各种变换的任务称为矩阵分解。

​		取回一组变换的原因很多。用途包括：

* 仅提取对象的缩放因子。
* 查找特定系统所需的转换。 （例如，某些系统可能不允许使用任意4×4矩阵）
* 确定模型是否仅经历了刚体变换。
* 在动画的关键帧之间进行插值，其中对象仅可用矩阵
* 从旋转矩阵上移除切变。

​		我们已经提出了两种分解方法，分别是为刚体变换导出平移和旋转矩阵（第4.1.6节），以及从正交矩阵导出欧拉角（第4.2.2节）。

​		如我们所见，取回平移矩阵很简单，因为我们只需要4×4矩阵的最后一列中的元素。我们还可以通过检查矩阵的行列式是否为负来确定是否发生了反射。要分离出旋转，缩放和剪切，需要花费更多的精力。

​		幸运的是，有几篇关于该主题的文章以及在线提供的代码。托马斯[1769]和戈德曼[552，553]分别针对各种类型的转换提出了一些不同的方法。 Shoemake [1635]改进了其仿射矩阵的技术，因为他的算法与参考系无关，并尝试分解矩阵以获得刚体变换。

#### 4.2.4绕任意轴旋转

​		有时使实体绕任意轴旋转某个角度会很方便。假设旋转轴$$\mathbf{r}$$已归一化，并且创建一个围绕$$\mathbf{r}$$旋转$$\alpha$$弧度的变换。

​		为此，我们首先变换到一个空间，在这个空间中我们要围绕其旋转的轴是x轴。这通过一个称为$$\mathbf{M}$$的旋转矩阵完成。然后执行实际旋转，然后使用$$\mathbf{M}^{-1} $$变换回去[314]。此过程如图4.8所示。

![image-20191124201220274](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191124201220274.png)

​		<font size=2>图4.8。 通过找到由r，s和t形成的正交法线，可以实现围绕任意轴r的旋转。 然后，我们将此基准与标准基准对齐，以使r与x轴对齐。 在那里绕着x轴旋转，最后我们变回原样.</font>

​		为了计算$$\mathbf{M}$$，我们需要找到两个相互正交的轴同时分别与$$\mathbf{r}$$正交。我们着重于找到第二个旋转轴$$\mathbf{s}$$，了解第三个旋转轴$$\mathbf{t}$$将是第一根轴和第二根轴的叉积，$$\mathbf{t}=\mathbf{r}\times\mathbf{s}$$。一种稳定的数学方法是找到$$\mathbf{r}$$的最小成分（绝对值），并将其设置为0。交换剩余的两个成分，然后取反它们中的第一个（实际上，两个非零成分都可以被否定）。在数学上，这表示为[784]：

​		
$$
\begin{align}
\bar s&=
\begin{cases}
(0,-r_{z},r_{y}),\quad if\quad|r_{x}|\le|r_{y}|\quad and \quad|r_{x}|\le|r_{z}|,\\
(-r_{z},0,r_{x}),\quad if\quad|r_{y}|\le|r_{x}|\quad and \quad|r_{y}|\le|r_{z}|,\\
(-r_{y},r_x,0),\quad if\quad|r_{z}|\le|r_{x}|\quad and \quad|r_{z}|\le|r_{y}|.
\qquad\qquad(4.27)\\
\end{cases}
\\s&=\bar s/||\bar s||,
\\\mathbf{t}&=\mathbf{r}\times \mathbf{s}.
\end{align}
$$
​		这保证$$\mathbf{\bar s}$$与$$\mathbf{r}$$正交（垂直），并且$$(\mathbf{r,s,t})$$是正交的基底。 Frisvad [496]提出了一种在代码中没有任何分支的方法，该方法速度更快，但准确性较低。马克斯[1147]和达夫（Duff）等 [388]提高了Frisvad方法的准确性。无论采用哪种技术，都会使用这三个向量来创建旋转矩阵：

​		
$$
\textbf{M}=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
\mathbf{r}^T \\
\mathbf{s}^T \\
\mathbf{t}^T\\
\end{matrix}
\end{pmatrix}.
\qquad\qquad(4.28)
\end{gather*}
$$
​		该矩阵将向量$$\mathbf{r}$$转换为x轴，将$$\mathbf{s}$$转换为y轴，将$$\mathbf{t}$$转换为z轴。因此，然后围绕归一化的向量$$\mathbf{r}$$旋转α弧度的最终变换为

​		
$$
\mathbf{X}=\mathbf{M}^T\mathbf{R}_x(\alpha)\mathbf{M}
\qquad\qquad(4.29)
$$
​		换句话说，这意味着首先我们进行变换，使$$\mathbf{r}$$为x轴（使用$$\mathbf{M}$$），然后围绕该x轴旋转α弧度（使用$$\mathbf{R}_x(\alpha)$$）），然后使用$$\mathbf{M}$$的逆矩阵进行变换，在这里为$$\mathbf{M}^T$$，因为$$\mathbf{M}$$是正交矩阵。

​		高德曼[550]提出了另一种绕任意归一化轴$$\mathbf{r}$$旋转$$\phi$$弧度的方法。在这里，我们只介绍他的变换：

​		
$$
\textbf{R}=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
\cos\phi+(1+\cos\phi)r_x^2
& (1-\cos\phi)r_xr_y-r_z\sin\phi
&(1-\cos\phi)r_xr_z+r_y\sin\phi
\\
 (1-\cos\phi)r_xr_y+r_z\sin\phi
 & \cos\phi+(1-\cos\phi)r_y^2
 & (1-\cos\phi)r_yr_z-r_x\sin\phi
 \\
 (1-\cos\phi)r_xr_z+r_y\sin\phi
 &(1-\cos\phi)r_yr_z+r_x\sin\phi
 & \cos\phi+(1-\cos\phi)r_z^2
\\
\end{matrix}
\end{pmatrix}.
\qquad\qquad(4.30)
\end{gather*}
$$
​		在第4.3.2节中，我们提出了另一种解决此问题的方法使用四元数。在该部分中还有针对相关问题（例如，从一个向量到另一个向量的旋转）的更有效算法。

### 4.3四元数

​		尽管四元数是威廉·罗恩·汉密尔顿爵士于1843年发明的，它是复数的扩展，但直到1985年，Shoemake [1633]才将它们引入计算机图形学领域。四元数用于表示旋转和方向。它们在几个方面都优于欧拉角和矩阵。任何三维定向都可以表示为围绕特定轴的单个旋转。考虑到该轴和角度表示，四元数的平移或从四元数的平移都是简单的，而在这两者对于欧拉角转换都具有挑战性。四元数可用于稳定和恒定的方向插值，而欧拉角无法很好地完成这些操作。

​	复数具有实部和虚部。每个均由两个实数表示，第二个实数乘以$$\sqrt{-1}$$。同样，四元数有四个部分。前三个值与旋转轴密切相关，旋转角影响所有四个部分（有关更多信息，请参见第4.3.2节）。每个四元数由四个实数表示，每个实数与一个不同的部分相关联。由于四元数具有四个分量，因此我们选择将它们表示为向量，但是为了区分它们，我们在它们上加了一个帽子：$$\hat{\textbf{q}}$$。我们从四元数的一些数学背景开始，然后将其用于构建各种有用的转换。

#### 4.3.1数学背景

​		我们从四元数的定义开始。

​		定义。四元数$$\hat{q}$$可以用以下所有等效的方式定义。

​		
$$
\begin{align}
\hat{\mathbf{q}}&=(\mathbf{q}_v,q_w)=iq_x+jq_y+kq_z+q_w=\mathbf{q}_v+q_w,\\
\mathbf{q}_v&=iq_x+jq_y+kq_z=(q_x,q_y,q_y),\qquad\qquad\qquad\qquad(4.31)
\\
i^2&=j^2=k^2=-1,jk=-kj=i,ki=-ik=j,ij=-ji=k
\end{align}
$$
​		变量$$q_w$$被称为四元数$$\hat{\textbf{q}}$$的实部。虚部为$$\mathbf{\mathbf{q}_v}$$，i，j和k称为虚部。

​		对于虚部$$\mathbf{\mathbf{q}_v}$$，我们可以使用所有向量运算，例如加法，缩放，点积，叉积等等。使用四元数的定义，可以得出两个四元数$$\hat{\textbf{q}}$$和$$\hat{\textbf{r}}$$之间的乘法运算，如下所示。注意，虚部的乘法是不可交换的。

​		
$$
\begin{align}
乘法:\mathbf{\hat{q}\hat{r}}&=(iq_x+jq_y+kq_z+q_w)(ir_x+jr_y+kr_z+r_w)\\
&=i(q_yr_z-q_zr_y)+r_wq_x+q_wr_x)
\\&+j(q_zr_x-q_xr_z+r_wq_y+q_wr_y)\qquad\qquad(4.32)
\\&+k(q_xr_y-q_yr_x+r_wq_z+q_wr_z)
\\&+q_wr_w-q_xr_x-q_yr_y-q_zr_z
\\=&(\mathbf{q}_v\times\mathbf{r}_v+r_w\mathbf{q}_v+q_w\mathbf{r}_v,
q_wr_w-\mathbf{q}_v\cdot\mathbf{r}_v).
\end{align}
$$
​		从该方程式可以看出，我们使用叉积和点积来计算两个四元数的乘法。

​		除了四元数的定义外，还需要加法，共轭，归一化和单位四元数的定义：

​		
$$
\begin{align}
&加法:\hat{\mathbf{q}}+\hat{\mathbf{r}}=
(\mathbf{q}_v,q_w)+(\mathbf{r}_v,r_w)=
(\mathbf{q}_v+\mathbf{r}_v,q_w+r_w).\\
&共轭：\mathbf{\hat{q}}^*=(\mathbf{q}_v,q_w)^*=(-\mathbf{q}_v,q_w).\\
&模：n(\mathbf{\hat{q}})=\sqrt{\hat{\mathbf{q}}^*\hat{\mathbf{q}}}
=\sqrt{\hat{\mathbf{q}}\hat{\mathbf{q}}^*}
=\sqrt{\mathbf{q}_v\cdot\mathbf{q}_v+q_w^2}\qquad\qquad(4.33)\\
&\qquad\qquad\quad=\sqrt{q_x^2+q_y^2+q_z^2+q_w^2}.\\
&单位四元数:\mathbf{\hat{i}}=(\textbf 0,1)
\end{align}
$$
​		当简化$$n(\mathbf{\hat{q}})=\sqrt{\hat{\mathbf{q}}^*\hat{\mathbf{q}}}$$时（如上所示），虚部将抵消，仅保留实部。规范有时表示为$$||\hat{\textbf{q}}||=n(\mathbf{\hat{q}})$$[1105]。通过上面的结果，可以得出由$$\hat{\textbf{q}}^{-1}$$表示的乘法逆运算。方程$$\hat{\mathbf{q}}^{-1}\hat{\mathbf{q}}=\hat{\mathbf{q}}\hat{\mathbf{q}}^{-1}=1$$对于逆计算必须成立（对于乘法逆运算来说是常见的）。我们从规范的定义中得出一个公式：

​		
$$
n(\mathbf{\hat{q}})^2=
\mathbf{\hat{q}\hat{q}^*}
\Longleftrightarrow
\frac{\mathbf{\hat{q}\hat{q}^*}}{n(\mathbf{\hat{q}})^2}=1
\qquad\qquad(4.34)
$$
​		这给出了乘法逆运算，如下所示：

​		
$$
逆运算：
\mathbf{\hat{q}}^{-1}=
\frac{1}{n(\mathbf{\hat{q}})^2}\mathbf{\hat{q}}^*.
\qquad\qquad(4.35)
$$
​		逆计算公式使用标量乘法，它是从公式4.31中的乘法得出的：$$s\hat{\textbf{q}}=(\textbf{0},s)(\textbf{q}_v,q_w)=(s\textbf{q}_v,sq_w)$$和$$\hat{\textbf{q}}s=(\textbf{q}_v,q_w)(\text{0},s)=(s\textbf{q}_v,sq_w)$$，这意味着标量乘法是可交换的：$$s\hat{\textbf{q}}=\hat{\textbf{q}}s=(s\hat{\textbf{q}}_v,sq_w)$$。

​		以下规则很容易从定义中得出：

$$
\begin{align}
共轭规则：\qquad
(\hat{\mathbf{q}})^*=&\hat{\mathbf{q}},\\
(\hat{\mathbf{q}}+\hat{\mathbf{r}})^*=&\hat{\mathbf{q}}^*+\hat{\mathbf{r}}^*,
\qquad\qquad(4.36)\\
(\hat{\mathbf{q}}\hat{\mathbf{r}})^*=&\hat{\mathbf{r}}^*\hat{\mathbf{q}}^*.
\end{align}
$$

$$
\begin{align}
模规则：\qquad
n(\hat{\mathbf{q}}^*)=&n(\hat{\mathbf{q}}),\\
n(\hat{\mathbf{q}}\hat{\mathbf{r}})=&n(\hat{\mathbf{q}})n(\hat{\mathbf{r}}).
\qquad\qquad(4.37)
\end{align}
$$

​		乘法定律：
$$
\begin{align}
线性:\qquad
\hat{\mathbf{p}}(s\hat{\mathbf{q}}+t\hat{\mathbf{r}})=&
s\hat{\mathbf{p}}\hat{\mathbf{q}}+t\hat{\mathbf{p}}\hat{\mathbf{r}},
\\
(s\hat{\mathbf{p}}+t\hat{\mathbf{q}})\hat{\mathbf{r}}=&
s\hat{\mathbf{q}}\hat{\mathbf{r}}+t\hat{\mathbf{q}}\hat{\mathbf{r}}.
\qquad\qquad(4.38)
\end{align}
$$

​		
$$
结合律:\qquad
\hat{\mathbf{p}}(\hat{\mathbf{q}}\hat{\mathbf{r}})=
(\hat{\mathbf{p}}\hat{\mathbf{q}})\hat{\mathbf{r}}
$$

​		使得$$n(\hat{\textbf{q}})=1$$的单位四元数$$\hat{\textbf{q}}=(\textbf{q}_v,q_w)$$。由此可以得出$$\hat{\textbf{q}} $$可写为
$$
\hat{\mathbf{q}}=(\sin\phi\mathbf{u}_q,\cos\phi)=
\sin\phi\mathbf{u}_q+\cos\phi,
\qquad\qquad(4.39)
$$

​		对于某些三维向量$$\textbf{u}_q$$，使得$$||\textbf{u}_q||=1$$，因为
$$
\begin{align}
n(\hat{\mathbf{q}})&=n(\sin\phi\mathbf{u}_q,\cos\phi)=
\sqrt{\sin^2\phi(\mathbf{u}_q\cdot\mathbf{u}_q)+\cos^2\phi}\\
&=\sqrt{\sin^2\phi+\cos^2\phi}=1
\qquad\qquad(4.40)
\end{align}
$$

​		当且仅当$$\textbf{u}_q\cdot\textbf{u}_q=1=||\textbf{u}_q||^2$$。 正如在下一节中将看到的，单位四元数非常适合以最有效的方式创建旋转和方向。 但在那之前，需要介绍一些关于单元四元数额外的操作。

​		对于复数，可以将二维单位向量写为$$\cos\phi+i\sin\phi=e^{i\phi}$$。 四元数的等效形式是
$$
\hat{\mathbf{q}}=\sin\phi\mathbf{u}_q+
\cos\phi=e^{\phi\mathbf{u}_q}.
\qquad\qquad(4.41)
$$

​		单位四元数的对数和幂函数来自公式4.41：
$$
\begin{align}
对数函数：
&\log(\hat{\mathbf{q}})=\log(e^{\phi\mathbf{u}_q})=\phi\mathbf{u}_q,
\\
幂函数：
&\hat{\mathbf{q}}^t=(\sin\phi\mathbf{u}_q+\cos\phi)^t=
e^{\phi t\mathbf{u}_q}=\sin(\phi t)\mathbf{u}_q+\cos(\phi t).
\qquad\qquad(4.42)
\end{align}
$$

​			![image-20191124201313125](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191124201313125.png)

​	        <font size=2>图4.9。 由单位四元数$\hat{\textbf{q}}=(\sin\phi\textbf{u}_q,\cos\phi)$表示的旋转变换的图示。 变换围绕轴$\textbf{u}_q$旋转$2\phi$弧度。</font>

#### 4.3.2 四元数变换

​		现在，我们将研究四元数集的子类，即单位长度的子类，称为单位四元数。 关于单位四元数的最重要事实是，它们可以表示任何三维旋转，并且这种表示极其紧凑和简单。

​		现在，我们将说明使单元四元数对旋转和定向如此有用的原因。 首先，将点或向量$$\textbf{p}=(p_x,p_y,p_z,p_w)^T$$的四个坐标分量放入四元数$$\hat{\textbf{p}}$$的四个分量中，并假设我们有一个单位四元数$$\hat{\textbf{q}}=(\sin\phi\textbf{u}_q,\cos\phi)$$。 可以证明
$$
\hat{\mathbf{q}}
\hat{\mathbf{p}}\hat{\mathbf{q}}^{-1}
\qquad\qquad(4.43)
$$

绕轴$$\textbf{u}_q$$旋转$$\hat{\textbf{p}}$$（并因此旋转点p）一个角度2$$\phi$$。 注意，由于$$\hat{\textbf{q}}$$是单位四元数，因此$$\hat{\textbf{q}}^{-1}=\hat{\textbf{q}}^*$$ 。 见图4.9。

​		$$\hat{\textbf{q}}$$的任何非零实数倍也表示相同的变换，这意味着$$\hat{\textbf{q}}$$和$$-\hat{\textbf{q}}$$表示相同的旋转。 也就是说，取反轴$$\textbf{u}_q$$和实部$$q_w$$，将创建一个四元数，该四元数的旋转与原始四元数的旋转完全相同。 这也意味着从矩阵中提取四元数可以返回$$\hat{\textbf{q}}$$或$$ -\hat{\textbf{q}}$$。

​		给定两个单位四元数$$\hat{\textbf{q}}$$和$$\hat{\textbf{r}}$$，首先将$$\hat{\textbf{q}}$$然后$$\hat{\textbf{r}}$$应用于四元数$$ \hat{\textbf{p}}$$（可以作为点p被插值）的级联公式由4.44给出：
$$
\hat{\mathbf{r}}(\hat{\mathbf{q}}\hat{\mathbf{p}}\hat{\mathbf{q}}^*)\hat{\mathbf{r}}^*=
(\hat{\mathbf{r}}\hat{\mathbf{q}})\hat{\mathbf{p}}
(\hat{\mathbf{r}}\hat{\mathbf{q}})^*=
\hat{\mathbf{c}}\hat{\mathbf{p}}\hat{\mathbf{c}}^*.
\qquad\qquad(4.44)
$$

​		在此，$$\hat{\textbf{c}}=\hat{\textbf{r}}\hat{\textbf{q}}$$ 是表示单元四元数$$\hat{\textbf{q}}$$和$$ \hat{\textbf{r}}$$的级联的单元四元数。

矩阵转换：

​		由于经常需要组合几种不同的变换，并且大多数变换都是矩阵形式，因此需要一种将公式4.43转换为矩阵的方法。 四元数$$\hat{\textbf{q}}$$可以转换成矩阵$$\textbf{M}^q$$，如公式4.45 [1633，1634]所示：
$$
\textbf{M}^q=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
1-s(q_y^2+q_z^2)
& s(q_xq_z+q_wq_z)
&s(q_xq_z+q_wq_y)&0
\\
s(q_xq_y+q_wq_z)
 & 1-s(q_x^2+q_z^2)
 & s(q_yq_z-q_wq_x) &0
 \\
 s(q_xq_z-q_wq_y)
 &s(q_yq_z+q_wq_x)
 & 1-s(q_x^2+q_y^2) &0
\\
0&0&0&1
\end{matrix}
\end{pmatrix}.
\qquad\qquad(4.45)
\end{gather*}
$$
​		在此，系数$$s=2/(n(\hat{\text{q}}))^2$$。 对于单元四元数，这简化为
$$
\textbf{M}^q=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
1-2(q_y^2+q_z^2)
& 2(q_xq_z+q_wq_z)
&2(q_xq_z+q_wq_y)&0
\\
2(q_xq_y+q_wq_z)
 & 1-2(q_x^2+q_z^2)
 & 2(q_yq_z-q_wq_x) &0
 \\
 2(q_xq_z-q_wq_y)
 &2(q_yq_z+q_wq_x)
 & 1-2(q_x^2+q_y^2) &0
\\
0&0&0&1
\end{matrix}
\end{pmatrix}.
\qquad\qquad(4.46)
\end{gather*}
$$
一旦构建了四元数，就无需计算三角函数，因此转换处理实际上是有效率的。

​		从正交矩阵$$ \textbf{M}^q$$到单位四元数$$\hat{\textbf{q}}$$的反向转换要复杂得多。 此过程的关键是公式4.46中的矩阵存在以下差异：
$$
\begin{align}
m_{21}^q-m_{12}^q&=4q_wq_x,\\
m_{02}^q-m_{20}^q&=4q_wq_y,\qquad\qquad(4.47) \\
m_{10}^q-m_{01}^q&=4q_wq_z,\\
\end{align}
$$
​		这些等式的含义是，如果$$q_w$$是已知的，则可以计算向量$$\textbf{v}_q$$的值，从而得出$$\hat{\textbf{q}}$$。 $$ \textbf{M}^q$$的trace由下式计算
$$
\begin{align}
tr(\textbf{M}^q)&=
4-2s(q_x^2+q_y^2+q_z^2)=
\left(1-\frac{q_x^2+q_y^2+q_z^2}{q_x^2+q_y^2+q_z^2+q_w^2}\right)\\
&=\frac{4q_w^2}{q_x^2+q_y^2+q_z^2+q_w^2}=\frac{4q_w^2}{(n(\hat{\text{q}}))^2}
\qquad\qquad(4.48)
\end{align}
$$
​		此结果将对单位四元数产生以下转换：
$$
\begin{align}
q_w &= \frac{1}{2}\sqrt{tr(\textbf{M}^q)},\qquad\qquad
q_x=\frac{m_{21}^q-m_{12}^q}{4q_w},\\
q_y &=\frac{m_{02}^q-m_{20}^q}{4q_w},\qquad\qquad
q_z=\frac{m_{10}^q-m_{01}^q}{4q_w}. \qquad\qquad(4.49)\\
\end{align}
$$
​		为了运行时具有数值稳定[1634]，应避免小数除法。 因此，首先设置$$t=q_w^2-q_x^2-q_y^2-q_z^2$$，由此得出：
$$
\begin{align}
m_{00}&=t+2q_x^2,\\
m_{11}&=t+2q_y^2,\\
m_{22}&=t+2q_z^2,\\
u&=m_{00}+m_{11}+m_{22}=t+2q_w^2,\qquad\qquad(4.50)
\end{align}
$$
​		这又意味着$$m_{00},m_{11},m_{22},u$$中的最大值决定了$$q_x,q_y,q_z,q_w$$中的哪个最大。 如果$$q_w$$最大，则使用公式4.49推导四元数。 否则，我们注意到以下情况成立：
$$
\begin{align}
4q_x^2&=+m{00}-m_{11}-m_{22}+m_{33},\\
4q_y^2&=-m{00}+m_{11}-m_{22}+m_{33},\\
4q_z^2&=-m{00}-m_{11}+m_{22}+m_{33},\\
4q_w^2&=tr(\textbf{M}^q).\qquad\qquad(4.51)
\end{align}
$$
​		然后，使用上述方程式的适当公式来计算$$q_x,q_y,q_z$$中的最大值，然后使用公式4.47计算$$\hat{{\textbf{q}}}$$的其余分量。 舒勒[1588]提出了一种无分支但使用四个平方根的变量。

球面线性插值：

​		球面线性插值是在给定两个单位四元数$$\hat{{\textbf{q}}}$$和$$\hat{{\textbf{r}}}$$以及参数$$t\in[0,1]$$的情况下计算插值四元数的运算。 例如，这对于动画对象很有用。 插值相机方向时，它的用处不大，因为插值时相机的“上”矢量可能会倾斜，通常会产生干扰。

​		此运算的代数形式由复合四元数$$\hat{{\textbf{s}}}$$表示，如下所示：
$$
\hat{\textbf{s}}(\hat{\textbf{q}},\hat{\textbf{r}},t)=
(\hat{\textbf{r}}\hat{\textbf{q}}^{-1})^t\hat{\textbf{q}}
\qquad\qquad(4.52)
$$
​		但是，对于软件实现，以下形式更合适：slerp代表球面线性插值：
$$
\hat{\textbf{s}}(\hat{\textbf{q}},\hat{\textbf{r}},t)=
\text{slerp}(\hat{\textbf{q}},\hat{\textbf{r}},t)=
\frac{\sin(\phi(1-t))}{\sin\phi}\hat{\textbf{q}}+
\frac{\sin(\phi t)}{\sin\phi}\hat{\textbf{r}}.
\qquad\qquad(4.53)
$$
​		为了计算该方程式所需的$$\phi$$，可以使用以下公式：$$\cos\phi=q_xr_x+q_yr_y+q_zr_z+q_wr_w$$ [325]。 对于$$ t\in[0,1]$$，slerp函数（用于计算（当且仅当$$\hat{{\textbf{q}}}$$和$$ \hat{{\textbf{r}}}$$不相反）插值四元数），它们共同构成从$$\hat{{\textbf{q}}}(t=0)$$到$$\hat{{\textbf{r}}}(t=1)$$的四维单位球面上的最短弧。 圆弧位于，由$$ \hat{{\textbf{q}}}$$和$$ \hat{{\textbf{r}}}$$得到平面，与原点，与四维单位球面的交点形成的圆上。 如图4.10所示。 计算出的旋转四元数以固定速度绕固定轴旋转。 这样的曲线，具有恒定的速度，因此加速度为零，称为测地曲线(geodesic curve )[229]。 球体上的大圆是通过原点和球体的平面相交而生成的，这种圆的一部分称为大圆弧。

​		slerp函数非常适合在两个方向之间进行插值，并且表现良好（固定轴，恒定速度）。 使用多个欧拉角插值时则不是这种情况。 在实践中，直接计算slerp是涉及调用三角函数的昂贵操作。 Malyshau [1114]讨论了将四元数集成到渲染管线中的问题。 他指出，如果不使用slerp而是简单地在像素着色器中对四元数进行归一化，则90度角的三角形取向误差最大为4度。 光栅化三角形时，此错误率可以接受。 Li [1039，1040]提供了更快的增量方法来计算不牺牲任何准确性的slerps。 Eberly [406]提出了一种仅使用加法和乘法来计算slerp的技术。

​		当方向大于两个时，说$$ \hat{{\textbf{q}}}_0,\hat{{\textbf{q}}}_1,……\hat{{\textbf{q}}}_{n-1}$$可用，我们想从$$\hat{{\textbf{q}}}_0$$到$$\hat{{\textbf{q}}}_1$$再到$$\hat{{\textbf{q}}}_2$$进行插值，依此类推，直到$$\hat{{\textbf{q}}}_{n-1}$$，slerp直接以简单的方式使用。 现在，当我们说$$\hat{{\textbf{q}}}_i$$时，我们将使用$$\hat{{\textbf{q}}}_{i-1}$$和$$ \hat{{\textbf{q}}}_i$$作为slerp的参数。 通过$$\hat{{\textbf{q}}}_i$$之后，我们将使用$$\hat{{\textbf{q}}}_i$$和$$\hat{{\textbf{q}}}_{i+1}$$作为slerp的参数。 这将导致突然的扭动出现在方向插值中，如图4.10所示。 这类似于点被线性插值时发生的情况。 请参阅第720页的图17.3的右上部分。某些读者在阅读了第17章中的样条后，可能希望重新阅读以下段落。

![image-20191124201353335](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191124201353335.png)

​		<font size=2>图4.10。 单位四元数表示为单位球面上的点。 函数slerp用于在四元数之间进行插值，并且插值路径是球面上的大圆弧。 请注意，从$\hat{{\textbf{q}}}_1$到$\hat{{\textbf{q}}}_2$进行插值，以及从$\hat{{\textbf{q}}}_1$到$\hat{{\textbf{q}}}_3$到$\hat{{\textbf{q}}}_2$进行插值，即使它们到达相同的方向，但也不一样。</font>

​		一种更好的插值方法是使用某种样条线。 我们在$$ \hat{{\textbf{q}}}_i$$和$$ \hat{{\textbf{q}}}_{i+1}$$之间引入四元数$$\hat{{\textbf{a}}}_i$$和$$\hat{{\textbf{a}}}_{i+1}$$。 可以在四元数$$ \hat{{\textbf{q}}}_i, \hat{{\textbf{q}}}_{i+1},\hat{{\textbf{a}}}_i,\hat{{\textbf{a}}}_{i+1}$$的集合内定义球形三次插值。 令人惊讶的是，这些额外的四元数的计算如下[404] 3所示：
$$
\hat{\textbf{a}}_i=\hat{\textbf{q}}_i\exp
\left[-\frac{\log(\hat{\textbf{q}}_i^{-1}\hat{\textbf{q}}_{i-1})
+\log(\hat{\textbf{q}}_i^{-1}\hat{\textbf{q}}_{i+1})}
{4}
\right]
.\qquad\qquad(4.54)
$$
​		$$ \hat{{\textbf{q}}}_i$$和$$ \hat{{\textbf{a}}}_i$$将用于使用了平滑三次样条的球面插值四元数，如公式4.55所示：
$$
\begin{align}
\text{squad}(\hat{\textbf{q}}_i,\hat{\textbf{q}}_{i+1},\hat{\textbf{a}}_i,\hat{\textbf{a}}_{i+1},t)&=
\\ \text{slerp}(\text{slerp}(\hat{\textbf{q}}_i,\hat{\textbf{q}}_{i+1},t)&,
\text{slerp}(\hat{\textbf{a}}_i,\hat{\textbf{a}}_{i+1},t),2t(1-t)).
\end{align}
\qquad\qquad(4.55)
$$
​		如上所示，squad 函数是通过使用slerp的重复球面插值法构建的（有关点的重复线性插值，请参见第17.1.1节）。 插值将通过初始方向$$\hat{\textbf{q}}_i,i\in[0,……,n-1]$$，但不是通过$$\hat{{\textbf{a}}}_i$$，这些用来表示初始位置处的切线方向。

从一个向量旋转到另一个向量：

​		常见的操作是通过最短路径从一个方向$\textbf{s}$转换到另一个方向$\textbf{t}$。 四元数数学极大地简化了此过程，并显示了四元数与该表示形式的密切关系。首先，对$\textbf{s}$和$\textbf{t}$进行归一化。 然后计算单位旋转轴$\textbf{u}$，其计算公式为$$\textbf{u}=(\textbf{s}\times\textbf{t})/||\textbf{s}\times\textbf{t}||$$。 接下来，$$e=\textbf{s}\cdot\textbf{t}=\cos(2\phi)$$和$$||\textbf{s}\times\textbf{t}||=\sin(2\phi)$$，其中2$\phi$是$\textbf{s}$和$\textbf{t}$之间的角度。 那么表示从$\textbf{s}$到$\textbf{t}$旋转的四元数为$$\hat{\textbf{q}}=(\sin\phi\textbf{u},\cos\phi)$$。 实际上，使用半角关系和三角恒等式化简得到$$\hat{\textbf{q}}=(\frac{\sin\phi}{\sin2\phi}(\textbf{s}\times\textbf{t}),\cos\phi)$$[1197]
$$
\hat{\textbf{q}}=(\textbf{q}_v,q_w)=
\left(
\frac{1}{\sqrt{2(1+e)}}(\textbf{s}\times\textbf{t}),\frac{\sqrt{2(1+e)}}{2}
\right).\qquad\qquad(4.56)
$$
​		当$\textbf{s}$和$\textbf{t}$指向几乎相同的方向时，以这种方式直接生成四元数（相对于$$\textbf{s}\times\textbf{t}$$的叉乘结果的归一化）可以避免数值不稳定[1197]。 当$\textbf{s}$和$\textbf{t}$指向相反的方向时，这两种方法都会出现稳定性问题，因为它们会除以零。 当检测到这种特殊情况时，可以使用任何垂直于$\textbf{s}$的旋转轴旋转到$\textbf{t}$。

​		有时我们需要从$\textbf{s}$到$ \textbf{t}$旋转的矩阵表示。 在对公式4.46进行一些代数和三角数学简化之后，旋转矩阵变为[1233]
$$
\textbf{R}(\textbf{s},\textbf{t})=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
e+hv_x^2
& hv_xv_y-v_z
&hv_xv_z+v_y&0
\\
hv_xv_y+v_z
 & e+hv_y^2
 & hv_yv_z-v_x &0
 \\
 hv_xv_z-v_y
 &hy_zv_z-v_x
 & e+hv_z^2 &0
\\
0&0&0&1
\end{matrix}
\end{pmatrix}.
\qquad\qquad(4.57)
\end{gather*}
$$
​		在此方程式中，我们使用了以下中间计算：
$$
\begin{align}
\textbf{v}&=\textbf{s}\times\textbf{t},\\
e&=\cos(2\phi)=\textbf{s}\cdot\textbf{t},\\
h&=\frac{1-\cos(2\phi)}{\sin^2(2\phi)}=\frac{1-e}{\textbf{v}\cdot\textbf{v}}=
\frac{1}{1+e}.
\qquad\qquad(4.58)
\end{align}
$$
​		可以看出，由于简化，所有平方根和三角函数都消失了，因此这是创建矩阵的有效方法。 请注意，公式4.57的结构类似于公式4.30的结构，并请注意，后一种形式不需要三角函数。

​		注意，当$\textbf{s}$和$ \textbf{t}$平行或接近平行时必须小心，因为$$||\textbf{s}\times\textbf{t}||\approx0$$。如果$$\phi \approx0$$，那么我们可以返回单位矩阵。 但是，如果$$2\phi\approx\pi$$，那么我们可以绕任何轴旋转π弧度。 该轴可以使用$\textbf{s}$与不平行于$ \textbf{s}$的任何其他向量之间的叉积找到（第4.2.4节）。 Moller和Hughes使用Householder矩阵以不同的方式处理这种特殊情况[1233]。

### 4.4顶点混合

​		想象一下，数字角色的手臂使用前臂和上臂两部分进行动画处理，如图4.11左侧所示。 该模型可以使用刚体变换进行动画处理（第4.1.6节）。 但是，这两个部分之间的接头将不会像真正的肘部。 这是因为使用了两个单独的对象，因此，关节由来自这两个单独的对象的重叠部分组成。 显然，最好只使用一个对象。 但是，静态模型零件无法解决使关节具有柔性的问题。

​		顶点混合是解决此问题的一种流行方法[1037，1903]。 该技术还有其他几个名称，例如线性混合蒙皮，骨架子空间网格变形。 虽然此处介绍的算法的起源尚不清楚，但定义骨骼并让皮肤对变化做出反应是计算机动画中的一个古老概念[1100]。 在最简单的形式中，前臂和上臂像和以前一样分别进行动画处理，但是在关节处，这两个部分通过一个弹性的“皮肤”相连。因此，该弹性部分将具有两组顶点，一组顶点由前臂矩阵进行变换，另一组顶点由上臂矩阵进行变换。 与每个三角形使用单个矩阵相比，这将导致三角形的顶点可以通过不同的矩阵进行变换。 见图4.11。

![image-20191124201419581](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191124201419581.png)

​		<font size=2>图4.11。 手臂由前臂和上臂组成，两个独立的对象进行动画处理使用刚体变换，在左侧。 肘部没有真实的出现。 在右侧，对一个对象使用顶点混合。 最右边的手臂说明了当单一的皮肤将两个部分直接覆盖以覆盖肘部时发生的情况。 最右边的手臂说明了使用顶点混合时发生的情况，并且某些顶点以不同的权重进行了混合：（2/3，1/3），表示顶点从上臂的变换获得的权重为2/3，从前臂获得的变换权重为1/3。 该图在最右边的插图中还显示了顶点混合的缺点。 在这里，可以看到肘部内部的折叠。 使用更多的骨骼和更精心选择重量可以达到更好的效果。</font>

​		进一步执行这一步骤，使单个顶点通过几种不同的矩阵进行变换，并将得到的位置加权并混合在一起。 这是通过为动画对象设置骨骼骨架来完成的，其中每个骨骼的变换可能会通过用户定义的权重影响每个顶点。 由于整个手臂可能是“弹性的”，即所有顶点可能受到不仅一个以上矩阵的影响，因此整个网格通常被称为皮肤（在骨骼上）。 见图4.12。 许多商业建模系统具有相同类型的骨骼骨架建模功能。 尽管名称如此，骨骼并不一定必须是刚性的。 例如，Mohr和Gleicher [1230]提出了添加附加关节以实现诸如肌肉膨胀等效果的想法。 James和Twigg [813]讨论了使用可以挤压和拉伸的骨骼动画蒙皮。

![image-20191124231139634](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191124231139634.png)

​		<font size=2>图4.12。 顶点融合的真实示例。 左上方的图像显示了处于伸展位置的手臂的两根骨骼。 在右上角显示了网格，并用颜色表示骨骼拥有的每个顶点。 底部：手臂的阴影网格在稍有不同的位置。 （图片由Je Lander [968]提供。）</font>

​		在数学上，这用公式4.59表示，其中$$\textbf{p}$$是原始顶点，$$\textbf{u}(t)$$是变换的顶点，其位置取决于时间t：
$$
\textbf{u}(t)=
\sum^{n-1}_{i=0}w_i\textbf{B}_i(t)\textbf{M}_i^{-1}\textbf{p},
\quad where \sum^{n-1}_{i=0}w_i=1,
\quad w_i\geq0.
\qquad\qquad(4.59)
$$
​		有n个骨骼会影响$$\textbf{p} $$的位置，这表示在世界坐标中。 顶点$$\textbf{p} $$的骨骼$$i$$的权重是值$$w_i$$。 矩阵$$\mathbf{M}_i$$变换初始骨骼的坐标系转换到世界坐标。 通常，骨骼的控制关节位于其坐标系的原点。 例如，前臂骨骼将其肘关节移动到原点，而动画旋转矩阵将手臂的这一部分绕关节移动。 矩阵$$\mathbf{B}_i(t)$$是第i个骨骼的世界变换，会随时间变化对对象进行动画处理，并且通常是多个矩阵的级联，例如之前的骨骼变换的层次结构和局部动画矩阵。

​		Woodland [1903]深入讨论了一种维护和更新$$\mathbf{B}_i(t)$$矩阵动画函数的方法。 每个骨骼都将一个顶点转换到相对于其自身参照系的位置，而且最终位置是从一组计算点插值得到。 矩阵$$\mathbf{M}_i$$在某些蒙皮讨论中未明确表示，而是被视为$$\mathbf{B}_i(t)$$矩阵的一部分。 我们在这里介绍它是因为它是有用的矩阵，而且总是矩阵级联结构的一部分。

​		在实践中，对于动画的每一帧，每个骨骼连接矩阵$$\mathbf{B}_i(t)$$和$$\mathbf{M}_i^{-1}$$，并且每一个结果矩阵都用于变换顶点。 顶点$$\textbf{p} $$由不同骨骼的级联矩阵变换，然后使用权重$$w_i$$进行混合，因此称为顶点混合。 权重是非负的并且总和为1，因此发生的事情是将顶点转换到几个位置，然后在其中进行插值。 这样，对于所有$$i=0...n-1$$（固定），变换后的点$$\mathbf{u}$$将位于点集$$\mathbf{B}_i(t)\mathbf{M}_i^{-1}\mathbf{p}$$的凸包中。 通常使用公式4.59转换法线。 根据所使用的变换（例如，如果骨骼被拉伸或挤压得相当大），如第4.1.7节所述，可能需要$$\mathbf{B}_i(t)\mathbf{M}_i^{-1}$$逆矩阵的转置。

​		顶点混合非常适合在GPU上使用。 网格中的顶点集可以放置在静态缓冲区中，该缓冲区一次发送到GPU并被重新使用。 在每帧中，只有骨骼矩阵会发生变化，而顶点着色器会计算它们对存储的网格的影响。 这样，可以最大程度地减少在CPU上处理和从CPU传输的数据量，从而使GPU高效地渲染网格。 如果模型的整个骨骼矩阵可以一起使用，则是最简单的。 否则，必须拆分模型并复制一些骨骼。 或者，可以将骨骼变换存储在顶点访问的纹理中，从而避免达到寄存器存储限制。每个变换可以仅存储在两个纹理中，通过使用四元数表示旋转[1639]。 如果可用，无序访问视图存储将允许重新使用蒙皮结果[146]。

​		可以指定超出[0,1]范围或不等于1的权重集。 但是，这仅在使用某些其他混合算法（例如渐变目标（4.5节））时才有意义。

​		基本顶点融合的一个缺点是可能会发生不必要的折叠，扭曲和自交[1037]。见图4.13。更好的解决方案是使用双四元数[872，873]。这种执行蒙皮的技术有助于保持原始变换的刚性，因此避免了四肢的“糖果包裹”扭曲。计算成本不到线性蒙皮混合的成本的1.5倍，并且效果很好，这导致该技术的快速被采用。但是，双四元数蒙皮会导致鼓起效果，Le 和 Hodgins [1001]提出了旋转中心蒙皮作为更好的选择。他们基于这样的假设：局部变换应该是刚体，并且具有相似权重$$\mathbf{M}_i$$的顶点应该具有相似的变换。预先为每个顶点计算旋转中心，同时施加正交（刚体）约束以防止肘关节塌陷和糖果包装纸扭曲的现象。在运行时，该算法类似于线性混合蒙皮，因为GPU在旋转中心执行执行线性混合蒙皮，随后执行四元数混合步骤。

![image-20191124230557239](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191124230557239.png)

![image-20191124230616070](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191124230616070.png)

​		<font size=2>图4.13。 左侧显示了使用线性混合蒙皮时关节处的问题。 在右侧，使用双四元数混合可以改善外观。 （图片由Ladislav Kavan等人提供，Paul Steed [1693]为其模型。）</font>

### 4.5渐变

​		在播放动画时，把一个三维模型渐变到另一个三维模型通常会很有用[28、883、1000、1005]。 假设一个模型在时间$t_0$显示，我们希望它在时间$t_1$渐变到另一种模型。 对于所有介于$t_0$和$t_1$之间的时间，都可以使用某种插值方法获得连续的“混合”模型。 渐变的一个例子如图4.14所示。

![image-20191125224157334](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191125224157334.png)

​		<font size=2>图4.14。 顶点渐变。 每个顶点都定义了两个位置和法线。 在每帧中，中间时刻的位置和法线由顶点着色器线性插值得到。 （图片由NVIDIA Corporation提供。）</font>

​		渐变涉及解决两个主要问题，即顶点对应问题和插值问题。 给定两个任意模型，这些模型可能具有不同的拓扑，不同的顶点数量和不同的网格连接性，通常必须从建立这些顶点对应关系开始。 这是一个困难的问题，并且在该领域已经进行了很多研究。 我们推荐感兴趣的读者阅读Alexa的调查[28]。

​		但是，如果两个模型之间已经存在一对一的顶点对应关系，则可以在基于每个顶点进行插值。 也就是说，对于第一个模型中的每个顶点，在第二个模型中必须仅存在一个顶点与之对应，反之亦然。 这使插值变得容易。 例如，线性插值可以直接在顶点上使用（有关插值的其他方法，请参见第17.1节）。 为了计算时间$t_1\in[t_0,t_1]$的变形顶点，我们首先计算$s=(t-t_0)/(t_1-t_0)$），然后线性顶点混合，
$$
\textbf{m}=(1-s)\textbf{p}_0+s\textbf{p}_1,
\qquad\qquad(4.60)
$$
其中$p_0$和$p_1$对应于相同的顶点，但在不同的时间$t_0$和$t_1$。

​		渐变的变种，其让用户拥有更直观控制被称为渐变目标或混合形状[907]。 基本思想可以使用图4.15进行解释。

![image-20191125224306960](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191125224306960.png)

​		<font size=2>图4.15。 给定两个嘴部姿势，计算一组差异向量的集合以控制插值，甚至控制外推。 在渐变目标中，差异向量用于将运动“添加”到中性脸部上。 对差向量使用正权重时，我们会露出笑容，而负权重会产生相反的效果。</font>

​		我们从一个中性模型开始，在这种情况下，它是一张脸。 让我们用N表示该模型。此外，我们还有一组不同的脸部姿势。 在此处的说明中，只有一个脸部姿势，一张笑脸。 通常，我们可以允许k≥1个不同的姿势，表示为$P_i,i\in[1,...,k]$。 作为预处理，“不同的脸”的计算公式为：$D_i=P_i-N$，即，从每个脸部姿势中减去中性模型。

​		在这一点上，我们有一个中立模型N和一组差异姿势$D_i$。 然后可以使用以下公式获得变形模型M：
$$
M = N + \sum_{i=1}^{k}w_iD_i. (4.61)
$$
​		对于这个中性模型，最重要的是，我们使用权重$w_i$添加所需的不同姿势的特征。 对于图4.15，设置$w_i=1$可使我们恰好位于插图中间。 使用$w_i=0.5$给我们一个半张微笑的脸，依此类推。 也可以使用负权重，也可以使用大于一的权重。

​		对于这个简单的脸部模型，我们可以添加表示“悲伤”眉毛。 负权重的眉毛会产生“快乐”的表情。 由于眉毛的位移是附加的，因此该眉毛姿势可与笑脸姿势一起使用。

​		渐变目标是一种强大的技术，可为动画师提供很多控制，因为模型的不同特征可以相互独立地进行操纵。 Lewis等 [1037]介绍了姿势空间渐变，它结合了顶点融合和顶点渐变目标。 Senior [1608]使用预先计算的顶点纹理来存储和检索目标姿势之间的替换。 支持流输出的硬件和每个顶点的ID允许在单个模型中使用更多目标，并且效果可以在GPU上专门计算[841，1074]。 使用低分辨率网格然后通过曲面细分阶段和替换映射生成高分辨率网格，可以避免在高度详细的模型中为每个顶点蒙皮的成本[1971]。

​		图4.16显示了同时使用蒙皮和渐变的真实示例。 Weronko和Andreason [1872]在《 The Order：1886》中使用了蒙皮和渐变。

![image-20191125224340010](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191125224340010.png)

​		<font size=2>图4.16。 Delsin角色在臭名昭著的Second Son中的脸部使用混合形状进行了动画处理。 所有这些拍摄都使用相同的静止姿势面孔，然后修改不同的权重以使面孔看起来有所不同。 （图片由Naughty Dog LLC提供。Infamous Second Son 2014年索尼互动娱乐LLC。InfamousSecond Son是Sony Interactive Entertainment LLC的商标。由Sucker Punch Productions LLC开发。）</font>

### 4.6几何缓存回放

​		在剪辑场景中，可能希望使用极高质量的动画，例如，对于无法使用上述任何方法表示的运动。 天真的方法是存储所有帧的所有顶点，从磁盘读取它们并更新网格。 但是，一个有30,000个顶点的简单模型在一个短动画中，这可能达到50 MB / s。 Gneiting [545]提出了几种将内存成本降低到大约10％的方法。

​		首先，使用量化。例如，位置和纹理坐标使用16位整数存储对于它们自身的坐标。这一步骤是有损的，在执行压缩后无法恢复原始数据的。为了进一步减少数据，进行了空间和时间预测，并对差异进行了编码。对于空间压缩，可以使用平行四边形预测[800]。对于三角形带，下一个顶点的预测位置就是当前三角形在其边周围的三角形平面中反射的当前三角形，从而形成平行四边形。与这个新位置的差异随后被编码。有了良好的预测，大多数值将接近零，这对于许多常用的压缩方案是理想的。与MPEG压缩类似，在时间维度上也进行预测。即，每n帧执行一次空间压缩。在这两者之间，将在时间维度上进行预测，例如，如果某个顶点通过增量向量从帧n-1移动到帧n，则很可能以相似的移动量到帧n + 1。这些技术减少了存储量足以使该系统可用于实时流数据。

### 4.7投影

​		在实际渲染场景之前，必须将场景中的所有相关对象投影到某种平面或某种简单体积上。 之后，将执行裁剪和渲染（第2.3节）。

​		本章到目前为止所看到的变换不影响第四个坐标（w分量）。 也就是说，点和向量在转换后仍保留其类型。 同样在4×4矩阵中，最底行始终为（0 0 0 1）。 透视投影矩阵是这两个属性的例外：最底行包含矢量和点操作数，并且经常需要归一化操作。 也就是说，w通常不是1，因此需要除以w才能获得非齐次点。 在本节中首先处理一种更简单也很常用的投影类型：正交投影。 它不会影响w分量。

​		在本部分中，假设观察者沿着相机的负z轴观看，y轴指向上方，x轴指向右侧。 这是一个右手坐标系。 某些文本和软件（例如DirectX）使用的是惯用左手的系统，在该系统中，观看者沿着相机的正Z轴看。 两种系统都是同等有效的，最后达到相同的效果。		

#### 4.7.1正交投影

​		正交投影的特征是平行线在投影之后保持平行。 当使用正交投影观看场景时，无论与相机的距离如何，对象都保持相同的大小。 矩阵$\mathbf{P}_o$，如下所示，是一个简单的正投影投影矩阵，它使一个点的x轴和y轴分量保持不变，而将z轴分量设置为零，即正交投影在平面z = 0上：
$$
\textbf{P}_o=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
1&0&0&0
\\
0&1&0&0
 \\
0&0&0&0
\\
0&0&0&1
\end{matrix}
\end{pmatrix}.
\qquad\qquad(4.62)
\end{gather*}
$$
​		图4.17说明了这种投影的效果。 显然矩阵$\mathbf{P}_o$是不可逆的，因为其行列式$|\mathbf{P}_o|=0$。换句话说，变换从三维降为二维，并且无法检索丢失的维度。 使用这种正交投影进行查看的问题在于，它将正值z点和负z值点都投影到投影平面上。 通常将z值（以及x和y值）限制为一定的范围是很有用的，例如从n（近平面）到f（远平面）。近平面也被称为 front plane 或者 hither; 远平面也被称为back plane 或者 yon。这种限制是平行投影的目的。

![image-20191126225539056](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191126225539056.png)

​		<font size=2>图4.17。 由公式4.62生成的简单正交投影的三种不同视图。 当观看者沿着负z轴看时，可以看到此投影，这意味着该投影仅跳过（或设置为零）z坐标，同时保持x和y坐标。 请注意，z = 0两侧的对象都投影到投影平面上。</font>

​		进行正交投影的更常见矩阵由六元组（l， r， b， t， n， f）表示，分别表示左侧，右侧，底部，顶部，近侧和远侧平面。 将由这些平面形成的与轴对齐的包围盒（AABB；请参见第22.2节中的定义）转换为以原点为中心的与轴对齐的立方体。 AABB的最小角为（l， b， n），最大角为（r， t， f）。 重要的是要认识到n> f，因为我们正朝着该空间体积的负z轴方向看。 我们的常识是，接近值应该比远端值低，因此可以让用户按原样提供它们，然后在内部取反它们。

​		在OpenGL中，与轴对齐的立方体的最小角为（-1，-1，-1），最大角为（1，1， 1）; 在DirectX中，范围是（-1，-1， 0）至（1，1， 1）。 该立方体称为规范视图体积，而该体积中的坐标称为规范化设备坐标。 转换过程如图4.18所示。 转换为规范视图体积的原因是裁剪能更有效地执行在该体积中。

​		转换为规范视图体积后，将要渲染的几何图形的顶点剪切到该立方体上。 不在立方体之外的几何图形最终被渲染通过将剩余的单位正方形映射到屏幕来。 此正交变换如下所示
$$
\textbf{P}_o=\textbf{S}(\textbf{s})\textbf{T}(\textbf{t})=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
\frac{2}{r-l}&0&0&0
\\
0&\frac{2}{t-b}&0&0
 \\
0&0&\frac{2}{f-n}&0
\\
0&0&0&1
\end{matrix}
\end{pmatrix}
\begin{pmatrix}
\begin{matrix}
1&0&0&-\frac{l+r}{2}
\\
0&1&0&-\frac{t+b}{2}
 \\
0&0&1&-\frac{f+n}{2}
\\
0&0&0&1
\end{matrix}
\end{pmatrix}\\=
\begin{pmatrix}
\begin{matrix}
\frac{2}{r-l}&0&0&-\frac{r+l}{r-l}
\\
0&\frac{2}{t-b}&0&-\frac{t+b}{t-b}
 \\
0&0&\frac{2}{f-n}&-\frac{f+n}{f-n}
\\
0&0&0&1
\end{matrix}
\end{pmatrix}
\qquad\qquad(4.63)
\end{gather*}
$$
​		正如这个等式如建议的，$\mathbf{P}_o$可以被写作变换的级联，平移变换$\mathbf{T}(\mathbf{t})$然后接着缩放矩阵$\mathbf{S}(\mathbf{s})$其中$\mathbf{s}=(2(r-l),2(t-b),2(f-n)),\mathbf{t}=(-(r+l)/2,-(t+b)/2,-(f+n)/2)$这个矩阵是可逆的（当且仅当$n\neq f,l\neq r,t\neq b$否者不存在逆矩阵）。即$\mathbf{P}_o^{-1}=\mathbf{T}(-\mathbf{t})\mathbf{S}((r-l)/2,(t-b)/2,(f-n)/2)$

​		在计算机图形学中，投影后最常使用左侧坐标系，即，对于视口，x轴向右，y轴向上，而z轴进入视口。 因为按照我们定义AABB的方式，远值小于近值，所以正交变换将始终包含一个镜像变换。 对于这一点，可以说原始的AABB尺寸与目标尺寸相同，即都是标准视图体积。 然后AABB的坐标分量对于（l， b， n）是（-1，-1， 1），对于（r， t， f）是（1， 1，-1）。 将其应用于方程式4.63可得出
$$
\textbf{P}_o=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
1&0&0&0
\\
0&1&0&0
 \\
0&0&-1&0
\\
0&0&0&1
\end{matrix}
\end{pmatrix}.
\qquad\qquad(4.64)
\end{gather*}
$$
​		这是一个镜像矩阵。 这种镜像将右手观察坐标系（从负z轴向下看）转换为左手归一化设备坐标系。

​		DirectX将z深度值映射到[0， 1]而不是OpenGL的[1， 1]。 这可以通过在正交矩阵之后应用简单的缩放和平移矩阵来完成，即

​		
$$
\textbf{M}_{st}=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
1&0&0&0
\\
0&1&0&0
 \\
0&0&0.5&0.5
\\
0&0&0&1
\end{matrix}
\end{pmatrix}.
\qquad\qquad(4.65)
\end{gather*}
$$
​		所以在DirectX中使用的正交矩阵为

​		
$$
\mathbf{P}_{o[0,1]}=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
\frac{2}{r-l}&0&0&-\frac{r+l}{r-l}
\\
0&\frac{2}{t-b}&0&-\frac{t+b}{t-b}
 \\
0&0&\frac{1}{f-n}&-\frac{n}{f-n}
\\
0&0&0&1
\end{matrix}
\end{pmatrix}
\qquad\qquad(4.66)
\end{gather*}
$$
​		由于DirectX使用行优先格式编写矩阵，因此这通常以转置形式出现。

#### 4.7.2平行投影

​		透视投影是比正交投影更复杂的变换，它通常在大多数计算机图形应用程序中使用。 在此平行线在投影之后通常不平行；当然，在极远处它们可能会收敛到一个点。透视更紧密地匹配我们如何感知世界，即更远的物体更小。

​	   首先，我们将提供有益的推导对投影到平面$z=d,d>0$上的透视投影矩阵。我们从世界空间中推导，以简化对世界到视图变换的理解。 此推导之后是更常规使用的矩阵，例如OpenGL [885]。

![image-20191128224313546](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191128224313546.png)

​		<font size=2>图4.19。 用于导出透视投影矩阵的符号。 将点$\mathbf{p}$投影到平面$z=d,d>0$，得出投影点$\mathbf{q}$。 投影是从摄影机位置的角度进行的，在本例中为原点。 右侧的$x$分量显示了推导中使用的相似三角形。</font>

​		假设摄像机（视点）位于原点，并且我们要将一个点$\mathbf{p}$投影到平面$z=d,d>0$，从而产生一个新点$\mathbf{q}=(q_x,q_y,-d)$  。 图4.19描绘了这种情况。 从该图所示的相似三角形中，以下推导得出$\mathbf{q} $的$x$分量的：
$$
\frac{q_x}{p_z}=\frac{-d}{p_z}\Leftrightarrow
q_x=-d\frac{p_x}{p_z}.
\qquad\quad(4.67)
$$
​		$\mathbf{q}$的其他分量的表达式为$q_y=-dp_y/p_z$（类似于$q_x$获得），$q_z=d$。 与上面的公式一起，它们给出了透视投影矩阵$\mathbf{P}_p$，如下所示：
$$
\textbf{P}_{p}=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
1&0&0&0
\\
0&1&0&0
 \\
0&0&1&0
\\
0&0&-1/d&1
\end{matrix}
\end{pmatrix}.
\qquad\qquad(4.68)
\end{gather*}
$$
​		该矩阵可产生正确的透视投影，可通过以下方式确认
$$
\textbf{q}=\mathbf{P}_p{\mathbf{p}}=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
1&0&0&0
\\
0&1&0&0
 \\
0&0&1&0
\\
0&0&-1/d&0
\end{matrix}
\end{pmatrix}
\begin{pmatrix}
\begin{matrix}
p_x
\\
p_y
 \\
p_z
\\
1
\end{matrix}
\end{pmatrix}=
\begin{pmatrix}
\begin{matrix}
p_x
\\
p_y
 \\
p_z
\\
-p_z/d
\end{matrix}
\end{pmatrix}\Rightarrow
\begin{pmatrix}
\begin{matrix}
-dp_x/p_z
\\
-dp_y/p_z
 \\
-dp_z/p_z
\\
1
\end{matrix}
\end{pmatrix}.
\qquad\qquad(4.69)
\end{gather*}
$$
​		最后一步来自以下事实：整个矢量除以$w$分量（在这种情况下为$-p_z/d$），最后得到1。由于我们要投影到该平面上，因此所得的$z$值始终为$-d$。

​		从直觉上讲，很容易理解为什么齐次坐标允许投影。齐次过程的一种几何解释是将点$(p_x,p_y,p_z)$投影到平面$w=1$上。

​		与正交变换一样，还有一个透视变换，而不是实际投影到平面（不可逆）上，而是将视锥从视锥变换为前述的规范视图体积。此处，视锥假定从$z=n$ 开始，结束在$z=f,0>n>f$。 $z=n$处的矩形在$(l,b,n)$处具有最小角，在$(r,t,n)$处具有最大角。如图4.20所示。

![image-20191128225854408](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191128225854408.png)

​		<font size=2>图4.20。 矩阵$\mathbf{P}_p$将视锥转换为单位立方体，也被称为规范视图体积。</font>

​		参数$(l,r,b,t,n,f)$确定摄像机的视锥。水平视野由视锥的左右平面（由$l$和$r$决定）之间的角度确定。以相同的方式，垂直视野由顶平面和底平面之间的角度（由$t$和$b$确定）确定。视野越大，相机“看得越多”。可以通过$r\neq-l$或$t\neq-b$来创建不对称的截头视锥。例如，不对称的截头视锥可用于立体观看和虚拟现实（第21.2.3节）。

​		视野是提供场景感的重要因素。与计算机屏幕相比，眼睛本身具有物理视野。这种关系是
$$
\phi=2\arctan(w/(2d)),\qquad\qquad (4.70)
$$
​		$\phi$是视场，$w$是垂直于视线的物体的宽度，$d$是到物体的距离。例如，一个25英寸的显示器大约为22英寸宽。在12英寸远处，水平视场为85度；在20英寸处为58度；在30英寸处为40度，可以使用相同的公式将摄像机镜头的尺寸转换为视场，例如，对于35mm摄像机的标准50mm镜头（镜框尺寸为36mm），其$\phi=2\arctan(36/(2\cdot50))=39.6$ = 39.6度。

​		与物理设置相比，使用更窄的视野将减少透视效果，因为观看者将放大场景。设置较宽的视野将使对象看起来失真（例如使用广角摄像机镜头），尤其是在屏幕边缘附近，并且会放大附近对象的比例。然而，较宽的视野使观看者感觉到物体更大并且更令人印象深刻，并且具有向用户提供有关周围环境的更多信息的优点。

​		公式4.71给出了将视锥转化为单位立方体的透视变换矩阵：
$$
\mathbf{P}_{p}=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
\frac{2n}{r-l}&0&-\frac{r+l}{r-l}&0
\\
0&\frac{2n}{t-b}&-\frac{t+b}{t-b}&0
 \\
0&0&\frac{f+n}{f-n}&-\frac{2fn}{f-n}
\\
0&0&1&0
\end{matrix}
\end{pmatrix}
\qquad\qquad(4.71)
\end{gather*}
$$
​		将转换应用到一个点后，我们将得到另一个点$\mathbf{q}=(q_x,q_y,q_z,q_w)^T$。此时的$w$分量$q_w$（通常）将为非零且不等于1。要获得投影点$\mathbf{p}$，我们需要除以$q_w$，即
$$
\mathbf{p}=(q_w/q_w,q_y/q_w,q_z/q_w,1).
\qquad\qquad(4.72)
$$
​		矩阵$\mathbf{P}_p$总是能看到$z=f$映射到+1和$z=n$映射到-1。

​		远平面以外的对象将被剪切，因此不会出现在场景中。透视投影可以处理取到无穷远的远平面，这使公式4.71变为
$$
\mathbf{P}_{p}=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
\frac{2n}{r-l}&0&-\frac{r+l}{r-l}&0
\\
0&\frac{2n}{t-b}&-\frac{t+b}{t-b}&0
 \\
0&0&1&-2n
\\
0&0&1&0
\end{matrix}
\end{pmatrix}
\qquad\qquad(4.73)
\end{gather*}
$$
​		综上所述，应用透视变换（以任何形式）$\mathbf{P}_p$，然后进行裁剪和齐次化（除以$w$），从而得到标准化的设备坐标。

​		要获得在OpenGL中使用的透视变换，出于与正交变换相同的原因，首先将其与$\textbf{S}(1,1,-1,1)$相乘。这仅会使等式4.71第三列中的值取反。在应用此镜像变换之后，将近值和远值作为正值输入，其中$0<n'<f'$，如传统上将它们呈现给用户一样。但是，它们仍然代表沿世界负z轴（即视线方向）的距离。出于参考目的，这是OpenGL方程：
$$
\mathbf{P}_{OpenGL}=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
\frac{2n'}{r-l}&0&\frac{r+l}{r-l}&0
\\
0&\frac{2n'}{t-b}&\frac{t+b}{t-b}&0
 \\
0&0&-\frac{f'+n'}{f'-n'}&-\frac{2f'n'}{f'-n'}
\\
0&0&-1&0
\end{matrix}
\end{pmatrix}
\qquad\qquad(4.74)
\end{gather*}
$$
​		一个更简单的设置是仅提供垂直视场$\phi$，长宽比$a=w/h$（其中$w×h$是屏幕分辨率），$n'$和$f'$。 这导致
$$
\mathbf{P}_{OpenGL}=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
c/a&0&0&0
\\
0&c&0&0
 \\
0&0&-\frac{f'+n'}{f'-n'}&-\frac{2f'n'}{f'-n'}
\\
0&0&-1&0
\end{matrix}
\end{pmatrix}
\qquad\qquad(4.75)
\end{gather*}
$$
​		其中$c = 1.0 / \tan（\phi/ 2）$。 该矩阵的作用与旧的gluPerspective（）完全一样，后者是OpenGL Utility Library（GLU）的一部分。

​		某些API（例如DirectX）将近平面映射到$z = 0$（而不是$z = -1$），而将远平面映射到$z =1$。此外，DirectX使用左手坐标系来定义其投影矩阵。 这意味着DirectX沿z轴正方向看，并以正数表示近和远值。 这是DirectX公式：
$$
\mathbf{P}_{p[0,1]}=
\begin{gather*}
\begin{pmatrix}
\begin{matrix}
\frac{2n'}{r-l}&0&-\frac{r+l}{r-l}&0
\\
0&\frac{2n'}{t-b}&-\frac{t+b}{t-b}&0
 \\
0&0&\frac{f'}{f'-n'}&-\frac{f'n'}{f'-n'}
\\
0&0&1&0
\end{matrix}
\end{pmatrix}
\qquad\qquad(4.76)
\end{gather*}
$$
​		DirectX在其文档中使用行优先形式，因此此矩阵通常以转置形式表示。

​		使用透视变换的一种效果是，计算出的深度值不会随输入pz值线性变化。 使用公式4.74–4.76中的任何一个乘以点$\mathbf{p}$，我们可以看到
$$
\mathbf{v}=\mathbf{P}_{\mathbf{p}}=
\begin{pmatrix}
\begin{matrix}
...
\\
...
 \\
dp_z+e
\\
\pm p_z
\end{matrix}
\end{pmatrix},
\qquad\qquad(4,77)
$$
​		其中省略了$v_x$和$v_y$的详细信息，并且常数$d$和$f$取决于所选矩阵。 例如，如果我们使用公式4.74，则$d =-（f'+ n'）/（f'-n'），e = -2f'n'/（f'-n'）$和$v_x = -p_z$ 。 要获得归一化设备坐标（**NDC**）中的深度，我们需要除以$w$分量，结果是
$$
z_{\textbf{DNC}}=\frac{dp_z+e}{-p_z}=d-\frac{e}{p_z},
\qquad\qquad(4.78)
$$
​		其中$zNDC∈[−1，+1]$对于OpenGL投影。 可以看出，输出深度$zNDC$与输入深度$p_z$成反比。

​		例如，如果$n'= 10$且$f'= 110$（使用OpenGL术语），则当$p_z$在负z轴（即中点）下沿60个单位时，归一化设备坐标深度值为0.833，而不是0。 图4.21显示了改变近平面到原点的距离的产生的影响。 近平面和远平面的放置会影响z缓冲区的精度。 第23.7节将进一步讨论这种影响。

![image-20191128233147337](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191128233147337.png)

​		<font size=2>图4.21。 改变近平面到原点的距离的效果。 距离$f'-n'$保持恒定为100。随着近平面变得更靠近原点，更接近远平面的点使用的归一化设备坐标（**NDC**）深度空间的范围更小。 这会使z缓冲区在较大距离处的准确性降低。</font>

​		有几种增加深度精度的方法。 一种常见的方法（我们称为反向z）是使用浮点深度或整型存储1.0 − zNDC [978]。 比较如图4.22所示。 Reed [1472]通过仿真显示，使用带反向z的浮点缓冲区可提供最佳精度，同时这也是整型深度缓冲区（通常每个深度有24bit）的首选方法。 对于标准映射（即非反向z）在变换中分离投影矩阵可降低错误率，如Upchurch和Desbrun [1803]所建议的。 例如，在$\mathbf{T} = \mathbf{PM}$的情况下，使用$\mathbf{P}（\mathbf{Mp}）$比使用$\mathbf{Tp}$更好。 同样，在$[0.5，1.0]$的范围内，fp32和int24的精度非常相似，因为fp32具有23bit的尾数。 使zNDC与$1 / p_z$成正比的原因是，它使硬件更简单并且压缩深度值更加成功，这将在23.7节中详细讨论。

![image-20191129232931850](C:\Users\tionerter\AppData\Roaming\Typora\typora-user-images\image-20191129232931850.png)

​		<font size=2>图4.22。 使用DirectX变换设置深度缓冲区的几种方法，即zNDC∈[0，+1]。 左上方：标准整型深度缓冲区，此处显示为4位精度（因此y轴上有16个标记）。 右上角：远端平面设置为∞，在两个轴上的小位移不会损失太多精度。 左下：具有3个指数位和3个尾数位用于浮点深度。 注意，分布在y轴上是非线性的，这使得在x轴上的分布更糟。 右下：浮点深度反转，即1 − zNDC，分布要好得多。 （插图由内森·里德（Nathan Reed）提供。）</font>

​		劳埃德[1063]提出使用深度值的对数来提高阴影贴图的精度。 Lauritzen等[991]使用前一帧的z缓冲区确定最大近平面和最小远平面。 对于屏幕空间深度，Kemen [881]建议对每个顶点使用以下重新映射：
$$
\begin{align}
z&=w(\log_2(\text{max}(10^{-6},1+w))f_c-1),[\text{OpenGL}]\\
z&=w\log_2(\text{max}(10^{-6},1+w))f_c/2,[\text{DirectX}]
\end{align}
\qquad\qquad(4.79)
$$
​		其中$w$是投影矩阵之后的顶点的$w$值，而$z$是顶点着色器的输出$z$。常数$f_c = 2 / log2（f +1）$，其中$f$为远平面。当仅应用此变换在顶点着色器中时，深度仍将在三角形上被线性插值通过GPU在顶点的非线性变换深度之间（公式4.79）。由于对数是单调函数，因此只要分段线性插值与精确的非线性变换深度值之间的差异较小，遮挡剔除硬件和深度压缩技术仍将起作用。对于大多数具有足够的几何细分的情况，这是正确的。但是，也可以对每个片段应用转换。这是通过输出每个顶点的值$e = 1 + w$来完成的，然后由GPU在三角形上进行插值。然后，像素着色器将片段深度修改为$\log2（e_i）f_c / 2$，其中$e_i$是$e$的插值。当GPU中没有浮点深度并且使用深度较大的距离进行渲染时，此方法是一个很好的选择。

​		Cozzi [1605]建议使用多个视锥，这可以提高精度以有效地达到任何所需的比率。 视锥在深度方向上分为几个不重叠的较小的子视锥，它们的组合是原先的视锥。 子视锥表以从后到前的顺序渲染。 首先，清空颜色和深度缓冲区，并将所有要渲染的对象分类到它们重叠的每个子视锥中。 对于每个子视锥，设置其投影矩阵，清空深度缓冲区，然后渲染与子视锥重叠的对象。

### 进一步阅读和资源

​		沉浸式线性代数站点[1718]提供了一本关于该主题基础知识的互动书籍，通过鼓励您操纵数字来帮助建立直觉。其他的交互式学习工具和转换代码库都来自realtimerendering.com。

​		法林（Farin）和汉斯福德（Hansford）的《几何工具箱》（The Geometry Toolbox）[461]是一部以无痛的方式建立对矩阵的直觉的最佳书籍之一。另一个有用的著作是Lengyel的“ 3D游戏编程和计算机图形学数学” [1025]。从不同的角度来看，许多计算机图形学文本，例如Hearn和Baker [689]，Marschner和Shirley [1129]，以及Hughes等人 [785]也涵盖了矩阵基础知识。 Ochiai等人的课程[1310]介绍了矩阵的基础，以及矩阵的指数和对数，以及用于计算机图形学的知识。 Graphics Gems系列[72、540、695、902、1344]提出了各种与变换相关的算法，并且在线提供了许多此类算法的代码。 Golub和Van Loan的矩阵计算[556]通常是认真研究矩阵技术的起点。有关骨架-子空间变形/顶点融合和形状插值的更多信息，请参见Lewis等人的SIGGRAPH论文[1037]。 ]。

​		Hart等人[674]和Hanson [663]提供了四元数的可视化。 Pletinckx [1421]和Schlag [1566]提出了在一组四元数之间平滑内插的不同方法。 Vlachos和Isidoro [1820]推导了四元数的$c^2$插值公式。四元数插值是沿曲线计算相符的坐标系的问题。 Dougan [374]对此进行了处理。

​		Alexa [28]和Lazarus and Verroust [1000]对许多不同的变形技术进行了调查。父母的书[1354]是有关计算机动画技术的绝佳来源。